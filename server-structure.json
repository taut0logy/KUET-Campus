[
  {
    "type": "file",
    "name": ".env",
    "path": "E:\\Work\\MIST_Hackathon\\server\\.env",
    "size": 2487,
    "content": null
  },
  {
    "type": "file",
    "name": ".gitignore",
    "path": "E:\\Work\\MIST_Hackathon\\server\\.gitignore",
    "size": 148,
    "content": null
  },
  {
    "type": "file",
    "name": "Dockerfile",
    "path": "E:\\Work\\MIST_Hackathon\\server\\Dockerfile",
    "size": 2651,
    "content": null
  },
  {
    "type": "file",
    "name": "package-lock.json",
    "path": "E:\\Work\\MIST_Hackathon\\server\\package-lock.json",
    "size": 167788,
    "content": "File too large to display"
  },
  {
    "type": "file",
    "name": "package.json",
    "path": "E:\\Work\\MIST_Hackathon\\server\\package.json",
    "size": 1618,
    "content": "{\r\n  \"name\": \"server\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"Backend server with Supabase authentication and role-based access\",\r\n  \"main\": \"src/index.js\",\r\n  \"scripts\": {\r\n    \"start\": \"node src/index.js\",\r\n    \"dev\": \"nodemon src/index.js\",\r\n    \"prisma:generate\": \"prisma generate\",\r\n    \"prisma:studio\": \"prisma studio\",\r\n    \"prisma:migrate\": \"prisma migrate dev\",\r\n    \"lint\": \"eslint .\",\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\r\n    \"seed\": \"node prisma/seeders/seed.js\"\r\n  },\r\n  \"prisma\": {\r\n    \"seed\": \"node prisma/seeders/seed.js\"\r\n  },\r\n  \"keywords\": [\r\n    \"express\",\r\n    \"supabase\",\r\n    \"prisma\",\r\n    \"authentication\",\r\n    \"role-based-access\"\r\n  ],\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"@google/generative-ai\": \"^0.23.0\",\r\n    \"@prisma/client\": \"^5.10.2\",\r\n    \"@socket.io/redis-adapter\": \"^8.3.0\",\r\n    \"@supabase/supabase-js\": \"^2.49.1\",\r\n    \"bcrypt\": \"^5.1.1\",\r\n    \"compression\": \"^1.7.4\",\r\n    \"cookie-parser\": \"^1.4.6\",\r\n    \"cors\": \"^2.8.5\",\r\n    \"dotenv\": \"^16.3.1\",\r\n    \"express\": \"^4.21.2\",\r\n    \"express-rate-limit\": \"^7.1.5\",\r\n    \"express-validator\": \"^7.2.1\",\r\n    \"helmet\": \"^7.1.0\",\r\n    \"http-errors\": \"^2.0.0\",\r\n    \"jsonwebtoken\": \"^9.0.2\",\r\n    \"morgan\": \"^1.10.0\",\r\n    \"multer\": \"^1.4.5-lts.1\",\r\n    \"nodemailer\": \"^6.9.8\",\r\n    \"pino\": \"^9.6.0\",\r\n    \"pino-http\": \"^10.4.0\",\r\n    \"pino-pretty\": \"^13.0.0\",\r\n    \"redis\": \"^4.7.0\",\r\n    \"socket.io\": \"^4.8.1\",\r\n    \"uuid\": \"^11.1.0\",\r\n    \"winston\": \"^3.17.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"eslint\": \"^8.56.0\",\r\n    \"nodemon\": \"^3.0.3\",\r\n    \"prisma\": \"^5.10.2\"\r\n  }\r\n}\r\n"
  },
  {
    "type": "directory",
    "name": "prisma",
    "path": "E:\\Work\\MIST_Hackathon\\server\\prisma",
    "children": [
      {
        "type": "directory",
        "name": "migrations",
        "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations",
        "children": [
          {
            "type": "directory",
            "name": "20250302142612_",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250302142612_",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250302142612_\\migration.sql",
                "size": 5157,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250302202912_add_multiple_roles_to_user",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250302202912_add_multiple_roles_to_user",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250302202912_add_multiple_roles_to_user\\migration.sql",
                "size": 266,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250303141432_",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250303141432_",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250303141432_\\migration.sql",
                "size": 576,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250303162609_add_notification_metadata",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250303162609_add_notification_metadata",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250303162609_add_notification_metadata\\migration.sql",
                "size": 90,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250304085403_add_bus_section",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304085403_add_bus_section",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304085403_add_bus_section\\migration.sql",
                "size": 3821,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250304121309_init",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304121309_init",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304121309_init\\migration.sql",
                "size": 1148,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250304143321_",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304143321_",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304143321_\\migration.sql",
                "size": 90,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250304145952_",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304145952_",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304145952_\\migration.sql",
                "size": 1336,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250304192115_abir",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304192115_abir",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304192115_abir\\migration.sql",
                "size": 1306,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250304194120_add_preorder_quantity",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304194120_add_preorder_quantity",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250304194120_add_preorder_quantity\\migration.sql",
                "size": 1030,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250305001608_meow",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305001608_meow",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305001608_meow\\migration.sql",
                "size": 4137,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250305002910_",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305002910_",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305002910_\\migration.sql",
                "size": 1142,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250305041540_update_bus_schedule_time",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305041540_update_bus_schedule_time",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305041540_update_bus_schedule_time\\migration.sql",
                "size": 6577,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250305150843_",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305150843_",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305150843_\\migration.sql",
                "size": 561,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250305205713_make_pickup_time_nullable",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305205713_make_pickup_time_nullable",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305205713_make_pickup_time_nullable\\migration.sql",
                "size": 358,
                "content": null
              }
            ]
          },
          {
            "type": "directory",
            "name": "20250305222023_add_detailed_nutrition_fields",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305222023_add_detailed_nutrition_fields",
            "children": [
              {
                "type": "file",
                "name": "migration.sql",
                "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\20250305222023_add_detailed_nutrition_fields\\migration.sql",
                "size": 754,
                "content": null
              }
            ]
          },
          {
            "type": "file",
            "name": "migration_lock.toml",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\migrations\\migration_lock.toml",
            "size": 126,
            "content": null
          }
        ]
      },
      {
        "type": "file",
        "name": "schema.prisma",
        "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\schema.prisma",
        "size": 19890,
        "content": "generator client {\r\n  provider = \"prisma-client-js\"\r\n}\r\n\r\ndatasource db {\r\n  provider  = \"postgresql\"\r\n  url       = env(\"DATABASE_URL\")\r\n  directUrl = env(\"DIRECT_URL\")\r\n}\r\n\r\nenum UserRole {\r\n  ADMIN\r\n  STUDENT\r\n  FACULTY\r\n  OFFICE_MANAGER\r\n  CAFE_MANAGER\r\n}\r\n\r\nenum UserStatus {\r\n  ACTIVE\r\n  INACTIVE\r\n  SUSPENDED\r\n}\r\n\r\nenum ClubRole {\r\n  MEMBER\r\n  MODERATOR\r\n  MANAGER\r\n}\r\n\r\nenum ClubStatus {\r\n  ACTIVE\r\n  INACTIVE\r\n  BANNED\r\n}\r\n\r\nenum FacultyDesignation {\r\n  PROFESSOR\r\n  ASSOCIATE_PROFESSOR\r\n  ASSISTANT_PROFESSOR\r\n  LECTURER\r\n  SENIOR_LECTURER\r\n  TEACHERS_ASSISTANT\r\n}\r\n\r\nenum FacultyStatus {\r\n  GUEST\r\n  PERMANENT\r\n  PART_TIME\r\n}\r\n\r\nmodel User {\r\n  id                Int            @id @default(autoincrement())\r\n  email             String         @unique @db.VarChar(255)\r\n  password          String\r\n  name              String         @db.VarChar(255)\r\n  cart              Cart?\r\n  roles             UserRole[]     @default([STUDENT])\r\n  employeeInfo      EmployeeInfo?  @relation(\"UserEmployeeInfo\")\r\n  studentInfo       StudentInfo?   @relation(\"UserStudentInfo\")\r\n  facultyInfo       FacultyInfo?   @relation(\"UserFacultyInfo\")\r\n  works             Work[]         @relation(\"UserWorks\")\r\n  status            UserStatus     @default(ACTIVE)\r\n  emailVerified     Boolean        @default(false)\r\n  verificationToken String?\r\n  resetToken        String?\r\n  resetTokenExpiry  DateTime?\r\n  createdAt         DateTime       @default(now())\r\n  updatedAt         DateTime       @updatedAt\r\n  sessions          Session[]\r\n  messages          Message[]      @relation(\"MessageSender\")\r\n  receivedMessages  Message[]      @relation(\"MessageReceiver\")\r\n  notifications     Notification[]\r\n  preorders         Preorder[]\r\n  routine           Routine[]\r\n  course            Course[]\r\n  clubs             UserClub[]      @relation(\"UserClubs\")\r\n  managedClubs      UserClubManager[]      @relation(\"ClubManagers\")\r\n  moderatedClubs    Club[]          @relation(\"ClubModerator\")\r\n  eventFollowers    Event[]         @relation(\"EventFollowers\")\r\n  clubFollowers     Club[]          @relation(\"ClubFollowers\")\r\n  clubTags          ClubTag[]       @relation(\"ClubTagFollowers\")\r\n  eventTags         EventTag[]      @relation(\"EventTagFollowers\")\r\n  userVisits        UserVisit[]\r\n  followUnfollowLogs FollowUnfollowLog[]\r\n  eventVisits       EventVisit[]\r\n  eventFollowUnfollowLogs EventFollowUnfollowLog[]\r\n  Assignment        Assignment[]\r\n  Exam              Exam[]\r\n\r\n  @@map(\"users\")\r\n}\r\n\r\nmodel Work {\r\n  id          Int         @id @default(autoincrement())\r\n  title       String      @db.VarChar(255)\r\n  startTime   DateTime\r\n  endTime     DateTime\r\n  description String?     @db.Text\r\n  facultyId   Int\r\n  faculty     FacultyInfo @relation(\"FacultyWorks\", fields: [facultyId], references: [id])\r\n  user        User        @relation(\"UserWorks\", fields: [userId], references: [id])\r\n  userId      Int\r\n}\r\n\r\nmodel Department {\r\n  id        Int           @id @default(autoincrement())\r\n  name      String        @unique @db.VarChar(255)\r\n  alias     String        @unique @db.VarChar(10)\r\n  faculty   String        @db.VarChar(255)\r\n  students  StudentInfo[]\r\n  faculties FacultyInfo[]\r\n}\r\n\r\nmodel FacultyInfo {\r\n  id           Int                @id @default(autoincrement())\r\n  employeeId   String             @unique @db.VarChar(50)\r\n  status       FacultyStatus\r\n  designation  FacultyDesignation\r\n  departmentId Int\r\n  department   Department         @relation(fields: [departmentId], references: [id])\r\n  bio          String?            @db.Text\r\n  user         User               @relation(\"UserFacultyInfo\", fields: [userId], references: [id])\r\n  userId       Int                @unique\r\n  works        Work[]             @relation(\"FacultyWorks\")\r\n}\r\n\r\nmodel EmployeeInfo {\r\n  id          Int    @id @default(autoincrement())\r\n  employeeId  String @unique @db.VarChar(50)\r\n  designation String @db.VarChar(100)\r\n  user        User?  @relation(\"UserEmployeeInfo\", fields: [userId], references: [id])\r\n  userId      Int?   @unique\r\n}\r\n\r\nmodel StudentInfo {\r\n  id           Int        @id @default(autoincrement())\r\n  studentId    String     @unique @db.VarChar(50)\r\n  section      String     @db.VarChar(10)\r\n  batch        Int\r\n  user         User       @relation(\"UserStudentInfo\", fields: [userId], references: [id])\r\n  userId       Int        @unique\r\n  departmentId Int\r\n  department   Department @relation(fields: [departmentId], references: [id])\r\n}\r\n\r\nmodel Session {\r\n  id        String   @id @default(uuid())\r\n  userId    Int\r\n  token     String   @unique\r\n  expiresAt DateTime\r\n  createdAt DateTime @default(now())\r\n  updatedAt DateTime @updatedAt\r\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\r\n\r\n  @@map(\"sessions\")\r\n}\r\n\r\nmodel Message {\r\n  id         String   @id @default(uuid())\r\n  content    String\r\n  senderId   Int\r\n  receiverId Int?\r\n  isRead     Boolean  @default(false)\r\n  createdAt  DateTime @default(now())\r\n  updatedAt  DateTime @updatedAt\r\n  sender     User     @relation(\"MessageSender\", fields: [senderId], references: [id], onDelete: Cascade)\r\n  receiver   User?    @relation(\"MessageReceiver\", fields: [receiverId], references: [id], onDelete: SetNull)\r\n\r\n  @@map(\"messages\")\r\n}\r\n\r\nmodel Notification {\r\n  id        String   @id @default(uuid())\r\n  userId    Int\r\n  title     String\r\n  message   String\r\n  isRead    Boolean  @default(false)\r\n  type      String   @default(\"INFO\")\r\n  metadata  Json?    @default(\"{}\")\r\n  createdAt DateTime @default(now())\r\n  updatedAt DateTime @updatedAt\r\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\r\n\r\n  @@map(\"notifications\")\r\n}\r\n\r\nmodel Meal {\r\n  id          Int        @id @default(autoincrement()) @map(\"meal_id\")\r\n  name        String\r\n  description String?    @db.Text\r\n  price       Decimal\r\n  category    String\r\n  isVegan     Boolean    @default(false)\r\n  isGlutenFree Boolean   @default(false)\r\n  isSugarFree Boolean    @default(false)\r\n  isLowFat    Boolean    @default(false)\r\n  isOrganic   Boolean    @default(false)\r\n  calories    Int?\r\n  protein     Int?\r\n  carbs       Int?\r\n  fat         Int?\r\n  fiber       Int?\r\n  sugar       Int?\r\n  sodium      Int?\r\n  vitaminA    Int?\r\n  vitaminC    Int?\r\n  calcium     Int?\r\n  iron        Int?\r\n  allergens   Json?\r\n  cartItems   CartItem[]\r\n  preorders   Preorder[]\r\n\r\n  @@map(\"meals\")\r\n}\r\n\r\nmodel Preorder {\r\n  id               Int      @id @default(autoincrement())\r\n  userId           Int\r\n  user             User     @relation(fields: [userId], references: [id])\r\n  mealId           Int\r\n  meal             Meal     @relation(fields: [mealId], references: [id])\r\n  quantity         Int      @default(1)\r\n  status           String   @default(\"pending_approval\")\r\n  orderTime        DateTime @default(now())\r\n  pickupTime       DateTime?\r\n  verificationCode String   @unique\r\n  rejectionReason  String?\r\n  createdAt        DateTime @default(now())\r\n  updatedAt        DateTime @updatedAt\r\n\r\n  @@map(\"preorders\")\r\n}\r\n\r\nmodel Cart {\r\n  id        Int        @id @default(autoincrement()) @map(\"cart_id\")\r\n  userId    Int        @unique\r\n  user      User       @relation(fields: [userId], references: [id])\r\n  items     CartItem[]\r\n  createdAt DateTime   @default(now())\r\n  updatedAt DateTime   @updatedAt\r\n\r\n  @@map(\"carts\")\r\n}\r\n\r\nmodel CartItem {\r\n  id         Int      @id @default(autoincrement()) @map(\"cart_item_id\")\r\n  cartId     Int\r\n  cart       Cart     @relation(fields: [cartId], references: [id])\r\n  mealId     Int\r\n  meal       Meal     @relation(fields: [mealId], references: [id])\r\n  quantity   Int      @default(1)\r\n  createdAt  DateTime @default(now())\r\n  updatedAt  DateTime @updatedAt\r\n\r\n  @@unique([cartId, mealId])\r\n  @@map(\"cart_items\")\r\n}\r\n\r\nmodel Routine {\r\n  id      String  @id @default(uuid())\r\n  userId  Int // Foreign key to User\r\n  weekday String // Weekday (e.g., \"Sunday\", \"Monday\", etc.)\r\n  period1 String? // Course for period 1\r\n  period2 String? // Course for period 2\r\n  period3 String? // Course for period 3\r\n  period4 String? // Course for period 4\r\n  period5 String? // Course for period 5\r\n  period6 String? // Course for period 6\r\n  period7 String? // Course for period 7\r\n  period8 String? // Course for period 8\r\n  period9 String? // Course for period 9\r\n  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)\r\n\r\n  @@unique([weekday, userId])\r\n  @@map(\"routines\")\r\n}\r\n\r\nmodel Course {\r\n  id         String       @id @default(uuid())\r\n  courseId   String       @unique\r\n  courseName String\r\n  courseType String\r\n  userId     Int // Foreign key to User\r\n  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)\r\n  Assignment Assignment[]\r\n  Exam       Exam[] // Add relation to Exam model\r\n\r\n  @@map(\"courses\")\r\n}\r\n\r\nmodel Assignment {\r\n  id                        String   @id @default(uuid()) @map(\"assignment_id\")\r\n  userId                    Int      @map(\"user_id\")\r\n  courseId                  String   @map(\"course_id\")\r\n  assignmentName            String   @map(\"assignment_name\")\r\n  assignmentContent         String?  @map(\"assignment_content\") @db.Text\r\n  deadline                  DateTime\r\n  status                    String   @default(\"due\") // Add status field with default value\r\n  notifiedFor24HourDeadline Boolean  @default(false)\r\n  createdAt                 DateTime @default(now())\r\n  updatedAt                 DateTime @updatedAt\r\n  user                      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\r\n  course                    Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)\r\n\r\n  @@map(\"assignments\")\r\n}\r\n\r\n// New model for exams\r\nmodel Exam {\r\n  id        String   @id @default(uuid())\r\n  userId    Int // Foreign key to User\r\n  courseId  String // Foreign key to Course\r\n  examType  String // \"term-final\", \"class-test\", \"lab-test\"\r\n  syllabus  String?  @db.Text\r\n  examDate  DateTime\r\n  createdAt DateTime @default(now())\r\n  updatedAt DateTime @updatedAt\r\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\r\n  course    Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)\r\n\r\n  @@map(\"exams\")\r\n}\r\n\r\n\r\n// Bus related models\r\nenum ScheduleStatus {\r\n  SCHEDULED\r\n  IN_PROGRESS\r\n  COMPLETED\r\n  CANCELLED\r\n  DELAYED\r\n  PENDING\r\n}\r\n\r\nenum MaintenanceType {\r\n  ROUTINE\r\n  REPAIR\r\n  INSPECTION\r\n}\r\n\r\nenum BusType {\r\n  SHUTTLE\r\n  MINIBUS\r\n  ARTICULATED\r\n}\r\n\r\nenum FrequencyType {\r\n  DAILY\r\n  WEEKDAYS\r\n  WEEKLY\r\n}\r\n\r\nenum Direction {\r\n  CLOCKWISE\r\n  COUNTER_CLOCKWISE\r\n}\r\n\r\nmodel Bus {\r\n  id           String           @id @default(uuid())\r\n  busNumber    String           @unique\r\n  licensePlate String? // Made nullable first\r\n  capacity     Int\r\n  type         BusType? // Using enum instead of String\r\n  isActive     Boolean          @default(true)\r\n  description  String?\r\n  routes       BusRoute[] // Add reverse relation\r\n  createdAt    DateTime         @default(now())\r\n  updatedAt    DateTime         @updatedAt\r\n  schedules    BusSchedule[]\r\n  drivers      Driver[]\r\n  maintenance  MaintenanceLog[]\r\n\r\n  @@map(\"buses\")\r\n}\r\n\r\nmodel Driver {\r\n  id            String        @id @default(uuid())\r\n  firstName     String\r\n  lastName      String\r\n  licenseNumber String        @unique\r\n  phone         String?\r\n  isAvailable   Boolean       @default(true)\r\n  availability  String? // Consider creating an enum for this\r\n  schedules     BusSchedule[]\r\n  buses         Bus[]\r\n  createdAt     DateTime      @default(now())\r\n  updatedAt     DateTime      @updatedAt\r\n\r\n  @@index([isAvailable]) // Add index for frequent queries\r\n  @@map(\"drivers\")\r\n}\r\n\r\nmodel BusRoute {\r\n  id         String        @id @default(uuid())\r\n  routeName  String\r\n  routeCode  String? // Made nullable first\r\n  startPoint String\r\n  endPoint   String\r\n  distance   Float // in kilometers\r\n  duration   Int // in minutes\r\n  direction  Direction? // Using enum instead of String\r\n  isActive   Boolean       @default(true)\r\n  busId      String\r\n  bus        Bus           @relation(fields: [busId], references: [id], onDelete: Cascade)\r\n  schedules  BusSchedule[]\r\n  stops      BusStop[]\r\n  createdAt  DateTime      @default(now())\r\n  updatedAt  DateTime      @updatedAt\r\n\r\n  @@index([isActive]) // Add index for frequent queries\r\n  @@map(\"bus_routes\")\r\n}\r\n\r\nmodel BusStop {\r\n  id            String   @id @default(uuid())\r\n  stopName      String\r\n  sequence      Int\r\n  timeFromStart Int? // First make it nullable\r\n  routeId       String\r\n  route         BusRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)\r\n  campusZone    String?\r\n  latitude      Float?\r\n  longitude     Float?\r\n  createdAt     DateTime @default(now())\r\n  updatedAt     DateTime @updatedAt\r\n\r\n  @@unique([routeId, sequence])\r\n  @@unique([stopName, routeId])\r\n  @@index([routeId])\r\n  @@map(\"bus_stops\")\r\n}\r\n\r\nmodel BusSchedule {\r\n  id                String         @id @default(uuid())\r\n  busId             String\r\n  routeId           String\r\n  driverId          String?\r\n  departureTime     String // Consider using DateTime with @db.Time\r\n  arrivalTime       String // Consider using DateTime with @db.Time\r\n  bookedSeats       Int            @default(0)\r\n  totalCapacity     Int            @default(50) // Added default\r\n  availableSeats    Int            @default(50) // Added default\r\n  isRecurring       Boolean        @default(false)\r\n  recurrencePattern String?\r\n  frequency         FrequencyType  @default(DAILY) // Added default\r\n  validFrom         DateTime       @default(now()) // Added default\r\n  validUntil        DateTime?\r\n  status            ScheduleStatus @default(SCHEDULED)\r\n  bus               Bus            @relation(fields: [busId], references: [id], onDelete: Cascade)\r\n  route             BusRoute       @relation(fields: [routeId], references: [id], onDelete: Cascade)\r\n  driver            Driver?        @relation(fields: [driverId], references: [id], onDelete: SetNull)\r\n  reminders         Reminder[]\r\n  createdAt         DateTime       @default(now())\r\n  updatedAt         DateTime       @updatedAt\r\n\r\n  @@index([status]) // Add index for frequent queries\r\n  @@index([validFrom]) // Add index for date queries\r\n  @@map(\"bus_schedules\")\r\n}\r\n\r\nmodel MaintenanceLog {\r\n  id              String          @id @default(uuid())\r\n  busId           String\r\n  maintenanceDate DateTime\r\n  type            MaintenanceType // Using enum instead of String\r\n  description     String\r\n  cost            Decimal?        @db.Decimal(10, 2)\r\n  nextDueDate     DateTime?\r\n  bus             Bus             @relation(fields: [busId], references: [id], onDelete: Cascade)\r\n  createdAt       DateTime        @default(now())\r\n  updatedAt       DateTime        @updatedAt\r\n\r\n  @@index([maintenanceDate]) // Add index for date queries\r\n  @@map(\"maintenance_logs\")\r\n}\r\n\r\nmodel Reminder {\r\n  id           String      @id @default(uuid())\r\n  studentId    String // Consider adding proper relation to User/Student model\r\n  scheduleId   String\r\n  reminderTime DateTime\r\n  busSchedule  BusSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)\r\n  createdAt    DateTime    @default(now())\r\n  updatedAt    DateTime    @updatedAt\r\n\r\n  @@index([reminderTime]) // Add index for date queries\r\n  @@index([studentId]) // Add index for frequent queries\r\n  @@map(\"reminders\")\r\n}\r\n\r\nmodel Club {\r\n  id           Int        @id @default(autoincrement())\r\n  name         String     @db.VarChar(255)\r\n  coverPhoto   String?    @db.VarChar(255)\r\n  slug         String     @unique @db.VarChar(255)\r\n  description  String?    @db.Text\r\n  foundingDate DateTime\r\n  moderatorId  Int\r\n  moderator    User       @relation(\"ClubModerator\", fields: [moderatorId], references: [id])\r\n  managers     UserClubManager[]\r\n  tags         Json\r\n  members      UserClub[] @relation\r\n  events       Event[]    @relation\r\n  clubTag      ClubTag?   @relation(fields: [clubTagId], references: [id])\r\n  clubTagId    Int?\r\n  followers    User[]     @relation(\"ClubFollowers\")\r\n  clubAlbums   ClubAlbum[]\r\n  userVisits   UserVisit[]\r\n  followUnfollowLogs FollowUnfollowLog[]\r\n}\r\n\r\nmodel UserClub {\r\n  id       Int        @id @default(autoincrement())\r\n  userId   Int\r\n  clubId   Int\r\n  joinDate DateTime   @default(now())\r\n  role     ClubRole   @default(MEMBER)\r\n  status   ClubStatus @default(ACTIVE)\r\n  user     User       @relation(\"UserClubs\", fields: [userId], references: [id], map: \"UserClub_userId_fkey1\")\r\n  club     Club       @relation(fields: [clubId], references: [id], map: \"UserClub_clubId_fkey1\")\r\n}\r\n\r\nmodel UserClubManager {\r\n  id       Int        @id @default(autoincrement())\r\n  userId   Int\r\n  clubId   Int\r\n  joinDate DateTime   @default(now())\r\n  role     ClubRole   @default(MANAGER)\r\n  user     User       @relation(\"ClubManagers\", fields: [userId], references: [id], map: \"UserClubManager_userId_fkey\")\r\n  club     Club       @relation(fields: [clubId], references: [id], map: \"UserClubManager_clubId_fkey\")\r\n}\r\n\r\nmodel ClubTag {\r\n  id          Int     @id @default(autoincrement())\r\n  name        String  @db.VarChar(255)\r\n  description String? @db.Text\r\n  clubs       Club[]  @relation\r\n  followers   User[]  @relation(\"ClubTagFollowers\")\r\n}\r\n\r\nmodel EventTag {\r\n  id          Int     @id @default(autoincrement())\r\n  name        String  @db.VarChar(255)\r\n  description String? @db.Text\r\n  events      Event[] @relation\r\n  followers   User[]  @relation(\"EventTagFollowers\")\r\n}\r\n\r\nmodel ClubAlbum {\r\n  id          Int       @id @default(autoincrement())\r\n  clubId      Int\r\n  club        Club      @relation(fields: [clubId], references: [id])\r\n  photos      Json\r\n  createdAt   DateTime  @default(now())\r\n  updatedAt   DateTime  @updatedAt\r\n  clubAlbumPhotos ClubAlbumPhoto[]\r\n}\r\n\r\nmodel ClubAlbumPhoto {\r\n  id          Int       @id @default(autoincrement())\r\n  clubAlbumId Int\r\n  clubAlbum   ClubAlbum @relation(fields: [clubAlbumId], references: [id])\r\n  photoUrl    String    @db.VarChar(255)\r\n  createdAt   DateTime  @default(now())\r\n  updatedAt   DateTime  @updatedAt\r\n}\r\n\r\nmodel Event {\r\n  id          Int       @id @default(autoincrement())\r\n  name        String    @db.VarChar(255)\r\n  coverPhoto  String?   @db.VarChar(255)\r\n  slug        String    @unique @db.VarChar(255)\r\n  description String?   @db.Text\r\n  startTime   DateTime\r\n  endTime     DateTime\r\n  eventLinks  Json\r\n  tags        EventTag[]\r\n  clubId      Int\r\n  club        Club      @relation(fields: [clubId], references: [id])\r\n  followers   User[]    @relation(\"EventFollowers\")\r\n  eventVisits EventVisit[]\r\n  eventFollowUnfollowLogs EventFollowUnfollowLog[]\r\n}\r\n\r\nmodel UserVisit {\r\n  id        Int      @id @default(autoincrement())\r\n  userId    Int\r\n  clubId    Int\r\n  visitedAt DateTime @default(now())\r\n  user      User     @relation(fields: [userId], references: [id])\r\n  club      Club     @relation(fields: [clubId], references: [id])\r\n}\r\n\r\nmodel FollowUnfollowLog {\r\n  id          Int      @id @default(autoincrement())\r\n  userId      Int\r\n  clubId      Int\r\n  action      String\r\n  actionAt    DateTime @default(now())\r\n  user        User     @relation(fields: [userId], references: [id])\r\n  club        Club     @relation(fields: [clubId], references: [id])\r\n}\r\n\r\nmodel EventVisit {\r\n  id        Int      @id @default(autoincrement())\r\n  userId    Int\r\n  eventId   Int\r\n  visitedAt DateTime @default(now())\r\n  user      User     @relation(fields: [userId], references: [id])\r\n  event     Event    @relation(fields: [eventId], references: [id])\r\n}\r\n\r\nmodel EventFollowUnfollowLog {\r\n  id          Int      @id @default(autoincrement())\r\n  userId      Int\r\n  eventId     Int\r\n  action      String\r\n  actionAt    DateTime @default(now())\r\n  user        User     @relation(fields: [userId], references: [id])\r\n  event       Event    @relation(fields: [eventId], references: [id])\r\n}"
      },
      {
        "type": "directory",
        "name": "seeders",
        "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\seeders",
        "children": [
          {
            "type": "file",
            "name": "departmentSeeder.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\seeders\\departmentSeeder.js",
            "size": 2823,
            "content": "const { prisma } = require('../../src/services/database.service');\r\n\r\nasync function seedDepartments() {\r\n  const departments = [\r\n    { name: 'Department of Civil Engineering', alias: 'CE', faculty: 'Faculty of Civil Engineering' },\r\n    { name: 'Department of Urban and Regional Planning', alias: 'URP', faculty: 'Faculty of Civil Engineering' },\r\n    { name: 'Department of Building Engineering and Construction Management', alias: 'BECM', faculty: 'Faculty of Civil Engineering' },\r\n    { name: 'Department of Architecture', alias: 'ARCH', faculty: 'Faculty of Civil Engineering' },\r\n    { name: 'Department of Mathematics', alias: 'MATH', faculty: 'Faculty of Science and Humanities' },\r\n    { name: 'Department of Physics', alias: 'PHY', faculty: 'Faculty of Science and Humanities' },\r\n    { name: 'Department of Chemistry', alias: 'CHEM', faculty: 'Faculty of Science and Humanities' },\r\n    { name: 'Department of Humanities and Business', alias: 'HUM', faculty: 'Faculty of Science and Humanities' },\r\n    { name: 'Department of Electrical and Electronic Engineering', alias: 'EEE', faculty: 'Faculty of Electrical and Electronic Engineering' },\r\n    { name: 'Department of Computer Science and Engineering', alias: 'CSE', faculty: 'Faculty of Electrical and Electronic Engineering' },\r\n    { name: 'Department of Electronics and Communication Engineering', alias: 'ECE', faculty: 'Faculty of Electrical and Electronic Engineering' },\r\n    { name: 'Department of Biomedical Engineering', alias: 'BME', faculty: 'Faculty of Electrical and Electronic Engineering' },\r\n    { name: 'Department of Materials Science and Engineering', alias: 'MSE', faculty: 'Faculty of Electrical and Electronic Engineering' },\r\n    { name: 'Department of Mechanical Engineering', alias: 'ME', faculty: 'Faculty of Mechanical Engineering' },\r\n    { name: 'Department of Industrial Engineering and Management', alias: 'IEM', faculty: 'Faculty of Mechanical Engineering' },\r\n    { name: 'Department of Energy Science and Engineering', alias: 'ESE', faculty: 'Faculty of Mechanical Engineering' },\r\n    { name: 'Department of Leather Engineering', alias: 'LE', faculty: 'Faculty of Mechanical Engineering' },\r\n    { name: 'Department of Textile Engineering', alias: 'TE', faculty: 'Faculty of Mechanical Engineering' },\r\n    { name: 'Department of Chemical Engineering', alias: 'CHE', faculty: 'Faculty of Mechanical Engineering' },\r\n    { name: 'Department of Mechatronics Engineering', alias: 'MTE', faculty: 'Faculty of Mechanical Engineering' }\r\n  ];\r\n\r\n  for (const department of departments) {\r\n    await prisma.department.create({ data: department });\r\n  }\r\n\r\n  console.log('Departments seeded successfully!');\r\n}\r\n\r\nseedDepartments().catch(e => {\r\n  console.error(e);\r\n  process.exit(1);\r\n}); \r\n\r\nmodule.exports = seedDepartments;"
          },
          {
            "type": "file",
            "name": "seed.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\prisma\\seeders\\seed.js",
            "size": 11967,
            "content": "import { PrismaClient } from \"@prisma/client\";\r\n\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nasync function main() {\r\n  // Clear existing meals\r\n  await prisma.meal.deleteMany({});\r\n\r\n\r\n  console.log(\"Cleared existing meals\");\r\n\r\n  // Create new meals with updated schema\r\n  await prisma.meal.createMany({\r\n    data: [\r\n      {\r\n        name: \"Grilled Chicken Salad\",\r\n        description: \"A healthy mix of grilled chicken, fresh greens, and vinaigrette dressing.\",\r\n        price: 8.99,\r\n        category: \"Salad\",\r\n        isVegan: false,\r\n        isGlutenFree: true,\r\n        isSugarFree: true,\r\n        isLowFat: true,\r\n        isOrganic: false,\r\n        calories: 350,\r\n        protein: 40,\r\n        carbs: 15,\r\n        fat: 10,\r\n        fiber: 5,\r\n        sugar: 3,\r\n        sodium: 320,\r\n        vitaminA: 2500,\r\n        vitaminC: 30,\r\n        calcium: 120,\r\n        iron: 2,\r\n        allergens: [\"None\"]\r\n      },\r\n      {\r\n        name: \"Vegan Buddha Bowl\",\r\n        description: \"A balanced bowl with quinoa, chickpeas, avocado, and tahini dressing.\",\r\n        price: 10.99,\r\n        category: \"Vegan\",\r\n        isVegan: true,\r\n        isGlutenFree: true,\r\n        isSugarFree: true,\r\n        isLowFat: false,\r\n        isOrganic: true,\r\n        calories: 500,\r\n        protein: 20,\r\n        carbs: 55,\r\n        fat: 15,\r\n        fiber: 12,\r\n        sugar: 6,\r\n        sodium: 240,\r\n        vitaminA: 4000,\r\n        vitaminC: 45,\r\n        calcium: 150,\r\n        iron: 6,\r\n        allergens: [\"Sesame\"]\r\n      },\r\n      {\r\n        name: \"Classic Cheeseburger\",\r\n        description: \"Juicy beef patty with cheddar cheese, lettuce, tomato, and pickles.\",\r\n        price: 9.99,\r\n        category: \"Fast Food\",\r\n        isVegan: false,\r\n        isGlutenFree: false,\r\n        isSugarFree: false,\r\n        isLowFat: false,\r\n        isOrganic: false,\r\n        calories: 700,\r\n        protein: 45,\r\n        carbs: 50,\r\n        fat: 40,\r\n        fiber: 3,\r\n        sugar: 8,\r\n        sodium: 980,\r\n        vitaminA: 600,\r\n        vitaminC: 10,\r\n        calcium: 300,\r\n        iron: 4,\r\n        allergens: [\"Gluten\", \"Dairy\"]\r\n      },\r\n      {\r\n        name: \"Whole Grain Breakfast Bowl\",\r\n        description: \"Nutritious bowl with oats, fresh fruits, nuts and honey.\",\r\n        price: 7.99,\r\n        category: \"Breakfast\",\r\n        isVegan: false,\r\n        isGlutenFree: false,\r\n        isSugarFree: false,\r\n        isLowFat: true,\r\n        isOrganic: true,\r\n        calories: 450,\r\n        protein: 15,\r\n        carbs: 75,\r\n        fat: 12,\r\n        fiber: 8,\r\n        sugar: 22,\r\n        sodium: 120,\r\n        vitaminA: 800,\r\n        vitaminC: 20,\r\n        calcium: 200,\r\n        iron: 3,\r\n        allergens: [\"Nuts\", \"Gluten\"]\r\n      },\r\n      {\r\n        name: \"Tofu Stir-Fry\",\r\n        description: \"Stir-fried tofu with vegetables and soy-ginger sauce.\",\r\n        price: 9.49,\r\n        category: \"Asian\",\r\n        isVegan: true,\r\n        isGlutenFree: false,\r\n        isSugarFree: false,\r\n        isLowFat: true,\r\n        isOrganic: false,\r\n        calories: 400,\r\n        protein: 30,\r\n        carbs: 45,\r\n        fat: 12,\r\n        fiber: 6,\r\n        sugar: 10,\r\n        sodium: 750,\r\n        vitaminA: 3000,\r\n        vitaminC: 40,\r\n        calcium: 250,\r\n        iron: 8,\r\n        allergens: [\"Soy\", \"Gluten\"]\r\n      },\r\n      {\r\n        name: \"Wild Salmon Fillet\",\r\n        description: \"Grilled wild-caught salmon with roasted vegetables and herbed quinoa.\",\r\n        price: 16.99,\r\n        category: \"Seafood\",\r\n        isVegan: false,\r\n        isGlutenFree: true,\r\n        isSugarFree: true,\r\n        isLowFat: false,\r\n        isOrganic: false,\r\n        calories: 520,\r\n        protein: 42,\r\n        carbs: 25,\r\n        fat: 28,\r\n        fiber: 5,\r\n        sugar: 3,\r\n        sodium: 340,\r\n        vitaminA: 900,\r\n        vitaminC: 25,\r\n        calcium: 180,\r\n        iron: 3,\r\n        allergens: [\"Fish\"]\r\n      },\r\n      {\r\n        name: \"Mediterranean Wrap\",\r\n        description: \"Whole grain wrap filled with hummus, falafel, fresh vegetables and tzatziki.\",\r\n        price: 8.49,\r\n        category: \"Sandwich\",\r\n        isVegan: false, // Contains tzatziki\r\n        isGlutenFree: false,\r\n        isSugarFree: true,\r\n        isLowFat: true,\r\n        isOrganic: true,\r\n        calories: 480,\r\n        protein: 18,\r\n        carbs: 60,\r\n        fat: 20,\r\n        fiber: 9,\r\n        sugar: 5,\r\n        sodium: 600,\r\n        vitaminA: 1500,\r\n        vitaminC: 35,\r\n        calcium: 150,\r\n        iron: 4,\r\n        allergens: [\"Gluten\", \"Sesame\"]\r\n      },\r\n      {\r\n        name: \"Vegetable Curry\",\r\n        description: \"A spicy blend of vegetables simmered in a rich curry sauce.\",\r\n        price: 9.99,\r\n        category: \"Indian\",\r\n        isVegan: true,\r\n        isGlutenFree: true,\r\n        isSugarFree: false,\r\n        isLowFat: true,\r\n        isOrganic: false,\r\n        calories: 450,\r\n        protein: 10,\r\n        carbs: 60,\r\n        fat: 18,\r\n        fiber: 8,\r\n        sugar: 7,\r\n        sodium: 680,\r\n        vitaminA: 4500,\r\n        vitaminC: 38,\r\n        calcium: 120,\r\n        iron: 5,\r\n        allergens: [\"None\"]\r\n      },\r\n      {\r\n        name: \"Shrimp Scampi\",\r\n        description: \"Succulent shrimp sautÃ©ed in garlic butter sauce, served over pasta.\",\r\n        price: 13.99,\r\n        category: \"Seafood\",\r\n        isVegan: false,\r\n        isGlutenFree: false,\r\n        isSugarFree: true,\r\n        isLowFat: false,\r\n        isOrganic: false,\r\n        calories: 650,\r\n        protein: 35,\r\n        carbs: 70,\r\n        fat: 25,\r\n        fiber: 3,\r\n        sugar: 4,\r\n        sodium: 890,\r\n        vitaminA: 600,\r\n        vitaminC: 12,\r\n        calcium: 100,\r\n        iron: 3,\r\n        allergens: [\"Shellfish\", \"Gluten\", \"Dairy\"]\r\n      },\r\n      {\r\n        name: \"Quinoa Power Bowl\",\r\n        description: \"Protein-rich quinoa with roasted vegetables, avocado, and tahini dressing.\",\r\n        price: 11.99,\r\n        category: \"Vegan\",\r\n        isVegan: true,\r\n        isGlutenFree: true,\r\n        isSugarFree: true,\r\n        isLowFat: true,\r\n        isOrganic: true,\r\n        calories: 480,\r\n        protein: 18,\r\n        carbs: 65,\r\n        fat: 16,\r\n        fiber: 10,\r\n        sugar: 5,\r\n        sodium: 320,\r\n        vitaminA: 3800,\r\n        vitaminC: 40,\r\n        calcium: 160,\r\n        iron: 6,\r\n        allergens: [\"Sesame\"]\r\n      },\r\n      {\r\n        name: \"Keto Plate\",\r\n        description: \"High-fat, low-carb meal with grilled steak, avocado, and greens.\",\r\n        price: 14.99,\r\n        category: \"Specialty Diet\",\r\n        isVegan: false,\r\n        isGlutenFree: true,\r\n        isSugarFree: true,\r\n        isLowFat: false,\r\n        isOrganic: false,\r\n        calories: 650,\r\n        protein: 40,\r\n        carbs: 8,\r\n        fat: 52,\r\n        fiber: 5,\r\n        sugar: 2,\r\n        sodium: 580,\r\n        vitaminA: 1500,\r\n        vitaminC: 15,\r\n        calcium: 120,\r\n        iron: 5,\r\n        allergens: [\"None\"]\r\n      },\r\n      {\r\n        name: \"Berry Smoothie Bowl\",\r\n        description: \"Blend of mixed berries, banana, and almond milk topped with granola and seeds.\",\r\n        price: 8.49,\r\n        category: \"Breakfast\",\r\n        isVegan: true,\r\n        isGlutenFree: false,\r\n        isSugarFree: false,\r\n        isLowFat: true,\r\n        isOrganic: true,\r\n        calories: 380,\r\n        protein: 10,\r\n        carbs: 65,\r\n        fat: 8,\r\n        fiber: 9,\r\n        sugar: 35,\r\n        sodium: 90,\r\n        vitaminA: 800,\r\n        vitaminC: 60,\r\n        calcium: 180,\r\n        iron: 3,\r\n        allergens: [\"Nuts\", \"Gluten\"]\r\n      },\r\n      {\r\n        name: \"Chicken Tikka Masala\",\r\n        description: \"Tender chicken in a creamy, spiced tomato sauce with basmati rice.\",\r\n        price: 12.99,\r\n        category: \"Indian\",\r\n        isVegan: false,\r\n        isGlutenFree: true,\r\n        isSugarFree: false,\r\n        isLowFat: false,\r\n        isOrganic: false,\r\n        calories: 620,\r\n        protein: 38,\r\n        carbs: 50,\r\n        fat: 32,\r\n        fiber: 4,\r\n        sugar: 8,\r\n        sodium: 850,\r\n        vitaminA: 1200,\r\n        vitaminC: 20,\r\n        calcium: 150,\r\n        iron: 4,\r\n        allergens: [\"Dairy\"]\r\n      },\r\n      {\r\n        name: \"Avocado Toast\",\r\n        description: \"Multigrain toast topped with smashed avocado, cherry tomatoes, and microgreens.\",\r\n        price: 7.99,\r\n        category: \"Breakfast\",\r\n        isVegan: true,\r\n        isGlutenFree: false,\r\n        isSugarFree: true,\r\n        isLowFat: false,\r\n        isOrganic: true,\r\n        calories: 320,\r\n        protein: 8,\r\n        carbs: 35,\r\n        fat: 18,\r\n        fiber: 8,\r\n        sugar: 3,\r\n        sodium: 380,\r\n        vitaminA: 1000,\r\n        vitaminC: 15,\r\n        calcium: 60,\r\n        iron: 2,\r\n        allergens: [\"Gluten\"]\r\n      },\r\n      {\r\n        name: \"Beef Teriyaki Bowl\",\r\n        description: \"Tender slices of beef in teriyaki sauce with steamed rice and vegetables.\",\r\n        price: 11.99,\r\n        category: \"Asian\",\r\n        isVegan: false,\r\n        isGlutenFree: false,\r\n        isSugarFree: false,\r\n        isLowFat: false,\r\n        isOrganic: false,\r\n        calories: 580,\r\n        protein: 35,\r\n        carbs: 70,\r\n        fat: 18,\r\n        fiber: 4,\r\n        sugar: 18,\r\n        sodium: 950,\r\n        vitaminA: 900,\r\n        vitaminC: 25,\r\n        calcium: 80,\r\n        iron: 4,\r\n        allergens: [\"Soy\", \"Gluten\"]\r\n      },\r\n      {\r\n        name: \"Spinach and Feta Omelette\",\r\n        description: \"Fluffy three-egg omelette with spinach, feta cheese, and herbs.\",\r\n        price: 8.99,\r\n        category: \"Breakfast\",\r\n        isVegan: false,\r\n        isGlutenFree: true,\r\n        isSugarFree: true,\r\n        isLowFat: false,\r\n        isOrganic: false,\r\n        calories: 380,\r\n        protein: 25,\r\n        carbs: 5,\r\n        fat: 28,\r\n        fiber: 2,\r\n        sugar: 1,\r\n        sodium: 620,\r\n        vitaminA: 3500,\r\n        vitaminC: 10,\r\n        calcium: 320,\r\n        iron: 4,\r\n        allergens: [\"Eggs\", \"Dairy\"]\r\n      },\r\n      {\r\n        name: \"Sweet Potato Fries\",\r\n        description: \"Crispy baked sweet potato fries with chipotle aioli.\",\r\n        price: 4.99,\r\n        category: \"Side\",\r\n        isVegan: false, // Aioli contains eggs\r\n        isGlutenFree: true,\r\n        isSugarFree: false,\r\n        isLowFat: false,\r\n        isOrganic: true,\r\n        calories: 320,\r\n        protein: 3,\r\n        carbs: 40,\r\n        fat: 18,\r\n        fiber: 6,\r\n        sugar: 8,\r\n        sodium: 380,\r\n        vitaminA: 12000,\r\n        vitaminC: 30,\r\n        calcium: 40,\r\n        iron: 1,\r\n        allergens: [\"Eggs\"]\r\n      },\r\n      {\r\n        name: \"Fresh Fruit Platter\",\r\n        description: \"Assortment of seasonal fruits beautifully arranged.\",\r\n        price: 7.49,\r\n        category: \"Side\",\r\n        isVegan: true,\r\n        isGlutenFree: true,\r\n        isSugarFree: false,\r\n        isLowFat: true,\r\n        isOrganic: true,\r\n        calories: 150,\r\n        protein: 2,\r\n        carbs: 38,\r\n        fat: 0,\r\n        fiber: 6,\r\n        sugar: 30,\r\n        sodium: 5,\r\n        vitaminA: 1500,\r\n        vitaminC: 90,\r\n        calcium: 40,\r\n        iron: 1,\r\n        allergens: [\"None\"]\r\n      },\r\n      {\r\n        name: \"Steamed Brown Rice\",\r\n        description: \"Perfectly cooked whole grain brown rice.\",\r\n        price: 3.49,\r\n        category: \"Side\",\r\n        isVegan: true,\r\n        isGlutenFree: true,\r\n        isSugarFree: true,\r\n        isLowFat: true,\r\n        isOrganic: true,\r\n        calories: 220,\r\n        protein: 5,\r\n        carbs: 45,\r\n        fat: 2,\r\n        fiber: 3,\r\n        sugar: 0,\r\n        sodium: 10,\r\n        vitaminA: 0,\r\n        vitaminC: 0,\r\n        calcium: 20,\r\n        iron: 1,\r\n        allergens: [\"None\"]\r\n      }\r\n    ],\r\n  });\r\n\r\n  console.log(\"New meals seeded successfully!\");\r\n}\r\n\r\nmain()\r\n  .catch((e) => {\r\n    console.error(e);\r\n    process.exit(1);\r\n  })\r\n  .finally(async () => {\r\n    await prisma.$disconnect();\r\n  });\r\n"
          }
        ]
      }
    ]
  },
  {
    "type": "directory",
    "name": "src",
    "path": "E:\\Work\\MIST_Hackathon\\server\\src",
    "children": [
      {
        "type": "directory",
        "name": "config",
        "path": "E:\\Work\\MIST_Hackathon\\server\\src\\config",
        "children": [
          {
            "type": "file",
            "name": "supabase.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\config\\supabase.js",
            "size": 601,
            "content": "const { createClient } = require('@supabase/supabase-js');\r\nrequire('dotenv').config();\r\n\r\n// Initialize Supabase client\r\nconst supabaseUrl = process.env.SUPABASE_URL;\r\nconst supabaseKey = process.env.SUPABASE_ANON_KEY;\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY;\r\n\r\n// Create client with anonymous key (limited permissions)\r\nconst supabaseClient = createClient(supabaseUrl, supabaseKey);\r\n\r\n// Create admin client with service key (full permissions)\r\nconst supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);\r\n\r\nmodule.exports = {\r\n  supabaseClient,\r\n  supabaseAdmin\r\n}; "
          }
        ]
      },
      {
        "type": "directory",
        "name": "controllers",
        "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers",
        "children": [
          {
            "type": "file",
            "name": "ai-cafe-manager.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\ai-cafe-manager.controller.js",
            "size": 13160,
            "content": "const { PrismaClient } = require('@prisma/client');\r\nconst { logger } = require('../utils/logger.util');\r\nconst { sendSuccess, sendError } = require('../utils/response.util');\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n/**\r\n * Process queries from cafe managers and provide database insights\r\n */\r\nexports.processCafeManagerQuery = async (req, res) => {\r\n  try {\r\n    const { message, history } = req.body;\r\n    const query = message.toLowerCase();\r\n    \r\n    // Handle different types of queries\r\n    let response;\r\n    \r\n    // Pending orders (fix for this specific issue)\r\n    if (\r\n      query.includes('pending') || \r\n      query.includes('approval') || \r\n      query.includes('need action') ||\r\n      query.includes('waiting for review') ||\r\n      (query.includes('any') && query.includes('new') && query.includes('order'))\r\n    ) {\r\n      response = await getPendingApprovalCount();\r\n    }\r\n    // Sales and revenue questions\r\n    else if (\r\n      query.includes('revenue') || \r\n      query.includes('sales') || \r\n      query.includes('earning') ||\r\n      query.includes('money') ||\r\n      query.includes('income')\r\n    ) {\r\n      response = await getRevenueInfo();\r\n    } \r\n    // Popular meals\r\n    else if (\r\n      query.includes('popular') || \r\n      (query.includes('top') && query.includes('meal')) ||\r\n      query.includes('best seller') ||\r\n      query.includes('most ordered')\r\n    ) {\r\n      response = await getPopularMeals();\r\n    } \r\n    // Order statistics\r\n    else if (\r\n      query.includes('order') && \r\n      (query.includes('count') || query.includes('number') || query.includes('total') || query.includes('statistics') || query.includes('status'))\r\n    ) {\r\n      response = await getOrdersInfo();\r\n    }\r\n    // Meal counts\r\n    else if (\r\n      (query.includes('how many') || query.includes('total') || query.includes('count')) && \r\n      (query.includes('meal') || query.includes('food') || query.includes('item'))\r\n    ) {\r\n      response = await getMealCounts();\r\n    }\r\n    // Orders ready for pickup\r\n    else if (\r\n      (query.includes('ready') && query.includes('pickup')) ||\r\n      query.includes('to be picked up') ||\r\n      query.includes('for collection')\r\n    ) {\r\n      response = await getReadyOrdersCount();\r\n    }\r\n    // Today's orders\r\n    else if (\r\n      (query.includes('today') || query.includes('current day')) && \r\n      query.includes('order')\r\n    ) {\r\n      response = await getTodayOrders();\r\n    }\r\n    // Recent activity\r\n    else if (\r\n      query.includes('recent') || \r\n      query.includes('latest') ||\r\n      query.includes('new activity') ||\r\n      query.includes('what happened')\r\n    ) {\r\n      response = await getRecentActivity();\r\n    }\r\n    // Specific meal info\r\n    else if (\r\n      query.includes('meal') && \r\n      (query.includes('find') || query.includes('information') || query.includes('details') || query.includes('about'))\r\n    ) {\r\n      const mealName = extractMealName(query);\r\n      if (mealName) {\r\n        response = await getMealInfo(mealName);\r\n      } else {\r\n        response = \"I couldn't identify which meal you're asking about. Could you specify the meal name?\";\r\n      }\r\n    }\r\n    // Help with using the system\r\n    else if (\r\n      query.includes('help') || \r\n      query.includes('how do i') || \r\n      query.includes('how to') ||\r\n      query.includes('what can you do')\r\n    ) {\r\n      response = getHelpResponse(query);\r\n    }\r\n    // Default response for unrecognized queries\r\n    else {\r\n      response = \"I'm not sure how to answer that. You can ask me about orders, meals, revenue, or navigation. For example, try 'How many pending orders do we have?' or 'Take me to meal management'\";\r\n    }\r\n\r\n    return sendSuccess(res, { response });\r\n  } catch (error) {\r\n    logger.error('Error in AI assistant:', error);\r\n    return sendError(res, 'Failed to process your request', 500);\r\n  }\r\n};\r\n\r\n// Helper functions to fetch data from database\r\n\r\n// Improved pending approval count function\r\nasync function getPendingApprovalCount() {\r\n  const count = await prisma.preorder.count({\r\n    where: {\r\n      status: 'pending_approval'\r\n    }\r\n  });\r\n  \r\n  // Get the most recent pending orders\r\n  const pendingOrders = await prisma.preorder.findMany({\r\n    where: {\r\n      status: 'pending_approval'\r\n    },\r\n    include: {\r\n      user: true,\r\n      meal: true\r\n    },\r\n    orderBy: {\r\n      orderTime: 'desc'\r\n    },\r\n    take: 3\r\n  });\r\n  \r\n  if (count === 0) {\r\n    return \"There are no orders pending approval. All orders have been processed!\";\r\n  } else {\r\n    let response = `There are ${count} orders pending your approval.`;\r\n    \r\n    if (pendingOrders.length > 0) {\r\n      response += \"\\n\\nMost recent pending orders:\";\r\n      pendingOrders.forEach((order, index) => {\r\n        response += `\\n${index + 1}. ${order.meal.name} - ordered by ${order.user.firstName} ${order.user.lastName} at ${new Date(order.orderTime).toLocaleTimeString()}`;\r\n      });\r\n      response += \"\\n\\nYou should review them in the order management section.\";\r\n    }\r\n    \r\n    return response;\r\n  }\r\n}\r\n\r\nasync function getRevenueInfo() {\r\n  // Calculate revenue from orders\r\n  const result = await prisma.preorder.aggregate({\r\n    _sum: {\r\n      total: true\r\n    },\r\n    where: {\r\n      status: 'picked_up'  // Only count completed orders\r\n    }\r\n  });\r\n  \r\n  const totalRevenue = result._sum.total || 0;\r\n  \r\n  // Get today's revenue\r\n  const today = new Date();\r\n  today.setHours(0, 0, 0, 0);\r\n  \r\n  const todayResult = await prisma.preorder.aggregate({\r\n    _sum: {\r\n      total: true\r\n    },\r\n    where: {\r\n      status: 'picked_up',\r\n      orderTime: {\r\n        gte: today\r\n      }\r\n    }\r\n  });\r\n  \r\n  const todayRevenue = todayResult._sum.total || 0;\r\n  \r\n  // Get yesterday's revenue for comparison\r\n  const yesterday = new Date();\r\n  yesterday.setDate(yesterday.getDate() - 1);\r\n  yesterday.setHours(0, 0, 0, 0);\r\n  \r\n  const yesterdayResult = await prisma.preorder.aggregate({\r\n    _sum: {\r\n      total: true\r\n    },\r\n    where: {\r\n      status: 'picked_up',\r\n      orderTime: {\r\n        gte: yesterday,\r\n        lt: today\r\n      }\r\n    }\r\n  });\r\n  \r\n  const yesterdayRevenue = yesterdayResult._sum.total || 0;\r\n  \r\n  // Calculate percentage change\r\n  const percentChange = yesterdayRevenue ? ((todayRevenue - yesterdayRevenue) / yesterdayRevenue) * 100 : 0;\r\n  \r\n  let trendMessage = \"\";\r\n  if (Math.abs(percentChange) > 1) {\r\n    trendMessage = `This is ${percentChange > 0 ? 'up' : 'down'} ${Math.abs(percentChange).toFixed(1)}% compared to yesterday.`;\r\n  } else {\r\n    trendMessage = \"This is about the same as yesterday.\";\r\n  }\r\n  \r\n  return `Total revenue from all completed orders is à§³${totalRevenue.toLocaleString()}. Today's revenue so far is à§³${todayRevenue.toLocaleString()}. ${trendMessage}`;\r\n}\r\n\r\nasync function getPopularMeals() {\r\n  const popularMeals = await prisma.preorder.groupBy({\r\n    by: ['mealId'],\r\n    _count: {\r\n      id: true\r\n    },\r\n    orderBy: {\r\n      _count: {\r\n        id: 'desc'\r\n      }\r\n    },\r\n    take: 5\r\n  });\r\n  \r\n  if (popularMeals.length === 0) {\r\n    return \"There are no orders yet to determine popular meals.\";\r\n  }\r\n  \r\n  // Get meal names\r\n  const mealIds = popularMeals.map(item => item.mealId);\r\n  const meals = await prisma.meal.findMany({\r\n    where: {\r\n      id: { in: mealIds }\r\n    },\r\n    select: {\r\n      id: true,\r\n      name: true,\r\n      price: true\r\n    }\r\n  });\r\n  \r\n  const mealsMap = meals.reduce((acc, meal) => {\r\n    acc[meal.id] = meal;\r\n    return acc;\r\n  }, {});\r\n  \r\n  const topMealsText = popularMeals\r\n    .map((item, index) => `${index + 1}. ${mealsMap[item.mealId].name} (${item._count.id} orders) - à§³${mealsMap[item.mealId].price} each`)\r\n    .join('\\n');\r\n  \r\n  const totalRevenue = popularMeals.reduce((sum, item) => {\r\n    return sum + (item._count.id * (mealsMap[item.mealId]?.price || 0));\r\n  }, 0);\r\n  \r\n  return `Top selling meals:\\n${topMealsText}\\n\\nThese top 5 meals have generated approximately à§³${totalRevenue.toLocaleString()} in revenue.`;\r\n}\r\n\r\nasync function getOrdersInfo() {\r\n  const totalOrders = await prisma.preorder.count();\r\n  \r\n  const statusCounts = await prisma.preorder.groupBy({\r\n    by: ['status'],\r\n    _count: {\r\n      id: true\r\n    }\r\n  });\r\n  \r\n  const statusMap = {\r\n    pending_approval: 'pending approval',\r\n    placed: 'placed',\r\n    ready: 'ready for pickup',\r\n    picked_up: 'completed',\r\n    cancelled: 'cancelled'\r\n  };\r\n  \r\n  const statusData = statusCounts.map(item => ({\r\n    status: statusMap[item.status] || item.status,\r\n    count: item._count.id,\r\n    percentage: Math.round((item._count.id / totalOrders) * 100)\r\n  }));\r\n  \r\n  const statusText = statusData\r\n    .map(item => `${item.status}: ${item.count} (${item.percentage}%)`)\r\n    .join('\\n');\r\n  \r\n  // Get today's order count\r\n  const today = new Date();\r\n  today.setHours(0, 0, 0, 0);\r\n  \r\n  const todayOrderCount = await prisma.preorder.count({\r\n    where: {\r\n      orderTime: {\r\n        gte: today\r\n      }\r\n    }\r\n  });\r\n  \r\n  return `Order Statistics:\\n\\nTotal orders in system: ${totalOrders}\\nOrders today: ${todayOrderCount}\\n\\nBreakdown by status:\\n${statusText}`;\r\n}\r\n\r\nasync function getTodayOrders() {\r\n  const today = new Date();\r\n  today.setHours(0, 0, 0, 0);\r\n  \r\n  const todayOrders = await prisma.preorder.count({\r\n    where: {\r\n      orderTime: {\r\n        gte: today\r\n      }\r\n    }\r\n  });\r\n  \r\n  if (todayOrders === 0) {\r\n    return \"There have been no orders placed today yet.\";\r\n  }\r\n  \r\n  // Get status breakdown for today's orders\r\n  const statusCounts = await prisma.preorder.groupBy({\r\n    by: ['status'],\r\n    _count: {\r\n      id: true\r\n    },\r\n    where: {\r\n      orderTime: {\r\n        gte: today\r\n      }\r\n    }\r\n  });\r\n  \r\n  const statusMap = {\r\n    pending_approval: 'pending approval',\r\n    placed: 'placed',\r\n    ready: 'ready for pickup',\r\n    picked_up: 'completed',\r\n    cancelled: 'cancelled'\r\n  };\r\n  \r\n  const statusText = statusCounts\r\n    .map(item => `${statusMap[item.status] || item.status}: ${item._count.id}`)\r\n    .join('\\n');\r\n  \r\n  const revenue = await prisma.preorder.aggregate({\r\n    _sum: {\r\n      total: true\r\n    },\r\n    where: {\r\n      orderTime: {\r\n        gte: today\r\n      },\r\n      status: {\r\n        not: 'cancelled'\r\n      }\r\n    }\r\n  });\r\n  \r\n  const totalRevenue = revenue._sum.total || 0;\r\n  \r\n  return `Today's Order Summary:\\n\\nTotal orders: ${todayOrders}\\nTotal revenue: à§³${totalRevenue.toLocaleString()}\\n\\nStatus breakdown:\\n${statusText}`;\r\n}\r\n\r\nasync function getMealCounts() {\r\n  const totalMeals = await prisma.meal.count();\r\n  \r\n  const categories = await prisma.meal.groupBy({\r\n    by: ['category'],\r\n    _count: {\r\n      id: true\r\n    }\r\n  });\r\n  \r\n  const categoriesText = categories\r\n    .map(cat => `${cat.category}: ${cat._count.id}`)\r\n    .join('\\n');\r\n  \r\n  // Get average price\r\n  const priceData = await prisma.meal.aggregate({\r\n    _avg: {\r\n      price: true\r\n    },\r\n    _min: {\r\n      price: true\r\n    },\r\n    _max: {\r\n      price: true\r\n    }\r\n  });\r\n  \r\n  return `Meal Statistics:\\n\\nTotal meals: ${totalMeals}\\nAverage price: à§³${priceData._avg.price.toFixed(2)}\\nPrice range: à§³${priceData._min.price} - à§³${priceData._max.price}\\n\\nBreakdown by category:\\n${categoriesText}`;\r\n}\r\n\r\nasync function getReadyOrdersCount() {\r\n  const count = await prisma.preorder.count({\r\n    where: {\r\n      status: 'ready'\r\n    }\r\n  });\r\n  \r\n  if (count === 0) {\r\n    return \"There are no orders ready for pickup at the moment.\";\r\n  } \r\n  \r\n  // Get ready orders with customer info\r\n  const readyOrders = await prisma.preorder.findMany({\r\n    where: {\r\n      status: 'ready'\r\n    },\r\n    include: {\r\n      user: true,\r\n      meal: true\r\n    },\r\n    orderBy: {\r\n      pickupTime: 'asc'\r\n    },\r\n    take: 5\r\n  });\r\n  \r\n  let response = `There are ${count} orders ready for customer pickup.`;\r\n  \r\n  if (readyOrders.length > 0) {\r\n    response += \"\\n\\nNext scheduled pickups:\";\r\n    readyOrders.forEach((order, index) => {\r\n      const pickupTime = new Date(order.pickupTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\r\n      response += `\\n${index + 1}. ${order.meal.name} for ${order.user.firstName} ${order.user.lastName} at ${pickupTime}`;\r\n    });\r\n  }\r\n  \r\n  return response;\r\n}\r\n\r\nasync function getRecentActivity() {\r\n  // Get the 5 most recent orders\r\n  const recentOrders = await prisma.preorder.findMany({\r\n    include: {\r\n      user: true,\r\n      meal: true\r\n    },\r\n    orderBy: {\r\n      orderTime: 'desc'\r\n    },\r\n    take: 5\r\n  });\r\n  \r\n  if (recentOrders.length === 0) {\r\n    return \"There has been no recent activity in the system.\";\r\n  }\r\n  \r\n  let response = \"Recent activity:\\n\";\r\n  \r\n  recentOrders.forEach((order, index) => {\r\n    const orderTime = new Date(order.orderTime).toLocaleString();\r\n    const status = order.status.replace(/_/g, ' ');\r\n    response += `\\n${index + 1}. ${order.user.firstName} ${order.user.lastName} ${status === 'pending approval' ? 'requested' : 'ordered'} ${order.meal.name} (${orderTime})`;\r\n  });\r\n  \r\n  return response;\r\n}\r\n\r\n// Other helper functions remain the same...\r\n\r\nmodule.exports = {\r\n  processCafeManagerQuery\r\n};"
          },
          {
            "type": "file",
            "name": "assignment.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\assignment.controller.js",
            "size": 2772,
            "content": "const assignmentService = require('../services/assignment.service');\r\nconst { sendSuccess, sendError } = require('../utils/response.util');\r\n\r\nconst createAssignment = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n    const { courseId, assignmentName, assignmentContent, deadline } = req.body;\r\n    \r\n    const assignment = await assignmentService.createAssignment(userId, {\r\n      courseId,\r\n      assignmentName,\r\n      assignmentContent,\r\n      deadline: new Date(deadline)\r\n    });\r\n\r\n    sendSuccess(res, assignment, 'Assignment created successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getAssignments = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n    \r\n    const assignments = await assignmentService.getAssignments(userId);\r\n    \r\n    sendSuccess(res, assignments, 'Assignments retrieved successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getAssignmentById = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n    const { id } = req.params;\r\n    \r\n    const assignment = await assignmentService.getAssignmentById(userId, id);\r\n    \r\n    if (!assignment) {\r\n      return sendError(res, 'Assignment not found', 404);\r\n    }\r\n    \r\n    sendSuccess(res, assignment, 'Assignment retrieved successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst updateAssignment = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n    const { id } = req.params;\r\n    const updateData = req.body;\r\n    \r\n    if (updateData.deadline) {\r\n      updateData.deadline = new Date(updateData.deadline);\r\n    }\r\n    \r\n    const assignment = await assignmentService.updateAssignment(userId, id, updateData);\r\n    \r\n    sendSuccess(res, assignment, 'Assignment updated successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst deleteAssignment = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n    const { id } = req.params;\r\n    \r\n    await assignmentService.deleteAssignment(userId, id);\r\n    \r\n    sendSuccess(res, { id }, 'Assignment deleted successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\n// Add this new controller method\r\nconst notifyDeadline = async (req, res, next) => {\r\n    try {\r\n      const userId = req.user.id;\r\n      const { assignmentId } = req.body;\r\n      \r\n      const result = await assignmentService.notifyDeadline(userId, assignmentId);\r\n      \r\n      sendSuccess(res, result, 'Deadline notification sent successfully');\r\n    } catch (error) {\r\n      next(error);\r\n    }\r\n  };\r\n  \r\n  // Add this to your module.exports\r\nmodule.exports = {\r\n  createAssignment,\r\n  getAssignments,\r\n  getAssignmentById,\r\n  updateAssignment,\r\n  deleteAssignment,\r\n  notifyDeadline\r\n};"
          },
          {
            "type": "file",
            "name": "auth.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\auth.controller.js",
            "size": 11686,
            "content": "const { validationResult } = require('express-validator');\r\nconst authService = require('../services/auth.service');\r\nconst { sendSuccess, sendError } = require('../utils/response.util');\r\nconst { ValidationError } = require('../middleware/error.middleware');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\n// Register a new employee\r\nconst registerEmployee = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const { email, password, name, captchaToken, employeeId, designation } = req.body;\r\n    \r\n    // Verify captcha\r\n    // if (!captchaToken) {\r\n    //   return sendError(res, 'CAPTCHA verification failed. Please try again.', 400);\r\n    // }\r\n    \r\n    // Register user\r\n    const result = await authService.registerEmployee({ \r\n      email, \r\n      password, \r\n      name, \r\n      captchaToken,\r\n      employeeId,\r\n      designation,\r\n    });\r\n    \r\n    // Generate tokens for immediate login\r\n    const { accessToken, user } = await authService.login(email, password, captchaToken);\r\n    \r\n    return sendSuccess(\r\n      res, \r\n      { \r\n        user,\r\n        accessToken,\r\n        success: true\r\n      },\r\n      'Employee registration successful! Please check your email to verify your account.',\r\n      201\r\n    );\r\n  } catch (error) {\r\n    logger.error('Registration error:', error);\r\n    \r\n    if (error.message.includes('already exists')) {\r\n      return sendError(res, error.message, 409);\r\n    }\r\n    \r\n    if (error.message.includes('CAPTCHA verification failed')) {\r\n      return sendError(res, error.message, 400);\r\n    }\r\n    \r\n    sendError(res, error.message, 500);\r\n    next(error);\r\n  }\r\n};\r\n\r\n// Register a new student\r\nconst registerStudent = async (req, res, next) => {\r\n  try {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return sendError(res, errors.array(), 400);\r\n    }\r\n\r\n    const { email, password, name, captchaToken, studentId, section, batch, departmentId } = req.body;\r\n\r\n    const result = await authService.studentRegister({ email, password, name, captchaToken, studentId, section, batch, departmentId });\r\n\r\n    return sendSuccess(\r\n      res, \r\n      {\r\n        user: result.user,\r\n        accessToken: result.accessToken,\r\n        success: true\r\n      },\r\n      'Student registration successful! Please check your email to verify your account.',\r\n      201\r\n    );\r\n  } catch (error) {\r\n    logger.error('Student registration error:', error);\r\n    if (error.message.includes('already exists')) {\r\n      return sendError(res, error.message, 409);\r\n    }\r\n    if (error.message.includes('CAPTCHA verification failed')) {\r\n      return sendError(res, error.message, 400);\r\n    }\r\n    sendError(res, error.message, 500);\r\n    next(error);\r\n  }\r\n};\r\n\r\n// Register a new faculty\r\nconst registerFaculty = async (req, res, next) => {\r\n  try {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return sendError(res, errors.array(), 400);\r\n    }\r\n\r\n    const { email, password, name, captchaToken, employeeId, status, designation, departmentId, bio } = req.body;\r\n\r\n    const result = await authService.facultyRegister({ email, password, name, captchaToken, employeeId, status, designation, departmentId, bio });\r\n\r\n    return sendSuccess(\r\n      res, \r\n      {\r\n        user: result.user,\r\n        accessToken: result.accessToken,\r\n        success: true\r\n      },\r\n      'Faculty registration successful! Please check your email to verify your account.',\r\n      201\r\n    );\r\n  } catch (error) {\r\n    logger.error('Faculty registration error:', error);\r\n    if (error.message.includes('already exists')) {\r\n      return sendError(res, error.message, 409);\r\n    }\r\n    if (error.message.includes('CAPTCHA verification failed')) {\r\n      return sendError(res, error.message, 400);\r\n    }\r\n    sendError(res, error.message, 500);\r\n    next(error);\r\n  }\r\n};\r\n\r\n// Verify email\r\nconst verifyEmail = async (req, res, next) => {\r\n  try {\r\n    const { token } = req.params;\r\n    \r\n    if (!token) {\r\n      throw new ValidationError('Verification token is required');\r\n    }\r\n    \r\n    const result = await authService.verifyEmail(token);\r\n    console.log(\"Verification done\")\r\n    \r\n    return sendSuccess(\r\n      res,\r\n      { success: result.success },\r\n      'Email verified successfully! You can now log in.'\r\n    );\r\n  } catch (error) {\r\n    logger.error('Email verification error:', error);\r\n    \r\n    if (error.message.includes('Invalid or expired')) {\r\n      return sendError(res, error.message, 400);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\nconst resendVerificationEmail = async (req, res, next) => {\r\n  try {\r\n    const { email } = req.body;\r\n    \r\n    await authService.resendVerificationEmail(email);\r\n  } catch (error) {\r\n    logger.error('Resend verification error:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n// Login user\r\nconst login = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const { email, password, captchaToken } = req.body;\r\n    \r\n    // Verify captcha\r\n    // if (!captchaToken) {\r\n    //   return sendError(res, 'CAPTCHA verification failed. Please try again.', 400);\r\n    // }\r\n    \r\n    // Login user\r\n    const result = await authService.login(email, password, captchaToken || 'test-token');\r\n    \r\n    // Set refresh token as HTTP-only cookie\r\n    res.cookie('refreshToken', result.refreshToken, {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === 'production',\r\n      sameSite: 'lax', // Changed from 'strict' to 'lax' for better cross-site functionality\r\n      maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days\r\n    });\r\n    \r\n    logger.info(`User ${email} logged in successfully`);\r\n    \r\n    return sendSuccess(\r\n      res,\r\n      {\r\n        user: result.user,\r\n        accessToken: result.accessToken\r\n      },\r\n      'Login successful'\r\n    );\r\n  } catch (error) {\r\n    logger.error('Login error:', error);\r\n    \r\n    if (error.message.includes('Invalid email or password')) {\r\n      return sendError(res, error.message, 401);\r\n    }\r\n    \r\n    if (error.message.includes('Account is')) {\r\n      return sendError(res, error.message, 403);\r\n    }\r\n    \r\n    if (error.message.includes('CAPTCHA verification failed')) {\r\n      return sendError(res, error.message, 400);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\n// Logout user\r\nconst logout = async (req, res, next) => {\r\n  try {\r\n    const { refreshToken } = req.cookies;\r\n    \r\n    if (!refreshToken) {\r\n      return sendError(res, 'No refresh token provided', 400);\r\n    }\r\n    \r\n    await authService.logout(req.user.id, refreshToken);\r\n    \r\n    // Clear refresh token cookie\r\n    res.clearCookie('refreshToken');\r\n    \r\n    return sendSuccess(res, null, 'Logged out successfully');\r\n  } catch (error) {\r\n    logger.error('Logout error:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n// Refresh access token\r\nconst refreshToken = async (req, res, next) => {\r\n  try {\r\n    const { refreshToken } = req.cookies;\r\n    \r\n    if (!refreshToken) {\r\n      return sendError(res, 'No refresh token provided', 401);\r\n    }\r\n    \r\n    const result = await authService.refreshToken(refreshToken);\r\n    \r\n    // Set new refresh token as HTTP-only cookie\r\n    res.cookie('refreshToken', result.refreshToken, {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === 'production',\r\n      sameSite: 'strict',\r\n      maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days\r\n    });\r\n    \r\n    return sendSuccess(\r\n      res,\r\n      { accessToken: result.accessToken },\r\n      'Token refreshed successfully'\r\n    );\r\n  } catch (error) {\r\n    logger.error('Token refresh error:', error);\r\n    \r\n    // Clear cookie on error\r\n    res.clearCookie('refreshToken');\r\n    \r\n    if (error.message.includes('Invalid or expired')) {\r\n      return sendError(res, error.message, 401);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\n// Request password reset\r\nconst requestPasswordReset = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      throw new ValidationError('Validation failed', errors.array());\r\n    }\r\n    \r\n    const { email, captchaToken } = req.body;\r\n    \r\n    // Verify captcha\r\n    // if (!captchaToken) {\r\n    //   return sendError(res, 'CAPTCHA verification failed. Please try again.', 400);\r\n    // }\r\n    \r\n    await authService.requestPasswordReset(email, captchaToken);\r\n    \r\n    // Always return success for security (even if email doesn't exist)\r\n    return sendSuccess(\r\n      res,\r\n      null,\r\n      'If an account with that email exists, we have sent password reset instructions to it.'\r\n    );\r\n  } catch (error) {\r\n    logger.error('Password reset request error:', error);\r\n    \r\n    if (error.message.includes('CAPTCHA verification failed')) {\r\n      return sendError(res, error.message, 400);\r\n    }\r\n    \r\n    // For security, don't reveal specific errors\r\n    next(error);\r\n  }\r\n};\r\n\r\n// Resend verification email\r\nconst resendVerification = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      throw new ValidationError('Validation failed', errors.array());\r\n    }\r\n    \r\n    const { email } = req.body;\r\n    \r\n    await authService.resendVerificationEmail(email);\r\n    \r\n    // Return success message\r\n    return sendSuccess(\r\n      res,\r\n      null,\r\n      'If your account requires verification, a new verification link has been sent to your email.'\r\n    );\r\n  } catch (error) {\r\n    logger.error('Resend verification error:', error);\r\n    \r\n    // For security, don't reveal specific errors\r\n    next(error);\r\n  }\r\n};\r\n\r\n// Reset password\r\nconst resetPassword = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      throw new ValidationError('Validation failed', errors.array());\r\n    }\r\n    \r\n    const { token } = req.params;\r\n    const { password } = req.body;\r\n    \r\n    await authService.resetPassword(token, password);\r\n    \r\n    return sendSuccess(\r\n      res,\r\n      null,\r\n      'Password reset successful! You can now log in with your new password.'\r\n    );\r\n  } catch (error) {\r\n    logger.error('Password reset error:', error);\r\n    \r\n    if (error.message.includes('Invalid or expired')) {\r\n      return sendError(res, error.message, 400);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\n// Get current user profile\r\nconst getCurrentUser = async (req, res, next) => {\r\n  try {\r\n    // User is already attached to req by the authenticate middleware\r\n    logger.info(`User ${req.user.email} retrieved profile`);\r\n    return sendSuccess(res, { user: req.user }, 'User profile retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Get current user error:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  registerEmployee,\r\n  registerStudent,\r\n  registerFaculty,\r\n  verifyEmail,\r\n  login,\r\n  logout,\r\n  refreshToken,\r\n  requestPasswordReset,\r\n  resendVerification,\r\n  resetPassword,\r\n  getCurrentUser\r\n}; "
          },
          {
            "type": "file",
            "name": "bus.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\bus.controller.js",
            "size": 5358,
            "content": "const { validationResult } = require('express-validator');\r\nconst busService = require('../services/bus.service');\r\nconst { sendSuccess, sendError } = require('../utils/response.util');\r\nconst { ValidationError } = require('../middleware/error.middleware');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\n/**\r\n * Get all buses\r\n */\r\nconst getBuses = async (req, res, next) => {\r\n  try {\r\n    const buses = await busService.getAllBuses();\r\n    return sendSuccess(res, { buses }, 'Buses retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving buses:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get bus by ID\r\n */\r\nconst getBusById = async (req, res, next) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const bus = await busService.getBusById(id);\r\n    \r\n    if (!bus) {\r\n      return sendError(res, 'Bus not found', 404);\r\n    }\r\n    \r\n    return sendSuccess(res, { bus }, 'Bus retrieved successfully');\r\n  } catch (error) {\r\n    logger.error(`Error retrieving bus with ID ${req.params.id}:`, error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new bus\r\n */\r\nconst createBus = async (req, res, next) => {\r\n  try {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const busData = req.body;\r\n    const bus = await busService.createBus(busData);\r\n    \r\n    return sendSuccess(res, { bus }, 'Bus created successfully', 201);\r\n  } catch (error) {\r\n    logger.error('Error creating bus:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Update a bus\r\n */\r\nconst updateBus = async (req, res, next) => {\r\n  try {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const { id } = req.params;\r\n    const busData = req.body;\r\n    \r\n    const bus = await busService.updateBus(id, busData);\r\n    \r\n    return sendSuccess(res, { bus }, 'Bus updated successfully');\r\n  } catch (error) {\r\n    logger.error(`Error updating bus with ID ${req.params.id}:`, error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a bus\r\n */\r\nconst deleteBus = async (req, res, next) => {\r\n  try {\r\n    const { id } = req.params;\r\n    await busService.deleteBus(id);\r\n    \r\n    return sendSuccess(res, null, 'Bus deleted successfully');\r\n  } catch (error) {\r\n    logger.error(`Error deleting bus with ID ${req.params.id}:`, error);\r\n    \r\n    if (error.code === 'P2025') {\r\n      return sendError(res, 'Bus not found', 404);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new driver\r\n */\r\nconst createDriver = async (req, res, next) => {\r\n  try {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const driverData = req.body;\r\n    const driver = await busService.createDriver(driverData);\r\n    \r\n    return sendSuccess(res, { driver }, 'Driver created successfully', 201);\r\n  } catch (error) {\r\n    logger.error('Error creating driver:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Update a driver\r\n */\r\nconst updateDriver = async (req, res, next) => {\r\n  try {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const { id } = req.params;\r\n    const driverData = req.body;\r\n    \r\n    const driver = await busService.updateDriver(id, driverData);\r\n    \r\n    return sendSuccess(res, { driver }, 'Driver updated successfully');\r\n  } catch (error) {\r\n    logger.error(`Error updating driver with ID ${req.params.id}:`, error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a driver\r\n */\r\nconst deleteDriver = async (req, res, next) => {\r\n  try {\r\n    const { id } = req.params;\r\n    await busService.deleteDriver(id);\r\n    \r\n    return sendSuccess(res, null, 'Driver deleted successfully');\r\n  } catch (error) {\r\n    logger.error(`Error deleting driver with ID ${req.params.id}:`, error);\r\n    \r\n    if (error.code === 'P2025') {\r\n      return sendError(res, 'Driver not found', 404);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get all drivers\r\n */\r\nconst getDrivers = async (req, res, next) => {\r\n  try {\r\n    const drivers = await busService.getAllDrivers();\r\n    return sendSuccess(res, { drivers }, 'Drivers retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving drivers:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  getBuses,\r\n  getBusById,\r\n  createBus,\r\n  updateBus,\r\n  deleteBus,\r\n  createDriver,\r\n  updateDriver,\r\n  deleteDriver,\r\n  getDrivers,\r\n};\r\n"
          },
          {
            "type": "file",
            "name": "cafeteria.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\cafeteria.controller.js",
            "size": 10577,
            "content": "const { validationResult } = require('express-validator');\r\nconst cafeteriaService = require('../services/cafeteria.service');\r\nconst { sendSuccess, sendError } = require('../utils/response.util');\r\nconst { ValidationError } = require('../middleware/error.middleware');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\n/**\r\n * Get all meals\r\n */\r\nconst getMeals = async (req, res, next) => {\r\n  try {\r\n    const meals = await cafeteriaService.getAllMeals();\r\n    return sendSuccess(res, { meals }, 'Meals retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving meals:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get meal by ID\r\n */\r\nconst getMealById = async (req, res, next) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const meal = await cafeteriaService.getMealById(id);\r\n    \r\n    if (!meal) {\r\n      return sendError(res, 'Meal not found', 404);\r\n    }\r\n    \r\n    return sendSuccess(res, { meal }, 'Meal retrieved successfully');\r\n  } catch (error) {\r\n    logger.error(`Error retrieving meal with ID ${req.params.id}:`, error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new meal\r\n */\r\nconst createMeal = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const mealData = req.body;\r\n    const meal = await cafeteriaService.createMeal(mealData);\r\n    \r\n    return sendSuccess(res, { meal }, 'Meal created successfully', 201);\r\n  } catch (error) {\r\n    logger.error('Error creating meal:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Update a meal\r\n */\r\nconst updateMeal = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const { id } = req.params;\r\n    const mealData = req.body;\r\n    \r\n    const meal = await cafeteriaService.updateMeal(id, mealData);\r\n    \r\n    return sendSuccess(res, { meal }, 'Meal updated successfully');\r\n  } catch (error) {\r\n    logger.error(`Error updating meal with ID ${req.params.id}:`, error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a meal\r\n */\r\nconst deleteMeal = async (req, res, next) => {\r\n  try {\r\n    const { id } = req.params;\r\n    await cafeteriaService.deleteMeal(id);\r\n    \r\n    return sendSuccess(res, null, 'Meal deleted successfully');\r\n  } catch (error) {\r\n    logger.error(`Error deleting meal with ID ${req.params.id}:`, error);\r\n    \r\n    if (error.code === 'P2025') {\r\n      return sendError(res, 'Meal not found', 404);\r\n    }\r\n    \r\n    if (error.code === 'P2003') {\r\n      return sendError(res, 'Cannot delete meal because it is referenced in menus', 400);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get all menus, optionally filtered by date\r\n */\r\nconst getMenus = async (req, res, next) => {\r\n  try {\r\n    const { date } = req.query;\r\n    const menus = await cafeteriaService.getMenus(date);\r\n    \r\n    return sendSuccess(res, { menus }, 'Menus retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving menus:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get menu by ID\r\n */\r\nconst getMenuById = async (req, res, next) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const menu = await cafeteriaService.getMenuById(id);\r\n    \r\n    if (!menu) {\r\n      return sendError(res, 'Menu not found', 404);\r\n    }\r\n    \r\n    return sendSuccess(res, { menu }, 'Menu retrieved successfully');\r\n  } catch (error) {\r\n    logger.error(`Error retrieving menu with ID ${req.params.id}:`, error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get today's menu\r\n */\r\nconst getTodayMenu = async (req, res, next) => {\r\n  try {\r\n    const menu = await cafeteriaService.getTodayMenu();\r\n    \r\n    if (!menu) {\r\n      return sendError(res, 'No menu available for today', 404);\r\n    }\r\n    \r\n    return sendSuccess(res, { menu }, 'Today\\'s menu retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving today\\'s menu:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new menu\r\n */\r\nconst createMenu = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const menuData = req.body;\r\n    const menu = await cafeteriaService.createMenu(menuData);\r\n    \r\n    return sendSuccess(res, { menu }, 'Menu created successfully', 201);\r\n  } catch (error) {\r\n    logger.error('Error creating menu:', error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Update a menu\r\n */\r\nconst updateMenu = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const { id } = req.params;\r\n    const menuData = req.body;\r\n    \r\n    const menu = await cafeteriaService.updateMenu(id, menuData);\r\n    \r\n    return sendSuccess(res, { menu }, 'Menu updated successfully');\r\n  } catch (error) {\r\n    logger.error(`Error updating menu with ID ${req.params.id}:`, error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a menu\r\n */\r\nconst deleteMenu = async (req, res, next) => {\r\n  try {\r\n    const { id } = req.params;\r\n    await cafeteriaService.deleteMenu(id);\r\n    \r\n    return sendSuccess(res, null, 'Menu deleted successfully');\r\n  } catch (error) {\r\n    logger.error(`Error deleting menu with ID ${req.params.id}:`, error);\r\n    \r\n    if (error.code === 'P2025') {\r\n      return sendError(res, 'Menu not found', 404);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Toggle meal availability in a menu\r\n */\r\nconst toggleMealAvailability = async (req, res, next) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { available } = req.body;\r\n    \r\n    if (typeof available !== 'boolean') {\r\n      return sendError(res, 'Available status must be a boolean', 400);\r\n    }\r\n    \r\n    const menuMeal = await cafeteriaService.toggleMealAvailability(id, available);\r\n    \r\n    return sendSuccess(\r\n      res, \r\n      { menuMeal }, \r\n      `Meal ${available ? 'enabled' : 'disabled'} successfully`\r\n    );\r\n  } catch (error) {\r\n    logger.error(`Error toggling availability for menu meal ID ${req.params.id}:`, error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Create a preorder\r\n */\r\nconst createPreorder = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const { menuMealId } = req.body;\r\n    const userId = req.user.id;\r\n    \r\n    const preorder = await cafeteriaService.createPreorder(userId, menuMealId);\r\n    \r\n    return sendSuccess(res, { preorder }, 'Preorder created successfully', 201);\r\n  } catch (error) {\r\n    logger.error('Error creating preorder:', error);\r\n    \r\n    if (error.message.includes('not available') || \r\n        error.message.includes('past menu')) {\r\n      return sendError(res, error.message, 400);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get user preorders\r\n */\r\nconst getUserPreorders = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n    const preorders = await cafeteriaService.getUserPreorders(userId);\r\n    \r\n    return sendSuccess(res, { preorders }, 'Preorders retrieved successfully');\r\n  } catch (error) {\r\n    logger.error(`Error retrieving preorders for user ${req.user.id}:`, error);\r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Update preorder status (admin only)\r\n */\r\nconst updatePreorderStatus = async (req, res, next) => {\r\n  try {\r\n    // Validate request\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      const errorMessages = errors.array().map(err => `${err.path}: ${err.msg}`).join(', ');\r\n      logger.debug('Validation errors:', errors.array());\r\n      throw new ValidationError(`Validation failed: ${errorMessages}`, errors.array());\r\n    }\r\n    \r\n    const { id } = req.params;\r\n    const { status } = req.body;\r\n    \r\n    const preorder = await cafeteriaService.updatePreorderStatus(id, status);\r\n    \r\n    return sendSuccess(res, { preorder }, 'Preorder status updated successfully');\r\n  } catch (error) {\r\n    logger.error(`Error updating status for preorder ${req.params.id}:`, error);\r\n    \r\n    if (error.message.includes('Invalid status')) {\r\n      return sendError(res, error.message, 400);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Cancel a preorder\r\n */\r\nconst cancelPreorder = async (req, res, next) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const userId = req.user.id;\r\n    \r\n    await cafeteriaService.cancelPreorder(id, userId);\r\n    \r\n    return sendSuccess(res, null, 'Preorder cancelled successfully');\r\n  } catch (error) {\r\n    logger.error(`Error cancelling preorder ${req.params.id}:`, error);\r\n    \r\n    if (error.message.includes('not authorized') || \r\n        error.message.includes('Cannot cancel')) {\r\n      return sendError(res, error.message, 400);\r\n    }\r\n    \r\n    if (error.message.includes('not found')) {\r\n      return sendError(res, 'Preorder not found', 404);\r\n    }\r\n    \r\n    next(error);\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  // Meal controllers\r\n  getMeals,\r\n  getMealById,\r\n  createMeal,\r\n  updateMeal,\r\n  deleteMeal,\r\n  \r\n  // Menu controllers\r\n  getMenus,\r\n  getMenuById,\r\n  getTodayMenu,\r\n  createMenu,\r\n  updateMenu,\r\n  deleteMenu,\r\n  toggleMealAvailability,\r\n  \r\n  // Preorder controllers\r\n  createPreorder,\r\n  getUserPreorders,\r\n  updatePreorderStatus,\r\n  cancelPreorder\r\n};"
          },
          {
            "type": "file",
            "name": "cart.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\cart.controller.js",
            "size": 2105,
            "content": "const cartService = require(\"../services/cart.service\");\r\nconst { validationResult } = require(\"express-validator\");\r\n\r\n\r\n\r\n// get cart\r\nexports.getCart = async (req, res) => {\r\n    const userId = req.user.id;\r\n    \r\n    try {\r\n      const cartItems = await cartService.getCartItems(userId);\r\n      return res.json({ items: cartItems });\r\n    } catch (error) {\r\n      console.error(\"Error in getCart controller:\", error);\r\n      return res.status(500).json({ error: \"Failed to fetch cart items\" });\r\n    }\r\n  };\r\n\r\n// add to cart\r\nexports.addToCart = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return res.status(400).json({ errors: errors.array() });\r\n  }\r\n\r\n  const { mealId } = req.body;\r\n  const userId = req.user.id;\r\n\r\n  try {\r\n    const cartItem = await cartService.addMealToCart(userId, mealId);\r\n    return res.json({ message: \"Meal added to cart\", cartItem });\r\n  } catch (error) {\r\n    console.error(\"Error in addToCart controller:\", error);\r\n    return res.status(500).json({ error: \"Failed to add meal to cart\" });\r\n  }\r\n};\r\n\r\n// update cart item quantity\r\nexports.updateCartItemQuantity = async (req, res) => {\r\n    const { id } = req.params;\r\n    const { quantity } = req.body;\r\n    const userId = req.user.id;\r\n  \r\n    try {\r\n      const updatedItem = await cartService.updateCartItemQuantity(userId, parseInt(id), quantity);\r\n      return res.json({ cartItem: updatedItem });\r\n    } catch (error) {\r\n      console.error(\"Error in updateCartItemQuantity controller:\", error);\r\n      return res.status(500).json({ error: \"Failed to update cart item quantity\" });\r\n    }\r\n  };\r\n\r\n// remove from cart\r\nexports.removeFromCart = async (req, res) => {\r\n    const { id } = req.params;\r\n    const userId = req.user.id;\r\n  \r\n    try {\r\n      await cartService.removeFromCart(userId, parseInt(id));\r\n      return res.json({ message: \"Item removed from cart\" });\r\n    } catch (error) {\r\n      console.error(\"Error in removeFromCart controller:\", error);\r\n      return res.status(500).json({ error: \"Failed to remove item from cart\" });\r\n    }\r\n  };"
          },
          {
            "type": "file",
            "name": "club.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\club.controller.js",
            "size": 12566,
            "content": "const { validationResult } = require('express-validator');\r\nconst clubService = require('../services/club.service');\r\nconst { sendSuccess, sendError } = require('../utils/response.util');\r\nconst { ValidationError } = require('../middleware/error.middleware');\r\nconst { logger } = require('../utils/logger.util');\r\nconst notificationService = require('../services/notification.service');\r\nconst { PrismaClient } = require('@prisma/client');\r\nconst prisma = new PrismaClient();\r\n\r\n// Create a new club\r\nconst createClub = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  try {\r\n    const club = await clubService.createClub(req.body);\r\n    return sendSuccess(res, { club }, 'Club created successfully');\r\n  } catch (error) {\r\n    logger.error('Error creating club:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Update an existing club\r\nconst updateClub = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  try {\r\n    const club = await clubService.updateClub(req.params.id, req.body);\r\n    return sendSuccess(res, { club }, 'Club updated successfully');\r\n  } catch (error) {\r\n    logger.error('Error updating club:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Delete a club\r\nconst deleteClub = async (req, res) => {\r\n  try {\r\n    await clubService.deleteClub(req.params.id);\r\n    return sendSuccess(res, null, 'Club deleted successfully');\r\n  } catch (error) {\r\n    logger.error('Error deleting club:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Follow a club\r\nconst followClub = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  try {\r\n    const follow = await clubService.followClub(req.user.id, req.params.clubId);\r\n    return sendSuccess(res, { follow }, 'Successfully followed the club');\r\n  } catch (error) {\r\n    logger.error('Error following club:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Unfollow a club\r\nconst unfollowClub = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  try {\r\n    await clubService.unfollowClub(req.user.id, req.params.clubId);\r\n    return sendSuccess(res, null, 'Successfully unfollowed the club');\r\n  } catch (error) {\r\n    logger.error('Error unfollowing club:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Add album photo\r\nconst addAlbumPhoto = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  try {\r\n    const photo = req.file; // Assuming file upload middleware is used\r\n    const albumPhoto = await clubService.addAlbumPhoto(req.params.clubId, photo);\r\n    return sendSuccess(res, { albumPhoto }, 'Album photo added successfully');\r\n  } catch (error) {\r\n    logger.error('Error adding album photo:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Remove album photo\r\nconst removeAlbumPhoto = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  try {\r\n    await clubService.removeAlbumPhoto(req.params.photoId);\r\n    return sendSuccess(res, null, 'Album photo removed successfully');\r\n  } catch (error) {\r\n    logger.error('Error removing album photo:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Add a user to a club\r\nconst addUserToClub = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  try {\r\n    const { userId, role } = req.body;\r\n    const clubId = req.params.clubId;\r\n    const userClub = await clubService.addUserToClub(userId, clubId, role);\r\n    // Send notification to the user\r\n    await notificationService.broadcastToChannel(`user:${userId}`, {\r\n      message: `You have been added to the club ${userClub.club.name} as ${role}.`,\r\n      clubId\r\n    });\r\n    return sendSuccess(res, { userClub }, 'User added to club successfully');\r\n  } catch (error) {\r\n    logger.error('Error adding user to club:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Remove a user from a club\r\nconst removeUserFromClub = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  try {\r\n    const userId = req.params.userId;\r\n    const clubId = req.params.clubId;\r\n    await clubService.removeUserFromClub(userId, clubId);\r\n    // Send notification to the user\r\n    await notificationService.broadcastToChannel(`user:${userId}`, {\r\n      message: `You have been removed from the club ${clubId}.`,\r\n      clubId\r\n    });\r\n    return sendSuccess(res, null, 'User removed from club successfully');\r\n  } catch (error) {\r\n    logger.error('Error removing user from club:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Change a user's role in a club\r\nconst changeUserRoleInClub = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  try {\r\n    const userId = req.params.userId;\r\n    const clubId = req.params.clubId;\r\n    const { newRole } = req.body;\r\n    await clubService.changeUserRoleInClub(userId, clubId, newRole);\r\n    // Send notification to the user\r\n    await notificationService.broadcastToChannel(`user:${userId}`, {\r\n      message: `Your role in the club has been changed to ${newRole}.`,\r\n      clubId\r\n    });\r\n    return sendSuccess(res, null, 'User role changed successfully');\r\n  } catch (error) {\r\n    logger.error('Error changing user role in club:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Change a user's status in a club\r\nconst changeUserStatusInClub = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  try {\r\n    const userId = req.params.userId;\r\n    const clubId = req.params.clubId;\r\n    const { newStatus } = req.body;\r\n    await clubService.changeUserStatusInClub(userId, clubId, newStatus);\r\n    return sendSuccess(res, null, 'User status changed successfully');\r\n  } catch (error) {\r\n    logger.error('Error changing user status in club:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get concise info of a club\r\nconst getClubInfo = async (req, res) => {\r\n  const { clubId } = req.params;\r\n  try {\r\n    const club = await prisma.club.findUnique({\r\n      where: { id: parseInt(clubId) },\r\n      select: {\r\n        id: true,\r\n        name: true,\r\n        coverPhoto: true,\r\n        followerCount: {\r\n          select: { _count: true }\r\n        }\r\n      }\r\n    });\r\n    return sendSuccess(res, { club }, 'Club info retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving club info:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get detailed info of a club\r\nconst getClubDetails = async (req, res) => {\r\n  const { clubId } = req.params;\r\n  try {\r\n    const club = await prisma.club.findUnique({\r\n      where: { id: parseInt(clubId) },\r\n      include: {\r\n        members: {\r\n          select: { userId, role }\r\n        },\r\n        followers: true,\r\n        moderator: true,\r\n        events: true\r\n      }\r\n    });\r\n    return sendSuccess(res, { club }, 'Club details retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving club details:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get events of a club\r\nconst getClubEvents = async (req, res) => {\r\n  const { clubId } = req.params;\r\n  const { page = 1, limit = 10 } = req.query;\r\n  try {\r\n    const events = await prisma.event.findMany({\r\n      where: { clubId: parseInt(clubId) },\r\n      skip: (page - 1) * limit,\r\n      take: limit\r\n    });\r\n    const totalCount = await prisma.event.count({ where: { clubId: parseInt(clubId) } });\r\n    return sendSuccess(res, { events, totalCount }, 'Club events retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving club events:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get analytics data for a club\r\nconst getClubAnalytics = async (req, res) => {\r\n  const { clubId } = req.params;\r\n  try {\r\n    const totalMembers = await prisma.userClub.count({\r\n      where: { clubId: parseInt(clubId) }\r\n    });\r\n\r\n    const totalFollowers = await prisma.club.followers.count({\r\n      where: { id: parseInt(clubId) }\r\n    });\r\n\r\n    const totalEvents = await prisma.event.count({\r\n      where: { clubId: parseInt(clubId) }\r\n    });\r\n\r\n    const totalVisits = await prisma.userVisit.count({\r\n      where: { clubId: parseInt(clubId) }\r\n    });\r\n\r\n    const followUnfollowLogs = await prisma.followUnfollowLog.findMany({\r\n      where: { clubId: parseInt(clubId) }\r\n    });\r\n\r\n    const followRate = followUnfollowLogs.filter(log => log.action === 'follow').length;\r\n    const unfollowRate = followUnfollowLogs.filter(log => log.action === 'unfollow').length;\r\n\r\n    const membersRoles = await prisma.userClub.groupBy({\r\n      by: ['role'],\r\n      where: { clubId: parseInt(clubId) },\r\n      _count: {\r\n        role: true\r\n      }\r\n    });\r\n\r\n    return sendSuccess(res, {\r\n      totalMembers,\r\n      totalFollowers,\r\n      totalEvents,\r\n      totalVisits,\r\n      followRate,\r\n      unfollowRate,\r\n      membersRoles\r\n    }, 'Club analytics retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving club analytics:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Log a user's visit to a club page\r\nconst logUserVisit = async (req, res) => {\r\n  const { clubId } = req.params;\r\n  const userId = req.user.id;\r\n  try {\r\n    await clubService.logUserVisit(userId, clubId);\r\n    return sendSuccess(res, null, 'User visit logged successfully');\r\n  } catch (error) {\r\n    logger.error('Error logging user visit:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Search for clubs\r\nconst searchClubs = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  const { query, page = 1, limit = 10, sort } = req.query;\r\n  try {\r\n    const clubs = await clubService.searchClubs({ query, page, limit, sort });\r\n    return sendSuccess(res, { clubs }, 'Clubs retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error searching clubs:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get short details of a club\r\nconst getClubShortDetails = async (req, res) => {\r\n  const { clubId } = req.params;\r\n  try {\r\n    const club = await prisma.club.findUnique({\r\n      where: { id: parseInt(clubId) },\r\n      select: {\r\n        id: true,\r\n        name: true,\r\n        coverPhoto: true,\r\n        followerCount: {\r\n          select: { _count: true }\r\n        },\r\n        description: true\r\n      }\r\n    });\r\n    return sendSuccess(res, { club }, 'Club short details retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving club short details:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get paginated and sortable list of clubs\r\nconst getPaginatedClubs = async (req, res) => {\r\n  const { page = 1, limit = 10, sort } = req.query;\r\n  try {\r\n    const where = {};\r\n    const clubs = await prisma.club.findMany({\r\n      where,\r\n      skip: (page - 1) * limit,\r\n      take: limit,\r\n      orderBy: sort === 'alphabetical' ? { name: 'asc' } : { foundingDate: 'desc' }\r\n    });\r\n    const totalCount = await prisma.club.count({ where });\r\n    return sendSuccess(res, { clubs, totalCount }, 'Clubs retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving paginated clubs:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  createClub,\r\n  updateClub,\r\n  deleteClub,\r\n  followClub,\r\n  unfollowClub,\r\n  addAlbumPhoto,\r\n  removeAlbumPhoto,\r\n  addUserToClub,\r\n  removeUserFromClub,\r\n  changeUserRoleInClub,\r\n  changeUserStatusInClub,\r\n  getClubInfo,\r\n  getClubDetails,\r\n  getClubEvents,\r\n  getClubAnalytics,\r\n  logUserVisit,\r\n  searchClubs,\r\n  getClubShortDetails,\r\n  getPaginatedClubs\r\n}; "
          },
          {
            "type": "file",
            "name": "department.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\department.controller.js",
            "size": 445,
            "content": "const departmentService = require('../services/department.service');\r\n\r\nclass DepartmentController {\r\n  async getDepartments(req, res) {\r\n    try {\r\n      const departments = await departmentService.getAllDepartments();\r\n      res.json(departments);\r\n    } catch (error) {\r\n      res.status(500).json({ message: error.message });\r\n    }\r\n  }\r\n}\r\n\r\nconst departmentController = new DepartmentController();\r\nmodule.exports = departmentController; "
          },
          {
            "type": "file",
            "name": "event.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\event.controller.js",
            "size": 7434,
            "content": "const { prisma } = require('../services/database.service');\r\nconst notificationService = require('../services/notification.service');\r\nconst eventService = require('../services/event.service');\r\nconst { sendSuccess, sendError } = require('../utils/response.util');\r\nconst { ValidationError } = require('../middleware/error.middleware');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\n// Create a new event\r\nconst createEvent = async (req, res) => {\r\n  const { name, description, startTime, endTime, clubId } = req.body;\r\n  try {\r\n    const event = await prisma.event.create({\r\n      data: {\r\n        name,\r\n        description,\r\n        startTime,\r\n        endTime,\r\n        clubId\r\n      }\r\n    });\r\n\r\n    // Broadcast notification to followers of the club\r\n    await notificationService.broadcastToChannel(`club:${clubId}`, {\r\n      message: `New event created: ${event.name}`,\r\n      eventId: event.id,\r\n      eventSlug: event.slug\r\n    });\r\n\r\n    res.status(201).json(event);\r\n  } catch (error) {\r\n    logger.error('Error creating event:', error);\r\n    res.status(500).json({ message: 'Error creating event' });\r\n  }\r\n};\r\n\r\n// Update an existing event\r\nconst updateEvent = async (req, res) => {\r\n  const { id } = req.params;\r\n  const { name, description, startTime, endTime } = req.body;\r\n  try {\r\n    const event = await prisma.event.update({\r\n      where: { id: parseInt(id) },\r\n      data: { name, description, startTime, endTime }\r\n    });\r\n\r\n    // Broadcast notification to followers of the club\r\n    await notificationService.broadcastToChannel(`club:${event.clubId}`, {\r\n      message: `Event updated: ${event.name}`,\r\n      eventId: event.id\r\n    });\r\n\r\n    res.json(event);\r\n  } catch (error) {\r\n    logger.error('Error updating event:', error);\r\n    res.status(500).json({ message: 'Error updating event' });\r\n  }\r\n};\r\n\r\n// Follow an event\r\nconst followEvent = async (req, res) => {\r\n  const { eventId } = req.params;\r\n  const userId = req.user.id;\r\n  try {\r\n    const follow = await eventService.followEvent(userId, eventId);\r\n    // Send notification to the user\r\n    await notificationService.broadcastToChannel(`user:${userId}`, {\r\n      message: `You are now following the event.`,\r\n      eventId\r\n    });\r\n    return sendSuccess(res, { follow }, 'Successfully followed the event');\r\n  } catch (error) {\r\n    logger.error('Error following event:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Unfollow an event\r\nconst unfollowEvent = async (req, res) => {\r\n  const { eventId } = req.params;\r\n  const userId = req.user.id;\r\n  try {\r\n    await eventService.unfollowEvent(userId, eventId);\r\n    // Send notification to the user\r\n    await notificationService.broadcastToChannel(`user:${userId}`, {\r\n      message: `You have unfollowed the event.`,\r\n      eventId\r\n    });\r\n    return sendSuccess(res, null, 'Successfully unfollowed the event');\r\n  } catch (error) {\r\n    logger.error('Error unfollowing event:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Log a user's visit to an event page\r\nconst logUserVisit = async (req, res) => {\r\n  const { eventId } = req.params;\r\n  const userId = req.user.id;\r\n  try {\r\n    await eventService.logUserVisit(userId, eventId);\r\n    return sendSuccess(res, null, 'User visit logged successfully');\r\n  } catch (error) {\r\n    logger.error('Error logging user visit:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get concise info of an event\r\nconst getEventInfo = async (req, res) => {\r\n  const { eventId } = req.params;\r\n  try {\r\n    const event = await prisma.event.findUnique({\r\n      where: { id: parseInt(eventId) },\r\n      select: {\r\n        id: true,\r\n        name: true,\r\n        startTime: true,\r\n        endTime: true,\r\n        club: { select: { name: true } }\r\n      }\r\n    });\r\n    return sendSuccess(res, { event }, 'Event info retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving event info:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get detailed info of an event\r\nconst getEventDetails = async (req, res) => {\r\n  const { eventId } = req.params;\r\n  try {\r\n    const event = await prisma.event.findUnique({\r\n      where: { id: parseInt(eventId) },\r\n      include: {\r\n        club: true,\r\n        followers: true\r\n      }\r\n    });\r\n    return sendSuccess(res, { event }, 'Event details retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving event details:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get analytics data for an event\r\nconst getEventAnalytics = async (req, res) => {\r\n  const { eventId } = req.params;\r\n  try {\r\n    const totalFollowers = await prisma.event.followers.count({\r\n      where: { id: parseInt(eventId) }\r\n    });\r\n\r\n    const followUnfollowLogs = await prisma.followUnfollowLog.findMany({\r\n      where: { eventId: parseInt(eventId) }\r\n    });\r\n\r\n    const followRate = followUnfollowLogs.filter(log => log.action === 'follow').length;\r\n    const unfollowRate = followUnfollowLogs.filter(log => log.action === 'unfollow').length;\r\n\r\n    return sendSuccess(res, {\r\n      totalFollowers,\r\n      followRate,\r\n      unfollowRate\r\n    }, 'Event analytics retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving event analytics:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Search for events\r\nconst searchEvents = async (req, res) => {\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return sendError(res, new ValidationError(errors.array()));\r\n  }\r\n  const { query, page = 1, limit = 10, sort } = req.query;\r\n  try {\r\n    const events = await eventService.searchEvents({ query, page, limit, sort });\r\n    return sendSuccess(res, { events }, 'Events retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error searching events:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get short details of an event\r\nconst getEventShortDetails = async (req, res) => {\r\n  const { eventId } = req.params;\r\n  try {\r\n    const event = await prisma.event.findUnique({\r\n      where: { id: parseInt(eventId) },\r\n      select: {\r\n        id: true,\r\n        name: true,\r\n        startTime: true,\r\n        endTime: true,\r\n        club: { select: { name: true } }\r\n      }\r\n    });\r\n    return sendSuccess(res, { event }, 'Event short details retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving event short details:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\n// Get paginated and sortable list of events\r\nconst getPaginatedEvents = async (req, res) => {\r\n  const { page = 1, limit = 10, sort } = req.query;\r\n  try {\r\n    const where = {};\r\n    const events = await prisma.event.findMany({\r\n      where,\r\n      skip: (page - 1) * limit,\r\n      take: limit,\r\n      orderBy: sort === 'latest' ? { startTime: 'desc' } : sort === 'oldest' ? { startTime: 'asc' } : { name: 'asc' }\r\n    });\r\n    const totalCount = await prisma.event.count({ where });\r\n    return sendSuccess(res, { events, totalCount }, 'Events retrieved successfully');\r\n  } catch (error) {\r\n    logger.error('Error retrieving paginated events:', error);\r\n    return sendError(res, error);\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  createEvent,\r\n  updateEvent,\r\n  followEvent,\r\n  unfollowEvent,\r\n  logUserVisit,\r\n  getEventInfo,\r\n  getEventDetails,\r\n  getEventAnalytics,\r\n  searchEvents,\r\n  getEventShortDetails,\r\n  getPaginatedEvents\r\n}; "
          },
          {
            "type": "file",
            "name": "order.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\order.controller.js",
            "size": 3921,
            "content": "const orderService = require('../services/order.service');\r\nconst { validationResult } = require('express-validator');\r\n\r\nexports.createOrder = async (req, res) => {\r\n  const userId = req.user.id;\r\n  const { items } = req.body;\r\n\r\n  console.log(\"Order request received for user:\", userId);\r\n  console.log(\"Items in request:\", JSON.stringify(items));\r\n\r\n  if (!items || !Array.isArray(items)) {\r\n    return res.status(400).json({ error: \"Invalid cart items\" });\r\n  }\r\n\r\n  try {\r\n    const orders = await orderService.createOrder(userId, items);\r\n    return res.json({ orders });\r\n  } catch (error) {\r\n    console.error(\"Error in createOrder controller:\", error);\r\n    return res.status(500).json({\r\n      error: \"Failed to create order\",\r\n      details: error.message\r\n    });\r\n  }\r\n};\r\n\r\nexports.getOrders = async (req, res) => {\r\n  const userId = req.user.id;\r\n  try {\r\n    const orders = await orderService.getUserOrders(userId);\r\n    return res.json({ orders });\r\n  } catch (error) {\r\n    console.error(\"Error in getOrders controller:\", error);\r\n    return res.status(500).json({ error: \"Failed to fetch orders\" });\r\n  }\r\n};\r\n\r\nexports.updateOrderStatus = async (req, res) => {\r\n  const { id } = req.params;\r\n  const { status } = req.body;\r\n  try {\r\n    const order = await orderService.updateOrderStatus(parseInt(id), status);\r\n    return res.json({ order });\r\n  } catch (error) {\r\n    console.error(\"Error in updateOrderStatus controller:\", error);\r\n    return res.status(500).json({ error: \"Failed to update order status\" });\r\n  }\r\n};\r\n\r\n\r\n\r\n// Get all orders for cafe manager\r\nexports.getOrdersForManagement = async (req, res) => {\r\n  try {\r\n    const orders = await orderService.getAllOrders();\r\n    return res.json({ orders });\r\n  } catch (error) {\r\n    console.error(\"Error in getOrdersForManagement controller:\", error);\r\n    return res.status(500).json({ message: \"Failed to fetch orders\" });\r\n  }\r\n};\r\n\r\n\r\nexports.updateOrderStatus = async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { status, approved, rejectionReason, pickupTime } = req.body;\r\n    \r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ message: \"Validation failed\", errors: errors.array() });\r\n    }\r\n\r\n    // Handle approvals\r\n    if (approved === true && status === 'placed') {\r\n      const order = await orderService.approveOrder(parseInt(id));\r\n      return res.json({ order });\r\n    }\r\n    \r\n    // Handle rejections with reason\r\n    if (status === 'cancelled' && rejectionReason) {\r\n      const order = await orderService.rejectOrder(parseInt(id), rejectionReason);\r\n      return res.json({ order });\r\n    }\r\n    \r\n    // Regular status update - now includes pickup time\r\n    const order = await orderService.updateOrderStatus(parseInt(id), status, pickupTime);\r\n    return res.json({ order });\r\n  } catch (error) {\r\n    console.error(\"Error in updateOrderStatus controller:\", error);\r\n    return res.status(500).json({ message: error.message || \"Failed to update order status\" });\r\n  }\r\n};\r\n\r\n\r\n// Update verification for CAFE_MANAGER\r\nexports.verifyOrder = async (req, res) => {\r\n  try {\r\n    const { verificationData } = req.body;\r\n    \r\n    if (!verificationData) {\r\n      return res.status(400).json({ message: \"Verification data is required\" });\r\n    }\r\n    \r\n    // Extract verification code\r\n    let verificationCode;\r\n    \r\n    if (typeof verificationData === 'string') {\r\n      verificationCode = verificationData;\r\n    } else {\r\n      verificationCode = verificationData.verificationCode;\r\n    }\r\n    \r\n    console.log('Controller received verification code:', verificationCode);\r\n    const order = await orderService.verifyOrder(verificationCode);\r\n    return res.status(200).json({ order });\r\n  } catch (error) {\r\n    console.error(\"Order verification error:\", error);\r\n    return res.status(400).json({ message: error.message });\r\n  }\r\n};"
          },
          {
            "type": "file",
            "name": "route.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\route.controller.js",
            "size": 1,
            "content": " "
          },
          {
            "type": "file",
            "name": "routine.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\routine.controller.js",
            "size": 3223,
            "content": "const routineService = require('../services/routine.service');\r\nconst { sendSuccess, sendError } = require('../utils/response.util');\r\n\r\nconst setWeeklySchedule = async (req, res, next) => {\r\n  try {\r\n    const  userId = req.user.id;\r\n    const { weekday, period1, period2, period3, period4, period5, period6, period7, period8, period9 } = req.body;\r\n\r\n    const routine = await routineService.setWeeklySchedule(userId, weekday, {\r\n      period1, period2, period3, period4, period5, period6, period7, period8, period9,\r\n    });\r\n\r\n    sendSuccess(res, routine, 'Weekly schedule set successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst addCourse = async (req, res, next) => {\r\n  try {\r\n    console.log('User from request:', req.user);\r\n    const userId  = req.user.id;\r\n    const { courseId, courseName, courseType } = req.body;\r\n    \r\n    if (!userId) {\r\n      throw new Error('User ID is missing from request');\r\n    }\r\n\r\n    const course = await routineService.addCourse(userId, courseId, courseName, courseType);\r\n\r\n    sendSuccess(res, course, 'Course added successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getWeeklySchedule = async (req, res, next) => {\r\n  try {\r\n    const  userId  = req.user.id;\r\n\r\n    const schedule = await routineService.getWeeklySchedule(userId);\r\n\r\n    sendSuccess(res, schedule, 'Weekly schedule retrieved successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getCourses = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n\r\n    const courses = await routineService.getCourses(userId);\r\n\r\n    sendSuccess(res, courses, 'Courses retrieved successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst addExam = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n    const { courseId, examType, syllabus, examDate } = req.body;\r\n    \r\n    const exam = await routineService.addExam(userId, courseId, examType, syllabus, new Date(examDate));\r\n\r\n    sendSuccess(res, exam, 'Exam added successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst updateExam = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n    const examId = req.params.id;\r\n    const { courseId, examType, syllabus, examDate } = req.body;\r\n    \r\n    const exam = await routineService.updateExam(userId, examId, courseId, examType, syllabus, new Date(examDate));\r\n\r\n    sendSuccess(res, exam, 'Exam updated successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst deleteExam = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n    const examId = req.params.id;\r\n    \r\n    await routineService.deleteExam(userId, examId);\r\n\r\n    sendSuccess(res, null, 'Exam deleted successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getExams = async (req, res, next) => {\r\n  try {\r\n    const userId = req.user.id;\r\n\r\n    const exams = await routineService.getExams(userId);\r\n\r\n    sendSuccess(res, exams, 'Exams retrieved successfully');\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  setWeeklySchedule,\r\n  addCourse,\r\n  getWeeklySchedule,\r\n  getCourses,\r\n  addExam,\r\n  updateExam,\r\n  deleteExam,\r\n  getExams,\r\n};"
          },
          {
            "type": "file",
            "name": "user.controller.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\controllers\\user.controller.js",
            "size": 1876,
            "content": "const userService = require('../services/user.service');\r\nconst { validationResult } = require('express-validator');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\nclass UserController {\r\n  async getProfile(req, res) {\r\n    try {\r\n      const user = await userService.getUserProfile(req.user.id);\r\n      res.json(user);\r\n    } catch (error) {\r\n      logger.error('Failed to get profile:', error);\r\n      res.status(error.message === 'User not found' ? 404 : 500)\r\n        .json({ message: error.message || 'Failed to get profile' });\r\n    }\r\n  }\r\n\r\n  async updateProfile(req, res) {\r\n    try {\r\n      // Check for validation errors\r\n      const errors = validationResult(req);\r\n      if (!errors.isEmpty()) {\r\n        return res.status(400).json({ \r\n          message: 'Validation failed',\r\n          errors: errors.array()\r\n        });\r\n      }\r\n\r\n      const user = await userService.updateProfile(req.user.id, req.body);\r\n      res.json(user);\r\n    } catch (error) {\r\n      logger.error('Failed to update profile:', error);\r\n      res.status(500).json({ message: error.message || 'Failed to update profile' });\r\n    }\r\n  }\r\n\r\n  async changePassword(req, res) {\r\n    try {\r\n      // Check for validation errors\r\n      const errors = validationResult(req);\r\n      if (!errors.isEmpty()) {\r\n        return res.status(400).json({ \r\n          message: 'Validation failed',\r\n          errors: errors.array()\r\n        });\r\n      }\r\n\r\n      const result = await userService.changePassword(req.user.id, req.body);\r\n      res.json(result);\r\n    } catch (error) {\r\n      logger.error('Failed to change password:', error);\r\n      res.status(error.message === 'Current password is incorrect' ? 400 : 500)\r\n        .json({ message: error.message || 'Failed to change password' });\r\n    }\r\n  }\r\n}\r\n\r\nconst userController = new UserController();\r\nmodule.exports = userController; "
          }
        ]
      },
      {
        "type": "file",
        "name": "index.js",
        "path": "E:\\Work\\MIST_Hackathon\\server\\src\\index.js",
        "size": 3234,
        "content": "require('dotenv').config();\r\nconst express = require('express');\r\nconst cors = require('cors');\r\nconst helmet = require('helmet');\r\nconst morgan = require('morgan');\r\nconst cookieParser = require('cookie-parser');\r\nconst compression = require('compression');\r\nconst { createServer } = require('http');\r\nconst routes = require('./routes');\r\nconst busRoutes = require('./routes/bus.routes');\r\nconst { connect } = require('./services/database.service');\r\nconst { verifyConnection: verifyEmailConnection } = require('./services/email.service');\r\nconst notificationService = require('./services/notification.service');\r\nconst { errorHandler, notFoundHandler } = require('./middleware/error.middleware');\r\nconst { logger, stream } = require('./utils/logger.util');\r\n\r\n// Initialize Express app\r\nconst app = express();\r\nconst httpServer = createServer(app);\r\nconst PORT = process.env.PORT || 8000;\r\n\r\n// Initialize Socket.io with notification service\r\nnotificationService.initialize(httpServer);\r\n\r\n// Connect to database service\r\nconnect()\r\n  .then(() => {\r\n    logger.info('Database service is ready');\r\n  })\r\n  .catch((error) => {\r\n    logger.error('Database service is not ready:', error);\r\n    process.exit(1);\r\n  });\r\n\r\n// Verify email service connection\r\nverifyEmailConnection()\r\n  .then((connected) => {\r\n    if (connected) {\r\n      logger.info('Email service is ready');\r\n    } else {\r\n      logger.warn('Email service is not ready. Emails will not be sent.');\r\n    }\r\n  })\r\n  .catch((error) => {\r\n    logger.error('Email service is not ready:', error);\r\n  });\r\n\r\n// Middleware\r\napp.use(helmet()); // Security headers\r\napp.use(compression()); // Compress responses\r\napp.use(morgan(process.env.NODE_ENV === 'development' ? 'dev' : 'combined', { stream })); // Logging\r\napp.use(express.json()); // Parse JSON request body\r\napp.use(express.urlencoded({ extended: true })); // Parse URL-encoded request body\r\napp.use(cookieParser()); // Parse cookies\r\n\r\n// CORS configuration\r\nconst corsOptions = {\r\n  origin: [process.env.CLIENT_URL || 'http://localhost:3000'], // Your frontend URL\r\n  credentials: true,\r\n  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],\r\n  allowedHeaders: ['Content-Type', 'Authorization', 'Accept'],\r\n  exposedHeaders: ['set-cookie'],\r\n  maxAge: 86400 // 24 hours\r\n};\r\napp.use(cors(corsOptions));\r\n\r\n// API routes\r\napp.use('/api/v1', routes);\r\napp.use('/api/bus', busRoutes);\r\n\r\n// 404 handler for routes that don't exist\r\napp.use(notFoundHandler);\r\n\r\n// Centralized error handler\r\napp.use(errorHandler);\r\n\r\n// Start server with Socket.io\r\nhttpServer.listen(PORT, () => {\r\n  logger.info(`Server running on port ${PORT} in ${process.env.NODE_ENV} mode`);\r\n  logger.info('Socket.io server initialized');\r\n});\r\n\r\n// Handle unhandled promise rejections\r\nprocess.on('unhandledRejection', (err) => {\r\n  logger.error('UNHANDLED REJECTION! ð¥ Shutting down...');\r\n  logger.error(`${err.name}: ${err.message}`);\r\n  logger.error(err.stack);\r\n  process.exit(1);\r\n});\r\n\r\n// Handle uncaught exceptions\r\nprocess.on('uncaughtException', (err) => {\r\n  logger.error('UNCAUGHT EXCEPTION! ð¥ Shutting down...');\r\n  logger.error(`${err.name}: ${err.message}`);\r\n  logger.error(err.stack);\r\n  process.exit(1);\r\n}); \r\n"
      },
      {
        "type": "directory",
        "name": "middleware",
        "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware",
        "children": [
          {
            "type": "file",
            "name": "auth.middleware.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\auth.middleware.js",
            "size": 7321,
            "content": "const jwt = require('jsonwebtoken');\nconst { prisma } = require('../services/database.service');\nrequire('dotenv').config();\n\n// Middleware to verify JWT token and attach user to request\nconst authenticate = async (req, res, next) => {\n  try {\n    // Get token from authorization header\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({ message: 'Authentication required. No token provided.' });\n    }\n\n    const token = authHeader.split(' ')[1];\n\n    // Verify token\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    \n    // Find user by ID\n    const user = await prisma.user.findUnique({\n      where: { id: decoded.userId },\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        roles: true,\n        status: true,\n        emailVerified: true,\n      }\n    });\n\n    if (!user) {\n      return res.status(401).json({ message: 'User not found or token invalid.' });\n    }\n\n    // Check if user is active\n    if (user.status === 'INACTIVE') {\n      return res.status(401).json({ message: 'Account is not active. Please contact the admin to activate your account.' });\n    }\n\n    if (user.status === 'SUSPENDED') {\n      return res.status(401).json({ message: 'Account is suspended. Please contact the admin to activate your account.' });\n    }\n\n    // Attach user to request\n    req.user = user;\n    next();\n  } catch (error) {\n    if (error.name === 'TokenExpiredError') {\n      return res.status(401).json({ message: 'Token expired. Please login again.' });\n    }\n    \n    if (error.name === 'JsonWebTokenError') {\n      return res.status(401).json({ message: 'Invalid token. Please login again.' });\n    }\n    \n    console.error('Authentication error:', error);\n    return res.status(500).json({ message: 'Internal server error during authentication.' });\n  }\n};\n\n// Define role-based permissions\nconst PERMISSIONS = {\n  ADMIN: [\n    'manage_users', 'view_users', 'delete_users',\n    'manage_content', 'view_content', 'delete_content',\n    'manage_settings', 'view_settings',\n    'manage_roles', 'view_roles',\n    'manage_faculty', 'view_faculty',\n    'manage_students', 'view_students',\n    'manage_office', 'view_office',\n    'manage_cafe', 'view_cafe',\n    'manage_clubs', 'view_clubs',\n  ],\n  STUDENT: [\n    'view_content',\n    'view_clubs',\n    'join_clubs',\n    'view_cafe',\n    'place_cafe_orders',\n  ],\n  FACULTY: [\n    'view_content',\n    'manage_content',\n    'view_students',\n    'view_clubs',\n    'view_cafe',\n    'place_cafe_orders',\n  ],\n  OFFICE_MANAGER: [\n    'view_content',\n    'manage_content',\n    'view_students',\n    'view_faculty',\n    'manage_office',\n    'view_office',\n  ],\n  CAFE_MANAGER: [\n    'view_content',\n    'manage_cafe',\n    'view_cafe',\n    'manage_cafe_items',\n    'view_cafe_orders',\n    'manage_cafe_orders',\n  ],\n  CLUB_MODERATOR: [\n    'view_content',\n    'manage_content',\n    'view_clubs',\n    'manage_clubs',\n    'view_club_members',\n    'manage_club_members',\n  ],\n};\n\n// Get all permissions for a user based on their roles\nconst getUserPermissions = (roles) => {\n  if (!Array.isArray(roles) || roles.length === 0) {\n    return [];\n  }\n  \n  // Combine permissions from all roles\n  const permissions = new Set();\n  \n  roles.forEach(role => {\n    const rolePermissions = PERMISSIONS[role] || [];\n    rolePermissions.forEach(permission => permissions.add(permission));\n  });\n  \n  return Array.from(permissions);\n};\n\n// Middleware to check if user has at least one of the required roles\nconst authorize = (requiredRoles = []) => {\n  if (typeof requiredRoles === 'string') {\n    requiredRoles = [requiredRoles];\n  }\n\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ message: 'Authentication required before authorization.' });\n    }\n    \n    // Get user roles (use roles array)\n    const userRoles = req.user.roles;\n    \n    // Check if user has any of the required roles\n    const hasRole = requiredRoles.length === 0 || requiredRoles.some(role => userRoles.includes(role));\n    \n    if (!hasRole) {\n      return res.status(403).json({\n        message: 'Forbidden: You do not have the required permission to access this resource.'\n      });\n    }\n    \n    next();\n  };\n};\n\n// Middleware to check if user has specific permission\nconst hasPermission = (requiredPermissions = []) => {\n  if (typeof requiredPermissions === 'string') {\n    requiredPermissions = [requiredPermissions];\n  }\n\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ message: 'Authentication required before authorization.' });\n    }\n    \n    // Get user roles (use roles array if available, fallback to single role)\n    const userRoles = req.user.roles || [req.user.role];\n    \n    // Get all permissions for the user\n    const userPermissions = getUserPermissions(userRoles);\n    \n    const hasRequiredPermission = requiredPermissions.some(permission => \n      userPermissions.includes(permission)\n    );\n    \n    if (!hasRequiredPermission) {\n      return res.status(403).json({\n        message: 'Forbidden: You do not have the required permission to access this resource.'\n      });\n    }\n    \n    next();\n  };\n};\n\n// Middleware to verify email is confirmed\nconst requireEmailVerified = (req, res, next) => {\n  if (!req.user) {\n    return res.status(401).json({ message: 'Authentication required.' });\n  }\n  \n  if (!req.user.emailVerified) {\n    return res.status(403).json({ \n      message: 'Email verification required. Please verify your email address before proceeding.' \n    });\n  }\n  \n  next();\n};\n\nasync function checkClubRole(req, res, next) {\n  const { userId } = req.user; // Assuming userId is available in req.user\n  const { clubId } = req.params; // Assuming clubId is passed in the request parameters\n\n  const userClub = await prisma.userClub.findFirst({\n    where: {\n      userId: userId,\n      clubId: parseInt(clubId),\n      status: 'ACTIVE'\n    }\n  });\n\n  if (!userClub) {\n    return res.status(403).json({ message: 'Access denied: You are not a member of this club.' });\n  }\n\n  // Check if the user is a moderator or manager\n  if (userClub.role === 'MODERATOR' || userClub.role === 'MANAGER') {\n    return next(); // User has the required role\n  }\n\n  return res.status(403).json({ message: 'Access denied: You do not have the required role for this club.' });\n}\n\nconst authorizeAdmin = (req, res, next) => {\n  if (req.user.role !== 'ADMIN') {\n    return res.status(403).json({ message: 'Access denied: Admins only.' });\n  }\n  next();\n};\n\nconst authorizeModeratorOrManager = async (req, res, next) => {\n  const { userId } = req.user;\n  const { clubId } = req.params;\n  // Check if the user is a moderator or manager of the club\n  const userClub = await prisma.userClub.findFirst({\n    where: {\n      userId,\n      clubId: parseInt(clubId),\n      status: 'ACTIVE'\n    }\n  });\n  if (!userClub || (userClub.role !== 'MODERATOR' && userClub.role !== 'MANAGER')) {\n    return res.status(403).json({ message: 'Access denied: You do not have the required role.' });\n  }\n  next();\n};\n\nmodule.exports = {\n  authenticate,\n  authorize,\n  authorizeAdmin,\n  authorizeModeratorOrManager,\n  hasPermission,\n  getUserPermissions,\n  requireEmailVerified,\n  PERMISSIONS,\n  checkClubRole\n}; "
          },
          {
            "type": "file",
            "name": "bus.middleware.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\bus.middleware.js",
            "size": 0,
            "content": ""
          },
          {
            "type": "file",
            "name": "error.middleware.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\error.middleware.js",
            "size": 4113,
            "content": "const { sendError, getErrorStatusCode } = require('../utils/response.util');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\n/**\r\n * Custom error classes for different types of errors\r\n */\r\nclass ValidationError extends Error {\r\n  constructor(message, details = null) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n    this.details = details;\r\n  }\r\n}\r\n\r\nclass UnauthorizedError extends Error {\r\n  constructor(message = 'Unauthorized access') {\r\n    super(message);\r\n    this.name = 'UnauthorizedError';\r\n  }\r\n}\r\n\r\nclass ForbiddenError extends Error {\r\n  constructor(message = 'Forbidden access') {\r\n    super(message);\r\n    this.name = 'ForbiddenError';\r\n  }\r\n}\r\n\r\nclass NotFoundError extends Error {\r\n  constructor(message = 'Resource not found') {\r\n    super(message);\r\n    this.name = 'NotFoundError';\r\n  }\r\n}\r\n\r\nclass ConflictError extends Error {\r\n  constructor(message = 'Resource conflict') {\r\n    super(message);\r\n    this.name = 'ConflictError';\r\n  }\r\n}\r\n\r\nclass DatabaseError extends Error {\r\n  constructor(message = 'Database error occurred', details = null) {\r\n    super(message);\r\n    this.name = 'DatabaseError';\r\n    this.details = details;\r\n  }\r\n}\r\n\r\n/**\r\n * Centralized error handling middleware\r\n */\r\nconst errorHandler = (err, req, res, next) => {\r\n  // Log error\r\n  logger.error(`[${req.method}] ${req.path} >> StatusCode:: ${getErrorStatusCode(err)}, Message:: ${err.message}`);\r\n  \r\n  // For debugging in development\r\n  if (process.env.NODE_ENV === 'development') {\r\n    logger.debug(err.stack);\r\n  }\r\n\r\n  // Handle database connection errors\r\n  if (err.message && err.message.includes('Database connection not initialized')) {\r\n    logger.error('Database connection error detected', err);\r\n    return sendError(\r\n      res,\r\n      'Database connection error',\r\n      503, // Service Unavailable\r\n      { type: 'database_connection_error' }\r\n    );\r\n  }\r\n\r\n  // Get appropriate status code\r\n  const statusCode = getErrorStatusCode(err);\r\n  \r\n  // Prepare detailed error information\r\n  let errorDetails = null;\r\n  \r\n  // Include validation errors details if available\r\n  if (err.details || err.errors) {\r\n    errorDetails = err.details || err.errors;\r\n  }\r\n  \r\n  // For Prisma errors, provide more helpful messages\r\n  if (err.code) {\r\n    switch (err.code) {\r\n      case 'P2002': // Unique constraint failed\r\n        const fields = err.meta?.target || ['field'];\r\n        return sendError(\r\n          res, \r\n          `Duplicate entry: ${fields.join(', ')} already exists`, \r\n          409,\r\n          { fields, type: 'unique_constraint' }\r\n        );\r\n      \r\n      case 'P2025': // Record not found\r\n        return sendError(res, 'Resource not found', 404, { type: 'not_found' });\r\n      \r\n      case 'P2003': // Foreign key constraint failed\r\n        return sendError(\r\n          res,\r\n          'Operation failed due to a reference constraint',\r\n          400,\r\n          { type: 'foreign_key_constraint' }\r\n        );\r\n      \r\n      case 'P2000': // Input value too long\r\n        return sendError(\r\n          res,\r\n          'Input value is too long',\r\n          400,\r\n          { type: 'input_too_long' }\r\n        );\r\n      \r\n      // Add more Prisma error cases as needed\r\n    }\r\n  }\r\n  \r\n  // For validation errors from express-validator\r\n  if (err.array && typeof err.array === 'function') {\r\n    const validationErrors = err.array();\r\n    return sendError(\r\n      res, \r\n      'Validation failed', \r\n      400, \r\n      { validationErrors, type: 'validation_error' }\r\n    );\r\n  }\r\n\r\n  // Send standardized error response\r\n  return sendError(\r\n    res,\r\n    err.message || 'Internal server error',\r\n    statusCode,\r\n    errorDetails\r\n  );\r\n};\r\n\r\n/**\r\n * 404 handler for routes that don't exist\r\n */\r\nconst notFoundHandler = (req, res) => {\r\n  logger.warn(`[${req.method}] ${req.path} - Route not found`);\r\n  return sendError(res, `Route not found: ${req.method} ${req.path}`, 404);\r\n};\r\n\r\nmodule.exports = {\r\n  errorHandler,\r\n  notFoundHandler,\r\n  ValidationError,\r\n  UnauthorizedError,\r\n  ForbiddenError,\r\n  NotFoundError,\r\n  ConflictError,\r\n  DatabaseError\r\n}; "
          },
          {
            "type": "file",
            "name": "rate-limit.middleware.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\rate-limit.middleware.js",
            "size": 1093,
            "content": "const rateLimit = require('express-rate-limit');\r\nrequire('dotenv').config();\r\n\r\n// Parse environment variables\r\nconst WINDOW_MS = eval(process.env.RATE_LIMIT_WINDOW_MS) || 5 * 60 * 1000; // Default: 5 minutes\r\nconst MAX_REQUESTS = parseInt(process.env.RATE_LIMIT_MAX) || 100; // Default: 100 requests per window\r\n\r\n// // Create a standard limiter\r\nconst standardLimiter = rateLimit({\r\n  windowMs: WINDOW_MS,\r\n  max: MAX_REQUESTS,\r\n  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers\r\n  legacyHeaders: false, // Disable the `X-RateLimit-*` headers\r\n  message: {\r\n    status: 429,\r\n    message: 'Too many requests, please try again later.',\r\n  },\r\n});\r\n\r\n// // Create a stricter limiter for sensitive routes (auth, etc.)\r\nconst authLimiter = rateLimit({\r\n  windowMs: WINDOW_MS,\r\n  max: 20, // Much lower limit for sensitive operations\r\n  standardHeaders: true,\r\n  legacyHeaders: false,\r\n  message: {\r\n    status: 429,\r\n    message: 'Too many authentication attempts, please try again later.',\r\n  },\r\n});\r\n\r\nmodule.exports = {\r\n  standardLimiter,\r\n  authLimiter,\r\n}; "
          },
          {
            "type": "directory",
            "name": "validators",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators",
            "children": [
              {
                "type": "file",
                "name": "assignment.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\assignment.validator.js",
                "size": 841,
                "content": "const { body } = require('express-validator');\r\n\r\n// Validation for creating an assignment\r\nconst createAssignmentValidator = [\r\n  body('courseId').isString().notEmpty().withMessage('Course ID is required'),\r\n  body('assignmentName').isString().notEmpty().withMessage('Assignment name is required'),\r\n  body('assignmentContent').optional().isString(),\r\n  body('deadline').isISO8601().withMessage('Valid deadline date is required'),\r\n];\r\n\r\n// Validation for updating an assignment\r\nconst updateAssignmentValidator = [\r\n  body('courseId').optional().isString(),\r\n  body('assignmentName').optional().isString(),\r\n  body('assignmentContent').optional().isString(),\r\n  body('deadline').optional().isISO8601().withMessage('Valid deadline date is required'),\r\n];\r\n\r\nmodule.exports = {\r\n  createAssignmentValidator,\r\n  updateAssignmentValidator,\r\n};"
              },
              {
                "type": "file",
                "name": "auth.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\auth.validator.js",
                "size": 6290,
                "content": "const { body } = require('express-validator');\r\n\r\n// Registration validation\r\nconst registerEmployeeValidator = [\r\n  body('email')\r\n    .isEmail()\r\n    .withMessage('Please provide a valid email address')\r\n    .normalizeEmail(),\r\n  \r\n  body('password')\r\n    .isLength({ min: 8, max: 128 })\r\n    .withMessage('Password must be between 8 and 128 characters')\r\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+/)\r\n    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'),\r\n  \r\n  body('name')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Name is required')\r\n    .isLength({ max: 50 })\r\n    .withMessage('Name cannot exceed 50 characters'),\r\n    \r\n  // body('captchaToken')\r\n  //   .notEmpty()\r\n  //   .withMessage('CAPTCHA verification is required')\r\n\r\n  body('employeeId')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Employee ID is required')\r\n    .isLength({ min: 10, max: 10 })\r\n    .withMessage('Employee ID must be 10 digits'),\r\n\r\n  body('designation')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Designation is required')\r\n    .isLength({ max: 50 })\r\n    .withMessage('Designation cannot exceed 50 characters'),\r\n];\r\n\r\n// Student registration validation\r\nconst registerStudentValidator = [\r\n  body('email')\r\n    .isEmail()\r\n    .withMessage('Please provide a valid email address')\r\n    .normalizeEmail()\r\n    .notEmpty()\r\n    .withMessage('Email is required'),\r\n\r\n  body('password')\r\n    .isLength({ min: 8, max: 128 })\r\n    .notEmpty()\r\n    .withMessage('Password is required')\r\n    .withMessage('Password must be between 8 and 128 characters')\r\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+/)\r\n    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'),\r\n\r\n  body('name')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Name is required')\r\n    .isLength({ max: 255 })\r\n    .withMessage('Name cannot exceed 255 characters'),\r\n\r\n  // body('captchaToken')\r\n  //   .notEmpty()\r\n  //   .withMessage('CAPTCHA verification is required')\r\n\r\n  body('studentId')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Student ID is required')\r\n    .isLength({ min: 7, max: 7 })\r\n    .withMessage('Student ID must be 7 digits'),\r\n\r\n  body('section')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Section is required')\r\n    .isLength({ max: 10 })\r\n    .withMessage('Section cannot exceed 10 characters'),\r\n\r\n  body('batch')\r\n    .isInt()\r\n    .toInt()\r\n    .notEmpty()\r\n    .withMessage('Batch is required')\r\n    .isInt({ min: 1974, max: new Date().getFullYear() })\r\n    .withMessage('Batch must be between 1974 and the current year'),\r\n  \r\n  body('departmentId')\r\n    .isInt()\r\n    .toInt()\r\n    .notEmpty()\r\n    .withMessage('Department is required')\r\n    .isInt({ min: 1, max: 100 })\r\n    .withMessage('Department must be between 1 and 100'),\r\n];\r\n\r\n// Faculty registration validation\r\nconst registerFacultyValidator = [\r\n  body('email')\r\n    .isEmail()\r\n    .withMessage('Please provide a valid email address')\r\n    .normalizeEmail()\r\n    .notEmpty()\r\n    .withMessage('Email is required'),\r\n\r\n    body('password')\r\n    .isLength({ min: 8, max: 128 })\r\n    .notEmpty()\r\n    .withMessage('Password is required')\r\n    .withMessage('Password must be between 8 and 128 characters')\r\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+/)\r\n    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'),\r\n\r\n  body('name')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Name is required')\r\n    .isLength({ max: 255 })\r\n    .withMessage('Name cannot exceed 255 characters'),\r\n\r\n  // body('captchaToken')\r\n  //   .notEmpty()\r\n  //   .withMessage('CAPTCHA verification is required')\r\n\r\n  body('employeeId')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Employee ID is required')\r\n    .isLength({ min: 10, max: 10 })\r\n    .withMessage('Employee ID must be 10 digits'),\r\n\r\n  body('status')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Status is required')\r\n    .isLength({ max: 20 })\r\n    .withMessage('Status cannot exceed 20 characters'),\r\n\r\n  body('designation')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Designation is required')\r\n    .isLength({ max: 50 })\r\n    .withMessage('Designation cannot exceed 50 characters'),\r\n\r\n  body('departmentId')\r\n    .isInt()\r\n    .toInt()\r\n    .notEmpty()\r\n    .withMessage('Department is required')\r\n    .isInt({ min: 1, max: 100 })\r\n    .withMessage('Department must be between 1 and 100'),\r\n\r\n  body('bio')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Bio is required')\r\n    .isLength({ max: 1000 })\r\n    .withMessage('Bio cannot exceed 1000 characters'),\r\n];\r\n\r\n// Login validation\r\nconst loginValidator = [\r\n  body('email')\r\n    .isEmail()\r\n    .withMessage('Please provide a valid email address')\r\n    .normalizeEmail(),\r\n  \r\n  body('password')\r\n    .notEmpty()\r\n    .withMessage('Password is required'),\r\n    \r\n  // body('captchaToken')\r\n  //   .notEmpty()\r\n  //   .withMessage('CAPTCHA verification is required')\r\n];\r\n\r\n// Password reset request validation\r\nconst requestPasswordResetValidator = [\r\n  body('email')\r\n    .isEmail()\r\n    .withMessage('Please provide a valid email address')\r\n    .normalizeEmail(),\r\n    \r\n  // body('captchaToken')\r\n  //   .notEmpty()\r\n  //   .withMessage('CAPTCHA verification is required')\r\n];\r\n\r\n// Reset password validation\r\nconst resetPasswordValidator = [\r\n  body('password')\r\n    .isLength({ min: 8, max: 128 })\r\n    .withMessage('Password must be between 8 and 128 characters')\r\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+/)\r\n    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'),\r\n];\r\n\r\nmodule.exports = {\r\n  registerEmployeeValidator,\r\n  registerStudentValidator,\r\n  registerFacultyValidator,\r\n  loginValidator,\r\n  requestPasswordResetValidator,\r\n  resetPasswordValidator\r\n}; "
              },
              {
                "type": "file",
                "name": "bus.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\bus.validator.js",
                "size": 2821,
                "content": "const { body, param } = require('express-validator');\r\n\r\n/**\r\n * Validators for Bus endpoints\r\n */\r\nconst createBusValidator = [\r\n  body('busNumber')\r\n    .notEmpty().withMessage('Bus number is required'),\r\n  body('licensePlate')\r\n    .optional()\r\n    .isString().withMessage('License plate must be a string'),\r\n  body('capacity')\r\n    .isInt({ gt: 0 }).withMessage('Capacity must be a positive integer'),\r\n  body('type')\r\n    .optional()\r\n    .isIn(['SHUTTLE', 'MINIBUS', 'ARTICULATED']).withMessage('Invalid bus type'),\r\n];\r\n\r\nconst updateBusValidator = [\r\n  param('id')\r\n    .notEmpty().withMessage('Bus ID is required'),\r\n  body('busNumber')\r\n    .optional()\r\n    .notEmpty().withMessage('Bus number cannot be empty'),\r\n  body('licensePlate')\r\n    .optional()\r\n    .isString().withMessage('License plate must be a string'),\r\n  body('capacity')\r\n    .optional()\r\n    .isInt({ gt: 0 }).withMessage('Capacity must be a positive integer'),\r\n  body('type')\r\n    .optional()\r\n    .isIn(['SHUTTLE', 'MINIBUS', 'ARTICULATED']).withMessage('Invalid bus type'),\r\n];\r\n\r\nconst deleteBusValidator = [\r\n  param('id')\r\n    .notEmpty().withMessage('Bus ID is required'),\r\n];\r\n\r\nconst getBusByIdValidator = [\r\n  param('id')\r\n    .notEmpty().withMessage('Bus ID is required'),\r\n];\r\n\r\nconst getBusesValidator = [\r\n  // Add any query parameters validation if needed\r\n];\r\n\r\nconst createDriverValidator = [\r\n  body('firstName')\r\n    .notEmpty().withMessage('First name is required'),\r\n  body('lastName')\r\n    .notEmpty().withMessage('Last name is required'),\r\n  body('licenseNumber')\r\n    .notEmpty().withMessage('License number is required')\r\n    .isString().withMessage('License number must be a string'),\r\n  body('phone')\r\n    .optional()\r\n    .isString().withMessage('Phone must be a string'),\r\n  body('isAvailable')\r\n    .optional()\r\n    .isBoolean().withMessage('IsAvailable must be a boolean'),\r\n];\r\n\r\nconst updateDriverValidator = [\r\n  param('id')\r\n    .notEmpty().withMessage('Driver ID is required'),\r\n  body('firstName')\r\n    .optional()\r\n    .notEmpty().withMessage('First name cannot be empty'),\r\n  body('lastName')\r\n    .optional()\r\n    .notEmpty().withMessage('Last name cannot be empty'),\r\n  body('licenseNumber')\r\n    .optional()\r\n    .isString().withMessage('License number must be a string'),\r\n  body('phone')\r\n    .optional()\r\n    .isString().withMessage('Phone must be a string'),\r\n  body('isAvailable')\r\n    .optional()\r\n    .isBoolean().withMessage('IsAvailable must be a boolean'),\r\n];\r\n\r\nconst deleteDriverValidator = [\r\n  param('id')\r\n    .notEmpty().withMessage('Driver ID is required'),\r\n];\r\n\r\nmodule.exports = {\r\n  createBusValidator,\r\n  updateBusValidator,\r\n  deleteBusValidator,\r\n  getBusByIdValidator,\r\n  getBusesValidator,\r\n  createDriverValidator,\r\n  updateDriverValidator,\r\n  deleteDriverValidator,\r\n};\r\n"
              },
              {
                "type": "file",
                "name": "cafeteria.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\cafeteria.validator.js",
                "size": 7316,
                "content": "const { body, param, query } = require('express-validator');\r\n\r\n/**\r\n * Validators for Meal endpoints\r\n */\r\nconst createMealValidator = [\r\n    body('name')\r\n        .notEmpty().withMessage('Name is required'),\r\n    body('description')\r\n        .optional()\r\n        .isString().withMessage('Description must be a string'),\r\n    body('calories')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Calories must be a positive number'),\r\n    body('protein')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Protein must be a positive number'),\r\n    body('carbs')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Carbs must be a positive number'),\r\n    body('fat')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Fat must be a positive number'),\r\n    body('fiber')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Fiber must be a positive number'),\r\n    body('sugar')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Sugar must be a positive number'),\r\n    body('sodium')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Sodium must be a positive number'),\r\n    body('vitaminA')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Vitamin A must be a positive number'),\r\n    body('vitaminC')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Vitamin C must be a positive number'),\r\n    body('calcium')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Calcium must be a positive number'),\r\n    body('iron')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Iron must be a positive number'),\r\n    body('isSugarFree')\r\n        .optional()\r\n        .isBoolean().withMessage('Sugar free flag must be a boolean'),\r\n    body('isLowFat')\r\n        .optional()\r\n        .isBoolean().withMessage('Low fat flag must be a boolean'),\r\n    body('isOrganic')\r\n        .optional()\r\n        .isBoolean().withMessage('Organic flag must be a boolean'),\r\n];\r\n\r\nconst updateMealValidator = [\r\n    param('id')\r\n        .isInt().withMessage('Meal id must be an integer'),\r\n    body('name')\r\n        .optional()\r\n        .notEmpty().withMessage('Name cannot be empty'),\r\n    body('description')\r\n        .optional()\r\n        .isString().withMessage('Description must be a string'),\r\n    body('calories')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Calories must be a positive number'),\r\n    body('protein')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Protein must be a positive number'),\r\n    body('carbs')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Carbs must be a positive number'),\r\n    body('fat')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Fat must be a positive number'),\r\n    body('fiber')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Fiber must be a positive number'),\r\n    body('sugar')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Sugar must be a positive number'),\r\n    body('sodium')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Sodium must be a positive number'),\r\n    body('vitaminA')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Vitamin A must be a positive number'),\r\n    body('vitaminC')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Vitamin C must be a positive number'),\r\n    body('calcium')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Calcium must be a positive number'),\r\n    body('iron')\r\n        .optional()\r\n        .isInt({ min: 0 }).withMessage('Iron must be a positive number'),\r\n    body('isSugarFree')\r\n        .optional()\r\n        .isBoolean().withMessage('Sugar free flag must be a boolean'),\r\n    body('isLowFat')\r\n        .optional()\r\n        .isBoolean().withMessage('Low fat flag must be a boolean'),\r\n    body('isOrganic')\r\n        .optional()\r\n        .isBoolean().withMessage('Organic flag must be a boolean'),\r\n];\r\n\r\nconst deleteMealValidator = [\r\n    param('id')\r\n        .isInt().withMessage('Meal id must be an integer'),\r\n];\r\n\r\nconst getMealByIdValidator = [\r\n    param('id')\r\n        .isInt().withMessage('Meal id must be an integer'),\r\n];\r\n\r\n/**\r\n * Validators for Menu endpoints\r\n */\r\nconst createMenuValidator = [\r\n    body('date')\r\n        .notEmpty().withMessage('Date is required')\r\n        .isISO8601().withMessage('Date must be a valid ISO8601 date')\r\n        .toDate(),\r\n    body('meals')\r\n        .optional()\r\n        .isArray().withMessage('Meals must be an array'),\r\n    body('meals.*.mealId')\r\n        .isInt().withMessage('mealId must be an integer'),\r\n    body('meals.*.price')\r\n        .isDecimal().withMessage('Price must be a decimal'),\r\n    body('meals.*.available')\r\n        .optional()\r\n        .isBoolean().withMessage('Available must be a boolean'),\r\n];\r\n\r\nconst updateMenuValidator = [\r\n    param('id')\r\n        .isInt().withMessage('Menu id must be an integer'),\r\n    body('date')\r\n        .optional()\r\n        .isISO8601().withMessage('Date must be a valid ISO8601 date')\r\n        .toDate(),\r\n    body('meals')\r\n        .optional()\r\n        .isArray().withMessage('Meals must be an array'),\r\n    body('meals.*.mealId')\r\n        .isInt().withMessage('mealId must be an integer'),\r\n    body('meals.*.price')\r\n        .isDecimal().withMessage('Price must be a decimal'),\r\n    body('meals.*.available')\r\n        .optional()\r\n        .isBoolean().withMessage('Available must be a boolean'),\r\n    body('removeOthers')\r\n        .optional()\r\n        .isBoolean().withMessage('removeOthers must be a boolean'),\r\n];\r\n\r\nconst deleteMenuValidator = [\r\n    param('id')\r\n        .isInt().withMessage('Menu id must be an integer'),\r\n];\r\n\r\nconst getMenuByIdValidator = [\r\n    param('id')\r\n        .isInt().withMessage('Menu id must be an integer'),\r\n];\r\n\r\nconst getMenusValidator = [\r\n    query('date')\r\n        .optional()\r\n        .isISO8601().withMessage('Date must be a valid ISO8601 date')\r\n        .toDate(),\r\n];\r\n\r\nconst toggleMealAvailabilityValidator = [\r\n    param('id')\r\n        .isInt().withMessage('Menu meal id must be an integer'),\r\n    body('available')\r\n        .isBoolean().withMessage('Available status must be a boolean'),\r\n];\r\n\r\n/**\r\n * Validators for Preorder endpoints\r\n */\r\nconst createPreorderValidator = [\r\n    body('menuMealId')\r\n        .notEmpty().withMessage('menuMealId is required')\r\n        .isInt().withMessage('menuMealId must be an integer'),\r\n];\r\n\r\nconst updatePreorderStatusValidator = [\r\n    param('id')\r\n        .isInt().withMessage('Preorder id must be an integer'),\r\n    body('status')\r\n        .notEmpty().withMessage('Status is required')\r\n        .isIn(['placed', 'ready', 'picked_up', 'cancelled']).withMessage('Invalid status value'),\r\n];\r\n\r\nconst cancelPreorderValidator = [\r\n    param('id')\r\n        .isInt().withMessage('Preorder id must be an integer'),\r\n];\r\n\r\nmodule.exports = {\r\n    // Meal validators\r\n    createMealValidator,\r\n    updateMealValidator,\r\n    deleteMealValidator,\r\n    getMealByIdValidator,\r\n    // Menu validators\r\n    createMenuValidator,\r\n    updateMenuValidator,\r\n    deleteMenuValidator,\r\n    getMenuByIdValidator,\r\n    getMenusValidator,\r\n    toggleMealAvailabilityValidator,\r\n    // Preorder validators\r\n    createPreorderValidator,\r\n    updatePreorderStatusValidator,\r\n    cancelPreorderValidator\r\n};\r\n"
              },
              {
                "type": "file",
                "name": "cart.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\cart.validator.js",
                "size": 283,
                "content": "const { body } = require(\"express-validator\");\r\n\r\nconst addToCartValidator = [\r\n    body('mealId')\r\n        .exists()\r\n        .withMessage('Meal ID is required')\r\n        .isInt()\r\n        .withMessage('Meal ID must be an integer'),\r\n];\r\n\r\nmodule.exports = { addToCartValidator };\r\n"
              },
              {
                "type": "file",
                "name": "club.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\club.validator.js",
                "size": 2602,
                "content": "const { body, param, query } = require('express-validator');\r\n\r\n// Validation for creating a club\r\nconst createClubValidation = [\r\n  body('name').notEmpty().withMessage('Club name is required'),\r\n  body('description').optional().isString().withMessage('Description must be a string'),\r\n  body('moderatorId').isInt().withMessage('Moderator ID must be an integer')\r\n  \r\n];\r\n\r\n// Validation for updating a club\r\nconst updateClubValidation = [\r\n  param('id').isInt().withMessage('Club ID must be an integer'),\r\n  body('name').optional().notEmpty().withMessage('Club name cannot be empty'),\r\n  body('description').optional().isString().withMessage('Description must be a string')\r\n];\r\n\r\n// Validation for following a club\r\nconst followClubValidation = [\r\n  param('clubId').isInt().withMessage('Club ID must be an integer')\r\n];\r\n\r\n// Validation for unfollowing a club\r\nconst unfollowClubValidation = [\r\n  param('clubId').isInt().withMessage('Club ID must be an integer')\r\n];\r\n\r\n// Validation for adding an album photo\r\nconst addAlbumPhotoValidation = [\r\n  param('clubId').isInt().withMessage('Club ID must be an integer')\r\n];\r\n\r\n// Validation for removing an album photo\r\nconst removeAlbumPhotoValidation = [\r\n  param('photoId').isInt().withMessage('Photo ID must be an integer')\r\n];\r\n\r\n// Validation for adding a user to a club\r\nconst addUserToClubValidation = [\r\n  body('userId').isInt().withMessage('User ID must be an integer'),\r\n  body('role').isString().withMessage('Role must be a string')\r\n];\r\n\r\n// Validation for changing a user's role in a club\r\nconst changeUserRoleValidation = [\r\n  param('userId').isInt().withMessage('User ID must be an integer'),\r\n  body('newRole').isString().withMessage('New role must be a string')\r\n];\r\n\r\nconst changeUserStatusValidation = [\r\n  param('userId').isInt().withMessage('User ID must be an integer'),\r\n  body('newStatus').isString().withMessage('New status must be a string')\r\n];\r\n\r\n// Validation for searching clubs\r\nconst searchClubsValidation = [\r\n  query('query').optional().isString().withMessage('Query must be a string'),\r\n  query('page').optional().isInt().withMessage('Page must be an integer'),\r\n  query('limit').optional().isInt().withMessage('Limit must be an integer'),\r\n  query('sort').optional().isString().withMessage('Sort must be a string')\r\n];\r\n\r\nmodule.exports = {\r\n  createClubValidation,\r\n  updateClubValidation,\r\n  followClubValidation,\r\n  unfollowClubValidation,\r\n  addAlbumPhotoValidation,\r\n  removeAlbumPhotoValidation,\r\n  addUserToClubValidation,\r\n  changeUserRoleValidation,\r\n  changeUserStatusValidation,\r\n  searchClubsValidation\r\n}; "
              },
              {
                "type": "file",
                "name": "event.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\event.validator.js",
                "size": 1197,
                "content": "const { param, query } = require('express-validator');\r\n\r\n// validation for following an event\r\nconst followEventValidation = [\r\n  param('eventId').isInt().withMessage('Event ID must be an integer')\r\n];\r\n\r\n// validation for unfollowing an event\r\nconst unfollowEventValidation = [\r\n  param('eventId').isInt().withMessage('Event ID must be an integer')\r\n];\r\n\r\n// Validation for fetching event info\r\nconst eventInfoValidation = [\r\n  param('eventId').isInt().withMessage('Event ID must be an integer')\r\n];\r\n\r\n// Validation for fetching event details\r\nconst eventDetailsValidation = [\r\n  param('eventId').isInt().withMessage('Event ID must be an integer')\r\n];\r\n\r\n// Validation for searching events\r\nconst searchEventsValidation = [\r\n  query('query').optional().isString().withMessage('Query must be a string'),\r\n  query('page').optional().isInt().withMessage('Page must be an integer'),\r\n  query('limit').optional().isInt().withMessage('Limit must be an integer'),\r\n  query('sort').optional().isString().withMessage('Sort must be a string')\r\n];\r\n\r\nmodule.exports = {\r\n  followEventValidation,\r\n  unfollowEventValidation,\r\n  eventInfoValidation,\r\n  eventDetailsValidation,\r\n  searchEventsValidation\r\n}; "
              },
              {
                "type": "file",
                "name": "order.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\order.validator.js",
                "size": 1178,
                "content": "const { body, param } = require('express-validator');\r\n\r\nconst orderValidator = [\r\n  body('items')\r\n    .isArray()\r\n    .withMessage('Items must be an array')\r\n    .notEmpty()\r\n    .withMessage('Items array cannot be empty'),\r\n  body('items.*.mealId')\r\n    .isInt()\r\n    .withMessage('Each item must have a valid meal ID'),\r\n  body('items.*.quantity')\r\n    .isInt({ min: 1 })\r\n    .withMessage('Each item must have a valid quantity')\r\n];\r\n\r\n\r\nconst orderStatusValidator = [\r\n  param('id')\r\n    .isInt()\r\n    .withMessage('Order ID must be an integer'),\r\n  body('status')\r\n    .isIn(['pending_approval', 'placed', 'ready', 'picked_up', 'cancelled'])\r\n    .withMessage('Invalid status value'),\r\n  body('rejectionReason')\r\n    .optional()\r\n    .isString()\r\n    .withMessage('Rejection reason must be a string'),\r\n  body('pickupTime')\r\n    .optional()\r\n    .isISO8601()\r\n    .withMessage('Pickup time must be a valid date-time string')\r\n];\r\n\r\n\r\nconst orderVerificationValidator = [\r\n  body('verificationData')\r\n    .notEmpty()\r\n    .withMessage('Verification data is required')\r\n];\r\n\r\nmodule.exports = { \r\n  orderValidator,\r\n  orderStatusValidator,\r\n  orderVerificationValidator\r\n};"
              },
              {
                "type": "file",
                "name": "routine.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\routine.validator.js",
                "size": 1440,
                "content": "const { body } = require('express-validator');\r\n\r\n// Validation for setting weekly schedule\r\nconst setWeeklyScheduleValidator = [\r\n  body('weekday').isString().notEmpty().withMessage('Weekday is required'),\r\n  body('period1').optional().isString(),\r\n  body('period2').optional().isString(),\r\n  body('period3').optional().isString(),\r\n  body('period4').optional().isString(),\r\n  body('period5').optional().isString(),\r\n  body('period6').optional().isString(),\r\n  body('period7').optional().isString(),\r\n  body('period8').optional().isString(),\r\n  body('period9').optional().isString(),\r\n];\r\n\r\n// Validation for adding a course (updated)\r\nconst addCourseValidator = [\r\n  body('courseId').isString().notEmpty().withMessage('Course ID is required'),\r\n  body('courseName').isString().notEmpty().withMessage('Course name is required'),\r\n  body('courseType').isString().isIn(['theory', 'lab']).withMessage('Course type must be either \"theory\" or \"lab\"'),\r\n];\r\n\r\n// Validation for adding/updating an exam\r\nconst examValidator = [\r\n  body('courseId').isString().notEmpty().withMessage('Course ID is required'),\r\n  body('examType').isString().isIn(['class-test', 'term-final', 'lab-test']).withMessage('Exam type must be valid'),\r\n  body('syllabus').optional().isString(),\r\n  body('examDate').isISO8601().withMessage('Valid exam date is required'),\r\n];\r\n\r\nmodule.exports = {\r\n  setWeeklyScheduleValidator,\r\n  addCourseValidator,\r\n  examValidator,\r\n};"
              },
              {
                "type": "file",
                "name": "schedule.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\schedule.validator.js",
                "size": 1,
                "content": " "
              },
              {
                "type": "file",
                "name": "user.validator.js",
                "path": "E:\\Work\\MIST_Hackathon\\server\\src\\middleware\\validators\\user.validator.js",
                "size": 1365,
                "content": "const { body } = require('express-validator');\r\n\r\n// Profile update validation\r\nconst profileUpdateValidator = [\r\n  body('name')\r\n    .isString()\r\n    .trim()\r\n    .notEmpty()\r\n    .withMessage('Name is required')\r\n    .isLength({ min: 2, max: 255 })\r\n    .withMessage('Name must be between 2 and 255 characters'),\r\n  \r\n  body('phone')\r\n    .optional()\r\n    .isString()\r\n    .trim()\r\n    .matches(/^\\+?[1-9]\\d{1,14}$/)\r\n    .withMessage('Invalid phone number format'),\r\n\r\n  body('bio')\r\n    .optional()\r\n    .isString()\r\n    .trim()\r\n    .isLength({ max: 1000 })\r\n    .withMessage('Bio cannot exceed 1000 characters')\r\n];\r\n\r\n// Password change validation\r\nconst passwordChangeValidator = [\r\n  body('currentPassword')\r\n    .notEmpty()\r\n    .withMessage('Current password is required')\r\n    .isLength({ min: 8 })\r\n    .withMessage('Current password must be at least 8 characters'),\r\n  \r\n  body('newPassword')\r\n    .notEmpty()\r\n    .withMessage('New password is required')\r\n    .isLength({ min: 8 })\r\n    .withMessage('New password must be at least 8 characters')\r\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+/)\r\n    .withMessage('New password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')\r\n];\r\n\r\nmodule.exports = {\r\n  profileUpdateValidator,\r\n  passwordChangeValidator\r\n}; "
              }
            ]
          }
        ]
      },
      {
        "type": "directory",
        "name": "routes",
        "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes",
        "children": [
          {
            "type": "file",
            "name": "ai-cafe-manager.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\ai-cafe-manager.routes.js",
            "size": 461,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst aiController = require('../controllers/ai-cafe-manager.controller');\r\nconst { auth } = require('../middleware/auth.middleware');\r\nconst { validateRole } = require('../middleware/role.middleware');\r\n\r\n// AI assistant for cafe managers\r\nrouter.post('/cafe-assistant', \r\n  auth, \r\n  validateRole(['CAFE_MANAGER']), \r\n  aiController.processCafeManagerQuery\r\n);\r\n\r\nmodule.exports = router;"
          },
          {
            "type": "file",
            "name": "assignment.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\assignment.routes.js",
            "size": 1018,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\n\r\n// Assignment Controller\r\nconst assignmentController = require('../controllers/assignment.controller');\r\n\r\n// Middleware\r\nconst { authenticate } = require('../middleware/auth.middleware');\r\nconst {\r\n  createAssignmentValidator,\r\n  updateAssignmentValidator,\r\n} = require('../middleware/validators/assignment.validator');\r\n\r\n// Protected routes\r\nrouter.post('/create', authenticate, createAssignmentValidator, assignmentController.createAssignment);\r\nrouter.get('/list', authenticate, assignmentController.getAssignments);\r\nrouter.get('/:id', authenticate, assignmentController.getAssignmentById);\r\nrouter.put('/:id', authenticate, updateAssignmentValidator, assignmentController.updateAssignment);\r\nrouter.delete('/:id', authenticate, assignmentController.deleteAssignment);\r\n// Add this new route to your existing assignment routes\r\nrouter.post('/notify-deadline', authenticate, assignmentController.notifyDeadline);\r\n\r\nmodule.exports = router;"
          },
          {
            "type": "file",
            "name": "auth.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\auth.routes.js",
            "size": 1572,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst authController = require('../controllers/auth.controller');\r\nconst { authenticate } = require('../middleware/auth.middleware');\r\nconst { authLimiter } = require('../middleware/rate-limit.middleware');\r\nconst {\r\n  registerEmployeeValidator,\r\n  registerStudentValidator,\r\n  registerFacultyValidator,\r\n  loginValidator,\r\n  requestPasswordResetValidator,\r\n  resetPasswordValidator\r\n} = require('../middleware/validators/auth.validator');\r\n\r\n// Public routes\r\nrouter.post('/register/employee', authLimiter, registerEmployeeValidator, authController.registerEmployee);\r\nrouter.post('/register/student', authLimiter, registerStudentValidator, authController.registerStudent);\r\nrouter.post('/register/faculty', authLimiter, registerFacultyValidator, authController.registerFaculty);\r\nrouter.post('/login', authLimiter, loginValidator, authController.login);\r\nrouter.get('/verify-email/:token', authController.verifyEmail);\r\nrouter.post('/refresh-token', authController.refreshToken);\r\nrouter.post('/forgot-password', authLimiter, requestPasswordResetValidator, authController.requestPasswordReset);\r\nrouter.post('/reset-password/:token', authLimiter, resetPasswordValidator, authController.resetPassword);\r\nrouter.post('/resend-verification', authLimiter, requestPasswordResetValidator, authController.resendVerification);\r\n\r\n\r\n// Protected routes\r\nrouter.post('/logout', authenticate, authController.logout);\r\nrouter.get('/me', authenticate, authController.getCurrentUser);\r\n\r\nmodule.exports = router; "
          },
          {
            "type": "file",
            "name": "bus.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\bus.routes.js",
            "size": 20964,
            "content": "const express = require('express');\r\nconst { PrismaClient } = require('@prisma/client');\r\nconst router = express.Router();\r\nconst prisma = new PrismaClient();\r\nconst busController = require('../controllers/bus.controller');\r\nconst {\r\n  createBusValidator,\r\n  updateBusValidator,\r\n  deleteBusValidator,\r\n  getBusByIdValidator,\r\n  getBusesValidator,\r\n} = require('../middleware/validators/bus.validator');\r\n\r\n// Get all buses\r\nrouter.get('/buses', getBusesValidator, busController.getBuses);\r\n\r\n// New endpoint to get a bus by its ID\r\nrouter.get('/buses/:id', getBusByIdValidator, busController.getBusById);\r\n\r\n// POST create a new bus\r\nrouter.post('/buses', createBusValidator, busController.createBus);\r\n\r\n// PUT update a bus\r\nrouter.put('/buses/:id', updateBusValidator, busController.updateBus);\r\n\r\n// DELETE a bus\r\nrouter.delete('/buses/:id', deleteBusValidator, busController.deleteBus);\r\n\r\n// Get all routes\r\nrouter.get('/routes', async (req, res) => {\r\n  try {\r\n    console.log('Getting all routes');\r\n    const routes = await prisma.busRoute.findMany({\r\n      include: {\r\n        bus: true,\r\n        stops: true,\r\n        schedules: true\r\n      },\r\n      orderBy: {\r\n        routeName: 'asc'\r\n      }\r\n    });\r\n    \r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Routes retrieved successfully',\r\n      data: routes\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching routes:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch routes',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n// New endpoint to get buses for a specific bus route\r\nrouter.get('/buses/route/:routeId', async (req, res) => {\r\n  const { routeId } = req.params;\r\n  try {\r\n    console.log(`Getting buses for route ID: ${routeId}`);\r\n    const buses = await prisma.bus.findMany({\r\n      where: {\r\n        routes: {\r\n          some: {\r\n            id: routeId,\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        busNumber: 'asc',\r\n      },\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: `Buses for route ID ${routeId} retrieved successfully`,\r\n      data: buses,\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching buses for route:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch buses for the route',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error,\r\n      },\r\n    });\r\n  }\r\n});\r\n\r\n// New endpoint to get schedules for a specific bus by its ID\r\nrouter.get('/buses/:busId/schedules', async (req, res) => {\r\n  const { busId } = req.params;\r\n  try {\r\n    console.log(`Getting schedules for bus ID: ${busId}`);\r\n    const schedules = await prisma.busSchedule.findMany({\r\n      where: {\r\n        busId: busId, // Filter schedules by bus ID\r\n      },\r\n      include: {\r\n        route: true, // Include related route information if needed\r\n      },\r\n      orderBy: {\r\n        departureTime: 'asc', // Order by departure time\r\n      },\r\n    });\r\n\r\n    if (schedules.length === 0) {\r\n      return res.status(404).json({\r\n        status: 404,\r\n        success: false,\r\n        message: `No schedules found for bus ID ${busId}`,\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: `Schedules for bus ID ${busId} retrieved successfully`,\r\n      data: schedules,\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching schedules:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch schedules',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error,\r\n      },\r\n    });\r\n  }\r\n});\r\n\r\n// New endpoint to get driver information for a specific route\r\nrouter.get('/routes/:routeId/drivers', async (req, res) => {\r\n  const { routeId } = req.params;\r\n  try {\r\n    console.log(`Getting driver information for route ID: ${routeId}`);\r\n    \r\n    // Fetch the route along with the driver information\r\n    const routeWithDriver = await prisma.busSchedule.findMany({\r\n      where: {\r\n        routeId: routeId,\r\n      },\r\n      include: {\r\n        driver: true, // Assuming there's a relation to the Driver model\r\n      },\r\n    });\r\n\r\n    if (!routeWithDriver || routeWithDriver.length === 0) {\r\n      return res.status(404).json({\r\n        status: 404,\r\n        success: false,\r\n        message: `No drivers found for route ID ${routeId}`,\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: `Driver information for route ID ${routeId} retrieved successfully`,\r\n      data: routeWithDriver.map(schedule => ({\r\n        driverId: schedule.driverId,\r\n        driverName: schedule.driver.name, // Assuming the driver's name is stored in the Driver model\r\n        driverContact: schedule.driver.contact, // Assuming there's a contact field\r\n        // Add any other driver fields you want to include\r\n      })),\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching driver information:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch driver information',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error,\r\n      },\r\n    });\r\n  }\r\n});\r\n\r\n// New endpoint to get driver information for a specific schedule\r\nrouter.get('/schedules/:scheduleId/driver', async (req, res) => {\r\n  const { scheduleId } = req.params;\r\n  try {\r\n    console.log(`Getting driver information for schedule ID: ${scheduleId}`);\r\n    \r\n    // Fetch the schedule along with the driver ID\r\n    const schedule = await prisma.busSchedule.findUnique({\r\n      where: {\r\n        id: scheduleId,\r\n      },\r\n      select: {\r\n        driverId: true, // Only select the driverId\r\n      },\r\n    });\r\n\r\n    if (!schedule) {\r\n      return res.status(404).json({\r\n        status: 404,\r\n        success: false,\r\n        message: `No schedule found for ID ${scheduleId}`,\r\n      });\r\n    }\r\n\r\n    // Fetch the driver information using the driverId\r\n    const driver = await prisma.driver.findUnique({\r\n      where: {\r\n        id: schedule.driverId,\r\n      },\r\n    });\r\n\r\n    if (!driver) {\r\n      return res.status(404).json({\r\n        status: 404,\r\n        success: false,\r\n        message: `No driver found for ID ${schedule.driverId}`,\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: `Driver information for schedule ID ${scheduleId} retrieved successfully`,\r\n      data: {\r\n        driverId: driver.id,\r\n        driverName: `${driver.firstName} ${driver.lastName}`, // Combine first and last name\r\n        driverContact: driver.phone, // Assuming there's a phone field\r\n        // Add any other driver fields you want to include\r\n      },\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching driver information:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch driver information',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error,\r\n      },\r\n    });\r\n  }\r\n});\r\n\r\n// New route to get bus stops for a specific route\r\nrouter.get('/routes/:routeId/stops', async (req, res) => {\r\n  const { routeId } = req.params;\r\n\r\n  try {\r\n    const busStops = await prisma.busStop.findMany({\r\n      where: {\r\n        routeId: routeId, // Assuming you have a routeId field in your busStop model\r\n      },\r\n    });\r\n\r\n    if (!busStops || busStops.length === 0) {\r\n      return res.status(404).json({ message: 'No bus stops found for this route.' });\r\n    }\r\n\r\n    return res.status(200).json({ data: busStops });\r\n  } catch (error) {\r\n    console.error(\"Error fetching bus stops:\", error);\r\n    return res.status(500).json({ message: 'Internal server error' });\r\n  }\r\n});\r\n\r\n// New endpoint to get all schedules\r\nrouter.get('/schedules', async (req, res) => {\r\n  try {\r\n    const schedules = await prisma.busSchedule.findMany({\r\n      include: {\r\n        bus: true, // Include bus details if needed\r\n        driver: true, // Include driver details if needed\r\n      },\r\n    });\r\n\r\n    if (!schedules || schedules.length === 0) {\r\n      return res.status(404).json({ message: 'No schedules found.' });\r\n    }\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Schedules retrieved successfully',\r\n      data: schedules,\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching schedules:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch schedules',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error,\r\n      },\r\n    });\r\n  }\r\n});\r\n\r\n// New endpoint to get a specific route by ID\r\nrouter.get('/routes/:id', async (req, res) => {\r\n  const { id } = req.params; // Get the route ID from the request parameters\r\n  try {\r\n    const route = await prisma.busRoute.findUnique({\r\n      where: { id: id }, // Query for the route with the specified ID\r\n      include: {\r\n        // Include any related data if necessary\r\n        bus: true,\r\n        stops: true,\r\n        schedules: true,\r\n      },\r\n    });\r\n\r\n    if (!route) {\r\n      return res.status(404).json({ message: 'Route not found.' });\r\n    }\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Route retrieved successfully',\r\n      data: route,\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching route:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch route',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error,\r\n      },\r\n    });\r\n  }\r\n});\r\n\r\n// POST create a new driver\r\nrouter.post('/drivers', busController.createDriver);\r\n\r\n// PUT update a driver\r\nrouter.put('/drivers/:id', busController.updateDriver);\r\n\r\n// DELETE a driver\r\nrouter.delete('/drivers/:id', busController.deleteDriver);\r\n\r\n// New endpoint to get all drivers\r\nrouter.get('/drivers', busController.getDrivers);\r\n\r\n// Route Management Endpoints\r\n\r\n// Create a new route\r\nrouter.post('/routes', async (req, res) => {\r\n  try {\r\n    const {\r\n      routeName,\r\n      routeCode,\r\n      startPoint,\r\n      endPoint,\r\n      distance,\r\n      duration,\r\n      direction,\r\n      isActive,\r\n      busId\r\n    } = req.body;\r\n\r\n    const route = await prisma.busRoute.create({\r\n      data: {\r\n        routeName,\r\n        routeCode,\r\n        startPoint,\r\n        endPoint,\r\n        distance: parseFloat(distance),\r\n        duration: parseInt(duration),\r\n        direction,\r\n        isActive,\r\n        busId\r\n      },\r\n      include: {\r\n        bus: true,\r\n        stops: true,\r\n        schedules: true\r\n      }\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Route created successfully',\r\n      data: route\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating route:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to create route',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n// Update a route\r\nrouter.put('/routes/:id', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const {\r\n      routeName,\r\n      routeCode,\r\n      startPoint,\r\n      endPoint,\r\n      distance,\r\n      duration,\r\n      direction,\r\n      isActive,\r\n      busId\r\n    } = req.body;\r\n\r\n    const route = await prisma.busRoute.update({\r\n      where: { id },\r\n      data: {\r\n        routeName,\r\n        routeCode,\r\n        startPoint,\r\n        endPoint,\r\n        distance: parseFloat(distance),\r\n        duration: parseInt(duration),\r\n        direction,\r\n        isActive,\r\n        busId\r\n      },\r\n      include: {\r\n        bus: true,\r\n        stops: true,\r\n        schedules: true\r\n      }\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Route updated successfully',\r\n      data: route\r\n    });\r\n  } catch (error) {\r\n    console.error('Error updating route:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to update route',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n// Delete a route\r\nrouter.delete('/routes/:id', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    // First delete all associated stops and schedules\r\n    await prisma.busStop.deleteMany({\r\n      where: { routeId: id }\r\n    });\r\n\r\n    await prisma.busSchedule.deleteMany({\r\n      where: { routeId: id }\r\n    });\r\n\r\n    // Then delete the route\r\n    await prisma.busRoute.delete({\r\n      where: { id }\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Route and associated data deleted successfully'\r\n    });\r\n  } catch (error) {\r\n    console.error('Error deleting route:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to delete route',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n// Get all routes with related data\r\nrouter.get('/routes', async (req, res) => {\r\n  try {\r\n    const routes = await prisma.busRoute.findMany({\r\n      include: {\r\n        bus: true,\r\n        stops: {\r\n          orderBy: {\r\n            sequence: 'asc'\r\n          }\r\n        },\r\n        schedules: {\r\n          include: {\r\n            driver: true\r\n          }\r\n        }\r\n      },\r\n      orderBy: {\r\n        routeName: 'asc'\r\n      }\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Routes retrieved successfully',\r\n      data: routes\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching routes:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch routes',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n// Schedule Management Endpoints\r\n\r\n// Create a new schedule\r\nrouter.post('/schedules', async (req, res) => {\r\n  try {\r\n    const {\r\n      busId,\r\n      routeId,\r\n      driverId,\r\n      departureTime,\r\n      arrivalTime,\r\n      isRecurring,\r\n      frequency,\r\n      status,\r\n      totalCapacity,\r\n      availableSeats\r\n    } = req.body;\r\n\r\n    const schedule = await prisma.busSchedule.create({\r\n      data: {\r\n        busId,\r\n        routeId,\r\n        driverId,\r\n        departureTime,\r\n        arrivalTime,\r\n        isRecurring,\r\n        frequency,\r\n        status,\r\n        totalCapacity: parseInt(totalCapacity),\r\n        availableSeats: parseInt(availableSeats),\r\n        bookedSeats: 0\r\n      },\r\n      include: {\r\n        bus: true,\r\n        route: true,\r\n        driver: true\r\n      }\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Schedule created successfully',\r\n      data: schedule\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating schedule:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to create schedule',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n// Update a schedule\r\nrouter.put('/schedules/:id', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const {\r\n      busId,\r\n      routeId,\r\n      driverId,\r\n      departureTime,\r\n      arrivalTime,\r\n      isRecurring,\r\n      frequency,\r\n      status,\r\n      totalCapacity,\r\n      availableSeats\r\n    } = req.body;\r\n\r\n    const schedule = await prisma.busSchedule.update({\r\n      where: { id },\r\n      data: {\r\n        busId,\r\n        routeId,\r\n        driverId,\r\n        departureTime,\r\n        arrivalTime,\r\n        isRecurring,\r\n        frequency,\r\n        status,\r\n        totalCapacity: parseInt(totalCapacity),\r\n        availableSeats: parseInt(availableSeats)\r\n      },\r\n      include: {\r\n        bus: true,\r\n        route: true,\r\n        driver: true\r\n      }\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Schedule updated successfully',\r\n      data: schedule\r\n    });\r\n  } catch (error) {\r\n    console.error('Error updating schedule:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to update schedule',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n// Delete a schedule\r\nrouter.delete('/schedules/:id', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    // Delete any associated reminders first\r\n    await prisma.reminder.deleteMany({\r\n      where: { scheduleId: id }\r\n    });\r\n\r\n    // Then delete the schedule\r\n    await prisma.busSchedule.delete({\r\n      where: { id }\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Schedule and associated data deleted successfully'\r\n    });\r\n  } catch (error) {\r\n    console.error('Error deleting schedule:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to delete schedule',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n// Get all schedules with related data\r\nrouter.get('/schedules', async (req, res) => {\r\n  try {\r\n    const schedules = await prisma.busSchedule.findMany({\r\n      include: {\r\n        bus: true,\r\n        route: true,\r\n        driver: true\r\n      },\r\n      orderBy: {\r\n        departureTime: 'asc'\r\n      }\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Schedules retrieved successfully',\r\n      data: schedules\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching schedules:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch schedules',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n// Get schedules by route\r\nrouter.get('/routes/:routeId/schedules', async (req, res) => {\r\n  try {\r\n    const { routeId } = req.params;\r\n    const schedules = await prisma.busSchedule.findMany({\r\n      where: {\r\n        routeId\r\n      },\r\n      include: {\r\n        bus: true,\r\n        driver: true\r\n      },\r\n      orderBy: {\r\n        departureTime: 'asc'\r\n      }\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: `Schedules for route ${routeId} retrieved successfully`,\r\n      data: schedules\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching schedules for route:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch schedules for route',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n// Get active schedules for today\r\nrouter.get('/schedules/today', async (req, res) => {\r\n  try {\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n    \r\n    const tomorrow = new Date(today);\r\n    tomorrow.setDate(tomorrow.getDate() + 1);\r\n\r\n    const schedules = await prisma.busSchedule.findMany({\r\n      where: {\r\n        OR: [\r\n          {\r\n            // One-time schedules for today\r\n            isRecurring: false,\r\n            validFrom: {\r\n              gte: today,\r\n              lt: tomorrow\r\n            }\r\n          },\r\n          {\r\n            // Recurring schedules that are valid today\r\n            isRecurring: true,\r\n            validFrom: {\r\n              lte: today\r\n            },\r\n            OR: [\r\n              {\r\n                validUntil: null\r\n              },\r\n              {\r\n                validUntil: {\r\n                  gte: today\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        ],\r\n        status: {\r\n          in: ['SCHEDULED', 'PENDING', 'DELAYED']\r\n        }\r\n      },\r\n      include: {\r\n        bus: true,\r\n        route: true,\r\n        driver: true\r\n      },\r\n      orderBy: {\r\n        departureTime: 'asc'\r\n      }\r\n    });\r\n\r\n    res.json({\r\n      status: 200,\r\n      success: true,\r\n      message: 'Today\\'s schedules retrieved successfully',\r\n      data: schedules\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching today\\'s schedules:', error);\r\n    res.status(500).json({\r\n      status: 500,\r\n      success: false,\r\n      message: 'Failed to fetch today\\'s schedules',\r\n      error: {\r\n        message: error.message,\r\n        code: 500,\r\n        details: error\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\nmodule.exports = router;\r\n"
          },
          {
            "type": "file",
            "name": "cafeteria.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\cafeteria.routes.js",
            "size": 2707,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\n\r\n// Import controller methods\r\nconst cafeteriaController = require('../controllers/cafeteria.controller');\r\n\r\n\r\n// Import validators\r\nconst {\r\n  createMealValidator,\r\n  updateMealValidator,\r\n  deleteMealValidator,\r\n  getMealByIdValidator,\r\n  createMenuValidator,\r\n  updateMenuValidator,\r\n  deleteMenuValidator,\r\n  getMenuByIdValidator,\r\n  getMenusValidator,\r\n  toggleMealAvailabilityValidator,\r\n  createPreorderValidator,\r\n  updatePreorderStatusValidator,\r\n  cancelPreorderValidator\r\n} = require('../middleware/validators/cafeteria.validator');\r\n\r\n/* ---------------------- Meals Routes ---------------------- */\r\n// GET all meals\r\nrouter.get('/meals', cafeteriaController.getMeals);\r\n\r\n// GET meal by ID\r\nrouter.get('/meals/:id', getMealByIdValidator, cafeteriaController.getMealById);\r\n\r\n// POST create a new meal\r\nrouter.post('/meals', createMealValidator, cafeteriaController.createMeal);\r\n\r\n// PUT update a meal\r\nrouter.put('/meals/:id', updateMealValidator, cafeteriaController.updateMeal);\r\n\r\n// DELETE a meal\r\nrouter.delete('/meals/:id', deleteMealValidator, cafeteriaController.deleteMeal);\r\n\r\n/* ---------------------- Menus Routes ---------------------- */\r\n// GET all menus (optionally filtered by date using a query param)\r\nrouter.get('/menus', getMenusValidator, cafeteriaController.getMenus);\r\n\r\n// GET today's menu\r\nrouter.get('/menus/today', cafeteriaController.getTodayMenu);\r\n\r\n// GET menu by ID\r\nrouter.get('/menus/:id', getMenuByIdValidator, cafeteriaController.getMenuById);\r\n\r\n// POST create a new menu\r\nrouter.post('/menus', createMenuValidator, cafeteriaController.createMenu);\r\n\r\n// PUT update a menu\r\nrouter.put('/menus/:id', updateMenuValidator, cafeteriaController.updateMenu);\r\n\r\n// DELETE a menu\r\nrouter.delete('/menus/:id', deleteMenuValidator, cafeteriaController.deleteMenu);\r\n\r\n// PUT toggle meal availability in a menu\r\nrouter.put('/menus/meal/:id/toggle-availability', toggleMealAvailabilityValidator, cafeteriaController.toggleMealAvailability);\r\n\r\n/* ---------------------- Preorders Routes ---------------------- */\r\n// POST create a preorder (make sure to secure this route if authentication is required)\r\nrouter.post('/preorders', createPreorderValidator, cafeteriaController.createPreorder);\r\n\r\n// GET user preorders\r\nrouter.get('/preorders', cafeteriaController.getUserPreorders);\r\n\r\n// PUT update preorder status (admin only)\r\nrouter.put('/preorders/:id/status', updatePreorderStatusValidator, cafeteriaController.updatePreorderStatus);\r\n\r\n// DELETE cancel a preorder\r\nrouter.delete('/preorders/:id', cancelPreorderValidator, cafeteriaController.cancelPreorder);\r\n\r\nmodule.exports = router;"
          },
          {
            "type": "file",
            "name": "cart.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\cart.routes.js",
            "size": 685,
            "content": "const express = require(\"express\");\r\nconst router = express.Router();\r\nconst cartController = require(\"../controllers/cart.controller\");\r\nconst { addToCartValidator } = require('../middleware/validators/cart.validator');\r\nconst { authenticate } = require(\"../middleware/auth.middleware\");\r\n\r\n//get cart\r\nrouter.get(\"/\", authenticate, cartController.getCart);\r\n//add to cart\r\nrouter.post(\"/add\", authenticate, addToCartValidator, cartController.addToCart);\r\n//remove from cart\r\nrouter.delete(\"/item/:id\", authenticate, cartController.removeFromCart);\r\n//update cart item quantity\r\nrouter.put(\"/item/:id\", authenticate, cartController.updateCartItemQuantity);\r\nmodule.exports = router;\r\n"
          },
          {
            "type": "file",
            "name": "club.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\club.routes.js",
            "size": 2880,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst clubController = require('../controllers/club.controller');\r\nconst { authenticate, authorizeAdmin, authorizeModeratorOrManager } = require('../middleware/auth.middleware');\r\nconst { \r\n  createClubValidation,\r\n  updateClubValidation,\r\n  followClubValidation,\r\n  unfollowClubValidation,\r\n  addAlbumPhotoValidation,\r\n  removeAlbumPhotoValidation,\r\n  addUserToClubValidation,\r\n  changeUserRoleValidation,\r\n  changeUserStatusValidation,\r\n  searchClubsValidation\r\n} = require('../middleware/validators/club.validator');\r\n\r\n// Create a new club\r\nrouter.post('/', authorizeAdmin, createClubValidation, clubController.createClub);\r\n\r\n// Update an existing club\r\nrouter.put('/:id', authorizeModeratorOrManager, updateClubValidation, clubController.updateClub);\r\n\r\n// Delete a club\r\nrouter.delete('/:id', authorizeAdmin, clubController.deleteClub);\r\n\r\n// Follow a club\r\nrouter.post('/:clubId/follow', followClubValidation, clubController.followClub);\r\n\r\n// Unfollow a club\r\nrouter.delete('/:clubId/unfollow', unfollowClubValidation, clubController.unfollowClub);\r\n\r\n// Add album photo\r\nrouter.post('/:clubId/album', addAlbumPhotoValidation, clubController.addAlbumPhoto);\r\n\r\n// Remove album photo\r\nrouter.delete('/album/:photoId', removeAlbumPhotoValidation, clubController.removeAlbumPhoto);\r\n\r\n// Add a user to a club\r\nrouter.post('/:clubId/users', authorizeModeratorOrManager, addUserToClubValidation, clubController.addUserToClub);\r\n\r\n// Remove a user from a club\r\nrouter.delete('/:clubId/users/:userId', authorizeModeratorOrManager, clubController.removeUserFromClub);\r\n\r\n// Change a user's role in a club\r\nrouter.put('/:clubId/users/:userId/role', authorizeModeratorOrManager, changeUserRoleValidation, clubController.changeUserRoleInClub);\r\n\r\n// Change a user's status in a club\r\nrouter.put('/:clubId/users/:userId/status', authorizeModeratorOrManager, changeUserStatusValidation, clubController.changeUserStatusInClub);\r\n\r\n// Get concise info of a club\r\nrouter.get('/:clubId/info', clubController.getClubInfo);\r\n\r\n// Get detailed info of a club\r\nrouter.get('/:clubId/details', clubController.getClubDetails);\r\n\r\n// Get events of a club with pagination and filtering\r\nrouter.get('/:clubId/events', clubController.getClubEvents);\r\n\r\n// Get analytics data for a club\r\nrouter.get('/:clubId/analytics', authenticate, authorizeModeratorOrManager, clubController.getClubAnalytics);\r\n\r\n// Log a user's visit to a club page\r\nrouter.post('/:clubId/visit', clubController.logUserVisit);\r\n\r\n// Search for clubs\r\nrouter.get('/search', searchClubsValidation, clubController.searchClubs);\r\n\r\n// Get short details of a club\r\nrouter.get('/:clubId/short', clubController.getClubShortDetails);\r\n\r\n// Get paginated and sortable list of clubs\r\nrouter.get('/list', clubController.getPaginatedClubs);\r\n\r\nmodule.exports = router; "
          },
          {
            "type": "file",
            "name": "department.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\department.routes.js",
            "size": 267,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst departmentController = require('../controllers/department.controller');\r\n\r\n// Route to get all departments\r\nrouter.get('/', departmentController.getDepartments);\r\n\r\nmodule.exports = router; "
          },
          {
            "type": "file",
            "name": "event.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\event.routes.js",
            "size": 1792,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst { authenticate } = require('../middleware/auth.middleware');\r\nconst eventController = require('../controllers/event.controller');\r\nconst { authorizeModeratorOrManager } = require('../middleware/auth.middleware');\r\nconst { followEventValidation, unfollowEventValidation, eventInfoValidation, eventDetailsValidation, searchEventsValidation } = require('../middleware/validators/event.validator');\r\n\r\n// Create a new event\r\nrouter.post('/', authenticate, eventController.createEvent);\r\n\r\n// Update an existing event\r\nrouter.put('/:id', authenticate, eventController.updateEvent);\r\n\r\n// Follow an event\r\nrouter.post('/:eventId/follow', authenticate, followEventValidation, eventController.followEvent);\r\n\r\n// Unfollow an event\r\nrouter.delete('/:eventId/unfollow', authenticate, unfollowEventValidation, eventController.unfollowEvent);\r\n\r\n// Log a user's visit to an event page\r\nrouter.post('/:eventId/visit', authenticate, eventController.logUserVisit);\r\n\r\n// Get concise info of an event\r\nrouter.get('/:eventId/info', authenticate, eventInfoValidation, eventController.getEventInfo);\r\n\r\n// Get detailed info of an event\r\nrouter.get('/:eventId/details', authenticate, eventDetailsValidation, eventController.getEventDetails);\r\n\r\n// Get analytics data for an event\r\nrouter.get('/:eventId/analytics', authenticate, authorizeModeratorOrManager, eventController.getEventAnalytics);\r\n\r\n// Search for events\r\nrouter.get('/search', searchEventsValidation, eventController.searchEvents);\r\n\r\n// Get short details of an event\r\nrouter.get('/:eventId/short', eventController.getEventShortDetails);\r\n\r\n// Get paginated and sortable list of events\r\nrouter.get('/list', eventController.getPaginatedEvents);\r\n\r\nmodule.exports = router;"
          },
          {
            "type": "file",
            "name": "index.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\index.js",
            "size": 1893,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\n\r\nconst { standardLimiter } = require('../middleware/rate-limit.middleware');\r\n\r\nconst authRoutes = require('./auth.routes');\r\nconst cafeteriaRoutes = require('./cafeteria.routes');\r\nconst routineRoutes = require('./routine.routes');\r\nconst assignmentRoutes = require('./assignment.routes');\r\nconst userRoutes = require('./user.routes');\r\nconst notificationRoutes = require('./notification.routes');\r\nconst storageRoutes = require('./storage.routes');\r\nconst departmentRoutes = require('./department.routes');\r\nconst eventRoutes = require('./event.routes');\r\nconst clubRoutes = require('./club.routes');\r\nconst cartRoutes = require('./cart.routes');\r\nconst orderRoutes = require('./order.routes');\r\nconst busRoutes = require('./bus.routes');\r\n\r\n// Apply standard rate limit to all routes\r\nrouter.use(standardLimiter);\r\n\r\n// Health check route\r\nrouter.get('/health', (req, res) => {\r\n  res.status(200).json({\r\n    status: 'success',\r\n    message: 'Server is running',\r\n    timestamp: new Date().toISOString()\r\n  });\r\n});\r\n\r\n// Mount route modules\r\nrouter.use('/auth', authRoutes);\r\nrouter.use('/cafeteria', cafeteriaRoutes);\r\nrouter.use('/users', userRoutes);\r\nrouter.use('/notifications', notificationRoutes);\r\nrouter.use('/storage', storageRoutes);\r\nrouter.use('/cart', cartRoutes);\r\nrouter.use('/order', orderRoutes);\r\nrouter.use('/departments', departmentRoutes);\r\nrouter.use('/routine', routineRoutes);\r\nrouter.use('/bus', busRoutes);  // This will make the routes available at /api/v1/bus/*\r\nrouter.use('/events', eventRoutes);\r\nrouter.use('/clubs', clubRoutes);\r\nrouter.use('/assignments', assignmentRoutes);\r\n\r\n// Catch-all 404 handler\r\nrouter.use('*', (req, res) => {\r\n  res.status(404).json({\r\n    status: 'error',\r\n    message: `Cannot ${req.method} ${req.originalUrl}`\r\n  });\r\n});\r\n\r\nmodule.exports = router; \r\n"
          },
          {
            "type": "file",
            "name": "notification.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\notification.routes.js",
            "size": 5764,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst { authenticate, authorize } = require('../middleware/auth.middleware');\r\nconst notificationService = require('../services/notification.service');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\n// Get user's notifications with pagination\r\nrouter.get('/', authenticate, async (req, res) => {\r\n  try {\r\n    const { page = 1, limit = 10, unreadOnly = false } = req.query;\r\n    const result = await notificationService.getUserNotifications(req.user.id, {\r\n      page: parseInt(page),\r\n      limit: parseInt(limit),\r\n      unreadOnly: unreadOnly === 'true'\r\n    });\r\n    res.json(result);\r\n  } catch (error) {\r\n    logger.error('Failed to get notifications:', error);\r\n    res.status(500).json({ message: 'Failed to get notifications' });\r\n  }\r\n});\r\n\r\n// Delete a notification\r\nrouter.delete('/:id', authenticate, async (req, res) => {\r\n  try {\r\n    await notificationService.deleteNotification(req.user.id, req.params.id);\r\n    res.json({ message: 'Notification deleted successfully' });\r\n  } catch (error) {\r\n    logger.error('Failed to delete notification:', error);\r\n    res.status(500).json({ message: 'Failed to delete notification' });\r\n  }\r\n});\r\n\r\n// Get unread notifications count\r\nrouter.get('/unread/count', authenticate, async (req, res) => {\r\n  try {\r\n    const count = await notificationService.getUnreadCount(req.user.id);\r\n    res.json({ count });\r\n  } catch (error) {\r\n    logger.error('Failed to get unread count:', error);\r\n    res.status(500).json({ message: 'Failed to get unread count' });\r\n  }\r\n});\r\n\r\n// Mark a notification as read\r\nrouter.patch('/:id/read', authenticate, async (req, res) => {\r\n  try {\r\n    await notificationService.markAsRead(req.user.id, req.params.id);\r\n    res.json({ message: 'Notification marked as read' });\r\n  } catch (error) {\r\n    logger.error('Failed to mark notification as read:', error);\r\n    res.status(500).json({ message: 'Failed to mark notification as read' });\r\n  }\r\n});\r\n\r\n// Mark all notifications as read\r\nrouter.patch('/read/all', authenticate, async (req, res) => {\r\n  try {\r\n    await notificationService.markAllAsRead(req.user.id);\r\n    res.json({ message: 'All notifications marked as read' });\r\n  } catch (error) {\r\n    logger.error('Failed to mark all notifications as read:', error);\r\n    res.status(500).json({ message: 'Failed to mark all notifications as read' });\r\n  }\r\n});\r\n\r\n// Create notification (Admin only)\r\nrouter.post('/', authenticate, authorize(['ADMIN']), async (req, res) => {\r\n  try {\r\n    const { userId, title, message, type, metadata } = req.body;\r\n    const notification = await notificationService.createNotification({\r\n      userId,\r\n      title,\r\n      message,\r\n      type,\r\n      metadata\r\n    });\r\n    res.status(201).json(notification);\r\n  } catch (error) {\r\n    logger.error('Failed to create notification:', error);\r\n    res.status(500).json({ message: 'Failed to create notification' });\r\n  }\r\n});\r\n\r\n// Broadcast to roles (Admin only)\r\nrouter.post('/broadcast', authenticate, authorize(['ADMIN']), async (req, res) => {\r\n  try {\r\n    const { roles, title, message, type, metadata } = req.body;\r\n    const notifications = await notificationService.broadcastToRoles(roles, {\r\n      title,\r\n      message,\r\n      type,\r\n      metadata\r\n    });\r\n    res.status(201).json(notifications);\r\n  } catch (error) {\r\n    logger.error('Failed to broadcast notification:', error);\r\n    res.status(500).json({ message: 'Failed to broadcast notification' });\r\n  }\r\n});\r\n\r\n// Test notification endpoint\r\nrouter.post('/test', authenticate, async (req, res) => {\r\n  try {\r\n    const { title, message, type } = req.body;\r\n    const notification = await notificationService.createNotification({\r\n      userId: req.user.id,\r\n      title,\r\n      message,\r\n      type,\r\n      metadata: {\r\n        source: 'test'\r\n      }\r\n    });\r\n    res.json(notification);\r\n  } catch (error) {\r\n    console.error('Error in test notification:', error);\r\n    res.status(500).json({ error: 'Failed to send test notification' });\r\n  }\r\n});\r\n\r\n// Test endpoint for sending channel notifications\r\nrouter.post('/test/channel', authenticate, async (req, res) => {\r\n  try {\r\n    const { channelName, title, message, type } = req.body;\r\n    \r\n    // First subscribe the user to the channel if not already subscribed\r\n    await notificationService.subscribeToChannel(req.user.id, channelName);\r\n    \r\n    // Then broadcast to the channel\r\n    const notifications = await notificationService.broadcastToChannel(channelName, {\r\n      title,\r\n      message,\r\n      type,\r\n      metadata: {\r\n        source: 'test',\r\n        channel: channelName\r\n      }\r\n    });\r\n    \r\n    res.json(notifications);\r\n  } catch (error) {\r\n    console.error('Error in channel notification:', error);\r\n    res.status(500).json({ error: 'Failed to send channel notification' });\r\n  }\r\n});\r\n\r\n// Subscribe to a channel\r\nrouter.post('/channels/:channelName/subscribe', authenticate, async (req, res) => {\r\n  try {\r\n    await notificationService.subscribeToChannel(req.user.id, req.params.channelName);\r\n    res.json({ success: true });\r\n  } catch (error) {\r\n    console.error('Error subscribing to channel:', error);\r\n    res.status(500).json({ error: 'Failed to subscribe to channel' });\r\n  }\r\n});\r\n\r\n// Unsubscribe from a channel\r\nrouter.post('/channels/:channelName/unsubscribe', authenticate, async (req, res) => {\r\n  try {\r\n    await notificationService.unsubscribeFromChannel(req.user.id, req.params.channelName);\r\n    res.json({ success: true });\r\n  } catch (error) {\r\n    console.error('Error unsubscribing from channel:', error);\r\n    res.status(500).json({ error: 'Failed to unsubscribe from channel' });\r\n  }\r\n});\r\n\r\nmodule.exports = router; "
          },
          {
            "type": "file",
            "name": "order.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\order.routes.js",
            "size": 820,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst orderController = require('../controllers/order.controller');\r\nconst { orderValidator } = require('../middleware/validators/order.validator');\r\nconst { authenticate, authorize } = require('../middleware/auth.middleware');\r\n\r\nrouter.post('/', authenticate, orderValidator, orderController.createOrder);\r\nrouter.get('/', authenticate, orderController.getOrders);\r\n\r\n// New and modified routes for CAFE_MANAGER\r\nrouter.get('/manage', authenticate, authorize('CAFE_MANAGER'), orderController.getOrdersForManagement);\r\nrouter.put('/:id/status', authenticate, authorize(['CAFE_MANAGER']), orderController.updateOrderStatus);\r\nrouter.post('/verify', authenticate, authorize(['CAFE_MANAGER']), orderController.verifyOrder);\r\n\r\nmodule.exports = router;"
          },
          {
            "type": "file",
            "name": "routine.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\routine.routes.js",
            "size": 1294,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\n\r\n// Routine Controller\r\nconst routineController = require('../controllers/routine.controller');\r\n\r\n// Middleware\r\nconst { authenticate } = require('../middleware/auth.middleware');\r\nconst {\r\n  setWeeklyScheduleValidator,\r\n  addCourseValidator,\r\n  examValidator,\r\n} = require('../middleware/validators/routine.validator');\r\n\r\n// Protected routes\r\n\r\nrouter.post('/set-schedule', authenticate, setWeeklyScheduleValidator, routineController.setWeeklySchedule);\r\nrouter.post('/add-course', authenticate, addCourseValidator, routineController.addCourse);\r\nrouter.get('/get-schedule', authenticate, routineController.getWeeklySchedule);\r\nrouter.get('/get-courses', authenticate, routineController.getCourses);\r\n\r\n// Exam routes\r\nrouter.post('/add-exam', authenticate, examValidator, routineController.addExam);\r\nrouter.put('/update-exam/:id', authenticate, examValidator, routineController.updateExam);\r\nrouter.delete('/delete-exam/:id', authenticate, routineController.deleteExam);\r\nrouter.get('/get-exams', authenticate, routineController.getExams);\r\n\r\n// In routine.routes.js, add a test route\r\nrouter.get('/test-routine', (req, res) => {\r\n    res.json({ message: 'Routine routes working!' });\r\n  });\r\nmodule.exports = router;"
          },
          {
            "type": "file",
            "name": "storage.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\storage.routes.js",
            "size": 3269,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst multer = require('multer');\r\nconst { authenticate, authorize } = require('../middleware/auth.middleware');\r\nconst storageService = require('../services/storage.service');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\n// Configure multer for memory storage\r\nconst upload = multer({\r\n  storage: multer.memoryStorage(),\r\n  limits: {\r\n    fileSize: 20 * 1024 * 1024 // 20MB max file size\r\n  }\r\n});\r\n\r\n// Upload a file\r\nrouter.post('/upload', \r\n  authenticate, \r\n  upload.single('file'),\r\n  async (req, res) => {\r\n    try {\r\n      const { \r\n        folder = '', \r\n        isPrivate = false, \r\n        category = 'default',\r\n        shareWith = [] \r\n      } = req.body;\r\n\r\n      const file = await storageService.uploadFile(req.file, {\r\n        folder,\r\n        isPrivate: isPrivate === 'true',\r\n        category,\r\n        userId: req.user.id,\r\n        shareWithUsers: shareWith\r\n      });\r\n\r\n      res.status(201).json(file);\r\n    } catch (error) {\r\n      logger.error('File upload failed:', error);\r\n      res.status(400).json({ message: error.message });\r\n    }\r\n  }\r\n);\r\n\r\n// Share a file with users\r\nrouter.post('/:fileKey/share',\r\n  authenticate,\r\n  async (req, res) => {\r\n    try {\r\n      const { fileKey } = req.params;\r\n      const { userIds } = req.body;\r\n\r\n      if (!Array.isArray(userIds) || userIds.length === 0) {\r\n        return res.status(400).json({ message: 'Invalid userIds provided' });\r\n      }\r\n\r\n      await storageService.shareFile(fileKey, userIds, req.user.id);\r\n      res.json({ message: 'File shared successfully' });\r\n    } catch (error) {\r\n      logger.error('File sharing failed:', error);\r\n      res.status(400).json({ message: error.message });\r\n    }\r\n  }\r\n);\r\n\r\n// Get file URL\r\nrouter.get('/:fileKey',\r\n  authenticate,\r\n  async (req, res) => {\r\n    try {\r\n      const url = storageService.getFileUrl(req.params.fileKey);\r\n      res.json({ url });\r\n    } catch (error) {\r\n      logger.error('Failed to get file URL:', error);\r\n      res.status(400).json({ message: error.message });\r\n    }\r\n  }\r\n);\r\n\r\n// Download file\r\nrouter.get('/:fileKey/download',\r\n  authenticate,\r\n  async (req, res) => {\r\n    try {\r\n      const data = await storageService.downloadFile(req.params.fileKey);\r\n      res.send(data);\r\n    } catch (error) {\r\n      logger.error('File download failed:', error);\r\n      res.status(400).json({ message: error.message });\r\n    }\r\n  }\r\n);\r\n\r\n// Delete file\r\nrouter.delete('/:fileKey',\r\n  authenticate,\r\n  async (req, res) => {\r\n    try {\r\n      await storageService.deleteFile(req.params.fileKey, {\r\n        userId: req.user.id\r\n      });\r\n      res.json({ message: 'File deleted successfully' });\r\n    } catch (error) {\r\n      logger.error('File deletion failed:', error);\r\n      res.status(400).json({ message: error.message });\r\n    }\r\n  }\r\n);\r\n\r\n// List files in a folder\r\nrouter.get('/list/:folder?',\r\n  authenticate,\r\n  async (req, res) => {\r\n    try {\r\n      const files = await storageService.listFiles(req.params.folder || '');\r\n      res.json(files);\r\n    } catch (error) {\r\n      logger.error('Failed to list files:', error);\r\n      res.status(400).json({ message: error.message });\r\n    }\r\n  }\r\n);\r\n\r\nmodule.exports = router; "
          },
          {
            "type": "file",
            "name": "user.routes.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\routes\\user.routes.js",
            "size": 676,
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst { authenticate } = require('../middleware/auth.middleware');\r\nconst { profileUpdateValidator, passwordChangeValidator } = require('../middleware/validators/user.validator');\r\nconst userController = require('../controllers/user.controller');\r\n\r\n// Get user profile\r\nrouter.get('/profile', authenticate, userController.getProfile);\r\n\r\n// Update user profile\r\nrouter.patch('/profile', authenticate, profileUpdateValidator, userController.updateProfile);\r\n\r\n// Change password\r\nrouter.patch('/password', authenticate, passwordChangeValidator, userController.changePassword);\r\n\r\nmodule.exports = router; "
          }
        ]
      },
      {
        "type": "directory",
        "name": "seeders",
        "path": "E:\\Work\\MIST_Hackathon\\server\\src\\seeders",
        "children": []
      },
      {
        "type": "directory",
        "name": "services",
        "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services",
        "children": [
          {
            "type": "file",
            "name": "assignment.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\assignment.service.js",
            "size": 7965,
            "content": "const { prisma } = require('./database.service');\r\n\r\n// ... existing code ...\r\n// ... existing code ...\r\nconst createAssignment = async (userId, assignmentData) => {\r\n    if (!userId) {\r\n      throw new Error('User ID is required');\r\n    }\r\n    \r\n    // Extract courseId from assignmentData and ensure it exists\r\n    const { courseId, ...otherData } = assignmentData;\r\n    \r\n    if (!courseId) {\r\n      throw new Error('Course ID is required');\r\n    }\r\n    \r\n    // Check if the course exists and belongs to the user\r\n    const course = await prisma.course.findFirst({\r\n      where: {\r\n        id: courseId,\r\n        userId: userId\r\n      }\r\n    });\r\n    \r\n    if (!course) {\r\n      throw new Error('Course not found or you do not have permission to add assignments to it');\r\n    }\r\n    \r\n    // Ensure status is set to \"due\" by default\r\n    const dataToCreate = {\r\n      ...otherData,\r\n      status: otherData.status || \"due\",\r\n      user: {\r\n        connect: {\r\n          id: userId\r\n        }\r\n      },\r\n      course: {\r\n        connect: {\r\n          id: courseId\r\n        }\r\n      }\r\n    };\r\n    \r\n    console.log(\"Creating assignment with data:\", dataToCreate); // Debug log\r\n    \r\n    return await prisma.assignment.create({\r\n      data: dataToCreate,\r\n      include: {\r\n        course: true\r\n      }\r\n    });\r\n  };\r\n// ... existing code ...\r\n  // ... existing code ...\r\n\r\nconst getAssignments = async (userId) => {\r\n  if (!userId) {\r\n    throw new Error('User ID is required');\r\n  }\r\n  \r\n  const assignments = await prisma.assignment.findMany({\r\n    where: { userId },\r\n    include: {\r\n      course: {\r\n        select: {\r\n          courseId: true,\r\n          courseName: true\r\n        }\r\n      }\r\n    },\r\n    orderBy: {\r\n      deadline: 'asc'\r\n    }\r\n  });\r\n  \r\n  // Check for overdue assignments and update their status\r\n  const now = new Date();\r\n  const updatedAssignments = [];\r\n  \r\n  for (const assignment of assignments) {\r\n    // Ensure status exists\r\n    if (!assignment.status) {\r\n      assignment.status = \"due\";\r\n      await prisma.assignment.update({\r\n        where: { id: assignment.id },\r\n        data: { status: \"due\" }\r\n      });\r\n    }\r\n    \r\n    // If deadline has passed and status is still \"due\", update to \"overdued\"\r\n    if (new Date(assignment.deadline) < now && assignment.status === \"due\") {\r\n      const updated = await prisma.assignment.update({\r\n        where: { id: assignment.id },\r\n        data: { status: \"overdued\" },\r\n        include: {\r\n          course: {\r\n            select: {\r\n              courseId: true,\r\n              courseName: true\r\n            }\r\n          }\r\n        }\r\n      });\r\n      updatedAssignments.push(updated);\r\n    } else {\r\n      updatedAssignments.push(assignment);\r\n    }\r\n  }\r\n  \r\n  console.log(\"Returning assignments:\", updatedAssignments); // Debug log\r\n  return updatedAssignments;\r\n};\r\n\r\nconst getAssignmentById = async (userId, assignmentId) => {\r\n  if (!userId || !assignmentId) {\r\n    throw new Error('User ID and Assignment ID are required');\r\n  }\r\n  \r\n  return await prisma.assignment.findFirst({\r\n    where: { \r\n      id: assignmentId,\r\n      userId \r\n    },\r\n    include: {\r\n      course: {\r\n        select: {\r\n          courseId: true,\r\n          courseName: true\r\n        }\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nconst updateAssignment = async (userId, assignmentId, updateData) => {\r\n  if (!userId || !assignmentId) {\r\n    throw new Error('User ID and Assignment ID are required');\r\n  }\r\n  \r\n  // First check if the assignment belongs to the user\r\n  const assignment = await prisma.assignment.findFirst({\r\n    where: { \r\n      id: assignmentId,\r\n      userId \r\n    }\r\n  });\r\n  \r\n  if (!assignment) {\r\n    throw new Error('Assignment not found or you do not have permission to update it');\r\n  }\r\n  \r\n  return await prisma.assignment.update({\r\n    where: { id: assignmentId },\r\n    data: updateData,\r\n    include: {\r\n      course: {\r\n        select: {\r\n          courseId: true,\r\n          courseName: true\r\n        }\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nconst deleteAssignment = async (userId, assignmentId) => {\r\n  if (!userId || !assignmentId) {\r\n    throw new Error('User ID and Assignment ID are required');\r\n  }\r\n  \r\n  // First check if the assignment belongs to the user\r\n  const assignment = await prisma.assignment.findFirst({\r\n    where: { \r\n      id: assignmentId,\r\n      userId \r\n    }\r\n  });\r\n  \r\n  if (!assignment) {\r\n    throw new Error('Assignment not found or you do not have permission to delete it');\r\n  }\r\n  \r\n  return await prisma.assignment.delete({\r\n    where: { id: assignmentId }\r\n  });\r\n};\r\n\r\n// Add this new service method\r\nconst notifyDeadline = async (userId, assignmentId) => {\r\n    if (!userId || !assignmentId) {\r\n      throw new Error('User ID and Assignment ID are required');\r\n    }\r\n    \r\n    // Get the assignment with course details\r\n    const assignment = await prisma.assignment.findFirst({\r\n      where: { \r\n        id: assignmentId,\r\n        userId \r\n      },\r\n      include: {\r\n        course: true,\r\n        user: true\r\n      }\r\n    });\r\n    \r\n    if (!assignment) {\r\n      throw new Error('Assignment not found');\r\n    }\r\n    \r\n    // Get the email service\r\n    const emailService = require('./email.service');\r\n    \r\n    // Get the notification service\r\n    const notificationService = require('./notification.service');\r\n    \r\n    // Format the deadline\r\n    const deadline = new Date(assignment.deadline);\r\n    const formattedDeadline = deadline.toLocaleString('en-US', {\r\n      weekday: 'long',\r\n      year: 'numeric',\r\n      month: 'long',\r\n      day: 'numeric',\r\n      hour: '2-digit',\r\n      minute: '2-digit'\r\n    });\r\n    \r\n    // Send email notification\r\n    const emailResult = await emailService.sendEmail({\r\n      to: assignment.user.email,\r\n      subject: `Deadline Reminder: ${assignment.assignmentName}`,\r\n      html: `\r\n        <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\r\n          <h2>Assignment Deadline Reminder</h2>\r\n          <p>This is a reminder that your assignment is due in 24 hours:</p>\r\n          \r\n          <div style=\"background-color: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0;\">\r\n            <p><strong>Assignment:</strong> ${assignment.assignmentName}</p>\r\n            <p><strong>Course:</strong> ${assignment.course.courseName} (${assignment.course.courseId})</p>\r\n            <p><strong>Deadline:</strong> ${formattedDeadline}</p>\r\n          </div>\r\n          \r\n          <p>Please ensure you complete and submit your assignment before the deadline.</p>\r\n          <p>You can view your assignment details by logging into your account.</p>\r\n          \r\n          <div style=\"margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; font-size: 12px; color: #666;\">\r\n            <p>This is an automated reminder. Please do not reply to this email.</p>\r\n          </div>\r\n        </div>\r\n      `\r\n    });\r\n    \r\n    // Create in-app notification\r\n    const notification = await notificationService.createNotification({\r\n      userId: assignment.userId,\r\n      title: 'Assignment Deadline Approaching',\r\n      message: `\"${assignment.assignmentName}\" is due within 24 hours (${formattedDeadline})`,\r\n      type: 'WARNING',\r\n      metadata: {\r\n        assignmentId: assignment.id,\r\n        courseId: assignment.courseId,\r\n        deadline: assignment.deadline\r\n      }\r\n    });\r\n    \r\n    // Mark the assignment as notified\r\n    await prisma.assignment.update({\r\n      where: { id: assignmentId },\r\n      data: { notifiedFor24HourDeadline: true }\r\n    });\r\n    \r\n    return {\r\n      emailSent: emailResult.success,\r\n      notificationCreated: !!notification,\r\n      assignment: {\r\n        id: assignment.id,\r\n        name: assignment.assignmentName,\r\n        deadline: assignment.deadline\r\n      }\r\n    };\r\n  };\r\n  \r\nmodule.exports = {\r\n  createAssignment,\r\n  getAssignments,\r\n  getAssignmentById,\r\n  updateAssignment,\r\n  deleteAssignment,\r\n  notifyDeadline\r\n};"
          },
          {
            "type": "file",
            "name": "auth.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\auth.service.js",
            "size": 15688,
            "content": "const bcrypt = require('bcrypt');\r\nconst jwt = require('jsonwebtoken');\r\nconst crypto = require('crypto');\r\nconst { prisma } = require('./database.service');\r\nconst { supabaseAdmin } = require('../config/supabase');\r\nconst emailService = require('./email.service');\r\nrequire('dotenv').config();\r\n\r\n// Generate a random token\r\nconst generateVerificationToken = (id) => {\r\n  const token = crypto.randomBytes(32).toString('hex');\r\n  const signedToken = jwt.sign(\r\n    { id },\r\n    process.env.JWT_VERIFICATION_SECRET,\r\n    { expiresIn: process.env.JWT_VERIFICATION_EXPIRES_IN }\r\n  )\r\n  return { token, signedToken };\r\n};\r\n\r\nconst generateResetToken = () => {\r\n  return crypto.randomBytes(32).toString('hex');\r\n};\r\n// Hash password\r\nconst hashPassword = async (password) => {\r\n  const saltRounds = 10;\r\n  return await bcrypt.hash(password, saltRounds);\r\n};\r\n\r\n// Compare password with hash\r\nconst comparePassword = async (password, hashedPassword) => {\r\n  return await bcrypt.compare(password, hashedPassword);\r\n};\r\n\r\n// Generate JWT tokens\r\nconst generateTokens = (userId, roles) => {\r\n  // Access token\r\n  const accessToken = jwt.sign(\r\n    { userId, roles },\r\n    process.env.JWT_SECRET,\r\n    { expiresIn: process.env.JWT_EXPIRES_IN }\r\n  );\r\n  \r\n  // Refresh token\r\n  const refreshToken = jwt.sign(\r\n    { userId },\r\n    process.env.JWT_REFRESH_SECRET,\r\n    { expiresIn: process.env.JWT_REFRESH_EXPIRES_IN }\r\n  );\r\n  \r\n  return { accessToken, refreshToken };\r\n};\r\n\r\n// Verify hCaptcha token\r\nconst verifyCaptcha = async (token) => {\r\n  try {\r\n    const secret = process.env.HCAPTCHA_SECRET_KEY;\r\n    \r\n    if (!secret) {\r\n      throw new Error('HCAPTCHA_SECRET_KEY is not set in environment variables');\r\n    }\r\n    \r\n    const response = await fetch('https://hcaptcha.com/siteverify', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n      },\r\n      body: `response=${token}&secret=${secret}`,\r\n    });\r\n    \r\n    const data = await response.json();\r\n    \r\n    if (!data.success) {\r\n      throw new Error('CAPTCHA verification failed');\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    throw new Error(`CAPTCHA verification failed: ${error.message}`);\r\n  }\r\n};\r\n\r\n// Register a new user\r\nconst registerEmployee = async (userData) => {\r\n  try {\r\n    const { email, password, name, roles = ['STUDENT'], captchaToken } = userData;\r\n    \r\n    // Verify captcha\r\n    //await verifyCaptcha(captchaToken);\r\n    \r\n    // Check if user already exists\r\n    const existingUser = await prisma.user.findUnique({\r\n      where: { email }\r\n    });\r\n\r\n    if (existingUser) {\r\n      throw new Error('A user with this email already exists');\r\n    }\r\n\r\n    // Hash password\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n    // Create user\r\n    const user = await prisma.user.create({\r\n      data: {\r\n        email,\r\n        password: hashedPassword,\r\n        name,\r\n        roles: roles,\r\n        status: 'ACTIVE',\r\n        emailVerified: false,\r\n        employeeInfo: {\r\n          create: {\r\n            employeeId,\r\n            designation\r\n          }\r\n        }\r\n      },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        roles: true,\r\n        status: true,\r\n        emailVerified: true,\r\n      }\r\n    });\r\n\r\n    // Generate verification token\r\n    const { token: verificationToken, signedToken: signedVerificationToken } = generateVerificationToken(user.id);\r\n\r\n    // Update verification token in database\r\n    await prisma.user.update({\r\n      where: { id: user.id },\r\n      data: {\r\n        verificationToken\r\n      }\r\n    });\r\n\r\n    // Send verification email\r\n    await emailService.sendVerificationEmail(user, signedVerificationToken);\r\n\r\n    return { user };\r\n  } catch (error) {\r\n    console.error('Error registering employee:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Register a new student\r\nconst studentRegister = async (userData) => {\r\n  try {\r\n    const { email, password, name, roles = ['STUDENT'], captchaToken, studentId, section, batch, departmentId } = userData;\r\n    \r\n    // Verify captcha\r\n    //await verifyCaptcha(captchaToken);\r\n    \r\n    // Check if user already exists by email or studentId\r\n    const existingUser = await prisma.user.findUnique({\r\n      where: { OR: [{ email }, { studentInfo: { studentId } }] }\r\n    });\r\n\r\n    if (existingUser) {\r\n      throw new Error('A user with this data already exists');\r\n    }\r\n\r\n    // Hash password\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n    // Create user\r\n    const user = await prisma.user.create({\r\n      data: {\r\n        email,\r\n        password: hashedPassword,\r\n        name,\r\n        roles: roles,\r\n        status: 'ACTIVE',\r\n        emailVerified: false,\r\n        studentInfo: {\r\n          create: {\r\n            studentId,\r\n            section,\r\n            batch,\r\n            department: {\r\n              connect: { id: departmentId }\r\n            }\r\n          }\r\n        }\r\n      },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        roles: true,\r\n        status: true,\r\n        emailVerified: true,\r\n      }\r\n    });\r\n\r\n    // Generate verification token\r\n    const { token: verificationToken, signedToken: signedVerificationToken } = generateVerificationToken(user.id);\r\n\r\n    // Update verification token in database\r\n    await prisma.user.update({\r\n      where: { id: user.id },\r\n      data: {\r\n        verificationToken\r\n      }\r\n    });\r\n\r\n    // Send verification email\r\n    await emailService.sendVerificationEmail(user, signedVerificationToken);\r\n\r\n    return { user };\r\n  } catch (error) {\r\n    console.error('Error registering student:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Register a new faculty\r\nconst facultyRegister = async (userData) => {\r\n  try {\r\n    const { email, password, name, roles = ['FACULTY'], captchaToken, employeeId, status, designation, departmentId, bio } = userData;\r\n    \r\n    // Verify captcha\r\n    //await verifyCaptcha(captchaToken);\r\n    \r\n    // Check if user already exists\r\n    const existingUser = await prisma.user.findUnique({\r\n      where: { email }\r\n    });\r\n\r\n    if (existingUser) {\r\n      throw new Error('A user with this email already exists');\r\n    }\r\n\r\n    // Hash password\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n    // Create user\r\n    const user = await prisma.user.create({\r\n      data: {\r\n        email,\r\n        password: hashedPassword,\r\n        name,\r\n        roles: roles,\r\n        status: 'ACTIVE',\r\n        emailVerified: false,\r\n        facultyInfo: {\r\n          create: {\r\n            employeeId,\r\n            status,\r\n            designation,\r\n            bio,\r\n            department: {\r\n              connect: { id: departmentId }\r\n            }\r\n          }\r\n        }\r\n      },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        roles: true,\r\n        status: true,\r\n        emailVerified: true,\r\n      }\r\n    });\r\n\r\n    // Generate verification token\r\n    const { token: verificationToken, signedToken: signedVerificationToken } = generateVerificationToken(user.id);\r\n\r\n    // Update verification token in database\r\n    await prisma.user.update({\r\n      where: { id: user.id },\r\n      data: {\r\n        verificationToken\r\n      }\r\n    });\r\n\r\n    // Send verification email\r\n    await emailService.sendVerificationEmail(user, signedVerificationToken);\r\n\r\n    return { user };\r\n  } catch (error) {\r\n    console.error('Error registering faculty:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Verify email with token\r\nconst verifyEmail = async (token) => {\r\n  try {\r\n\r\n    const decoded = jwt.verify(token, process.env.JWT_VERIFICATION_SECRET); \r\n\r\n    // Find user with this verification token in our database\r\n    const user = await prisma.user.findFirst({\r\n      where: { id: decoded.id }\r\n    });\r\n    \r\n    if (!user) {\r\n      throw new Error('Invalid or expired verification token');\r\n    }\r\n    \r\n    \r\n    // Update user status in our database\r\n    const updatedUser = await prisma.user.update({\r\n      where: { id: user.id },\r\n      data: {\r\n        emailVerified: true,\r\n        verificationToken: null\r\n      }\r\n    });\r\n\r\n    // Generate tokens\r\n    const { accessToken, refreshToken } = generateTokens(user.id, user.roles);\r\n\r\n    // Create session\r\n    await prisma.session.create({\r\n      data: {\r\n        userId: user.id,\r\n        token: refreshToken,\r\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\r\n      }\r\n    });\r\n\r\n    return { success: true, user: updatedUser, accessToken, refreshToken };\r\n  } catch (error) {\r\n    console.error('Error during email verification:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Login user\r\nconst login = async (email, password, captchaToken) => {\r\n  try {\r\n    // Verify captcha\r\n    //await verifyCaptcha(captchaToken);\r\n    \r\n    // Find user by email\r\n    const user = await prisma.user.findUnique({\r\n      where: { email },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        password: true,\r\n        name: true,\r\n        roles: true,\r\n        status: true,\r\n        emailVerified: true\r\n      }\r\n    });\r\n\r\n    if (!user) {\r\n      throw new Error('No user found with this email');\r\n    }\r\n\r\n    // Check password\r\n    const isValidPassword = await bcrypt.compare(password, user.password);\r\n    if (!isValidPassword) {\r\n      throw new Error('Wrong password. Please try again.');\r\n    }\r\n    \r\n    // Format user data for response, ensuring firstName and lastName are included\r\n    const userData = {\r\n      id: user.id,\r\n      email: user.email,\r\n      name: user.name,\r\n      status: user.status,\r\n      roles: user.roles,\r\n      emailVerified: user.emailVerified,\r\n    };\r\n\r\n    if (user.status !== 'ACTIVE') {\r\n      throw new Error('Account is not active. Please contact support.');\r\n    }\r\n\r\n    // Generate tokens\r\n    const { accessToken, refreshToken } = generateTokens(user.id, user.roles);\r\n    \r\n    // Create session\r\n    await prisma.session.create({\r\n      data: {\r\n        userId: user.id,\r\n        token: refreshToken,\r\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\r\n      }\r\n    });\r\n\r\n    return {\r\n      user: userData,\r\n      accessToken,\r\n      refreshToken\r\n    };\r\n  } catch (error) {\r\n    console.error('Error logging in:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Logout user\r\nconst logout = async (userId, refreshToken) => {\r\n  try {\r\n    // Remove session\r\n    await prisma.session.deleteMany({\r\n      where: {\r\n        userId,\r\n        token: refreshToken\r\n      }\r\n    });\r\n    \r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error during logout:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Refresh access token\r\nconst refreshToken = async (token) => {\r\n  try {\r\n    // Verify refresh token\r\n    const decoded = jwt.verify(token, process.env.JWT_REFRESH_SECRET);\r\n    \r\n    // Check if token exists in database\r\n    const session = await prisma.session.findFirst({\r\n      where: {\r\n        userId: decoded.userId,\r\n        token,\r\n        expiresAt: {\r\n          gt: new Date()\r\n        }\r\n      }\r\n    });\r\n    \r\n    if (!session) {\r\n      throw new Error('Invalid or expired refresh token');\r\n    }\r\n    \r\n    // Find the user to get their current role\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: decoded.userId },\r\n      select: {\r\n        id: true,\r\n        roles: true\r\n      }\r\n    });\r\n    \r\n    if (!user) {\r\n      throw new Error('User not found');\r\n    }\r\n    \r\n    // Generate new tokens with the user's current roles\r\n    const tokens = generateTokens(user.id, user.roles);\r\n    \r\n    // Update session with new refresh token\r\n    await prisma.session.update({\r\n      where: { id: session.id },\r\n      data: { token: tokens.refreshToken, expiresAt: new Date(Date.now() + 60 * 60 * 1000) }\r\n    });\r\n    \r\n    return {\r\n      accessToken: tokens.accessToken,\r\n      refreshToken: tokens.refreshToken\r\n    };\r\n  } catch (error) {\r\n    console.error('Error refreshing token:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Request password reset\r\nconst requestPasswordReset = async (email, captchaToken) => {\r\n  try {\r\n    // Verify captcha\r\n    //await verifyCaptcha(captchaToken);\r\n    \r\n    // Find user by email\r\n    const user = await prisma.user.findUnique({ where: { email } });\r\n    \r\n    // If the user doesn't exist, we still return success (for security)\r\n    if (!user) {\r\n      return { success: true };\r\n    }\r\n    \r\n    // Generate reset token and expiry\r\n    const resetToken = generateResetToken();\r\n    const resetTokenExpiry = new Date();\r\n    resetTokenExpiry.setMinutes(resetTokenExpiry.getMinutes() + 10);\r\n    \r\n    // Update user with reset token and expiry\r\n    await prisma.user.update({\r\n      where: { id: user.id },\r\n      data: {\r\n        resetToken,\r\n        resetTokenExpiry,\r\n      },\r\n    });\r\n      \r\n      // Send password reset email\r\n      await emailService.sendPasswordResetEmail(user, resetToken);\r\n    \r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error requesting password reset:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Reset password\r\nconst resetPassword = async (token, newPassword) => {\r\n  try {\r\n    // Find user with this reset token\r\n    const user = await prisma.user.findFirst({\r\n      where: {\r\n        resetToken: token,\r\n        resetTokenExpiry: {\r\n          gt: new Date()\r\n        }\r\n      }\r\n    });\r\n    \r\n    if (!user) {\r\n      throw new Error('Invalid or expired reset token');\r\n    }\r\n    \r\n    // Hash new password\r\n    const hashedPassword = await hashPassword(newPassword);\r\n    \r\n    // Update user password in our database\r\n    await prisma.user.update({\r\n      where: { id: user.id },\r\n      data: {\r\n        password: hashedPassword,\r\n        resetToken: null,\r\n        resetTokenExpiry: null\r\n      }\r\n    });\r\n    \r\n    // Update Supabase auth password\r\n    const { error: supabaseError } = await supabaseAdmin.auth.admin.updateUserById(\r\n      user.id,\r\n      { password: newPassword }\r\n    );\r\n    \r\n    if (supabaseError) {\r\n      console.error('Error updating Supabase password:', supabaseError);\r\n      // Continue as we already updated our database\r\n    }\r\n    \r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error resetting password:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Resend verification email\r\nconst resendVerificationEmail = async (email) => {\r\n  try {\r\n    // Find user by email\r\n    const user = await prisma.user.findUnique({\r\n      where: { email }\r\n    });\r\n    \r\n    if (!user) {\r\n      // For security, don't reveal that the user doesn't exist\r\n      return { success: true };\r\n    }\r\n    \r\n    // Check if user is already verified\r\n    if (user.emailVerified) {\r\n      return { success: true };\r\n    }\r\n    \r\n      const { token: verificationToken, signedToken: signedVerificationToken } = generateVerificationToken(user.id);\r\n      \r\n      // Update user with new verification token\r\n      await prisma.user.update({\r\n        where: { id: user.id },\r\n        data: {\r\n          verificationToken\r\n        }\r\n      });\r\n      \r\n      // Send verification email\r\n      await emailService.sendVerificationEmail(user, signedVerificationToken);\r\n    \r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error('Error resending verification email:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  registerEmployee,\r\n  studentRegister,\r\n  facultyRegister,\r\n  verifyEmail,\r\n  login,\r\n  logout,\r\n  refreshToken,\r\n  requestPasswordReset,\r\n  resetPassword,\r\n  generateTokens,\r\n  comparePassword,\r\n  resendVerificationEmail\r\n}; "
          },
          {
            "type": "file",
            "name": "bus.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\bus.service.js",
            "size": 3065,
            "content": "const { prisma } = require('../services/database.service');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\n/**\r\n * Get all buses\r\n */\r\nconst getAllBuses = async () => {\r\n  try {\r\n    logger.debug('Retrieving all buses');\r\n    return await prisma.bus.findMany();\r\n  } catch (error) {\r\n    logger.error('Error retrieving buses:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get bus by ID\r\n */\r\nconst getBusById = async (id) => {\r\n  try {\r\n    logger.debug(`Getting bus with ID: ${id}`);\r\n    return await prisma.bus.findUnique({\r\n      where: { id }\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error retrieving bus with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new bus\r\n */\r\nconst createBus = async (busData) => {\r\n  try {\r\n    logger.debug('Creating a new bus', busData);\r\n    return await prisma.bus.create({\r\n      data: busData\r\n    });\r\n  } catch (error) {\r\n    logger.error('Error creating bus:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Update a bus\r\n */\r\nconst updateBus = async (id, busData) => {\r\n  try {\r\n    logger.debug(`Updating bus with ID: ${id}`, busData);\r\n    return await prisma.bus.update({\r\n      where: { id },\r\n      data: busData\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error updating bus with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a bus\r\n */\r\nconst deleteBus = async (id) => {\r\n  try {\r\n    logger.debug(`Deleting bus with ID: ${id}`);\r\n    return await prisma.bus.delete({\r\n      where: { id }\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error deleting bus with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get all drivers\r\n */\r\nconst getAllDrivers = async () => {\r\n  try {\r\n    logger.debug('Retrieving all drivers');\r\n    return await prisma.driver.findMany();\r\n  } catch (error) {\r\n    logger.error('Error retrieving drivers:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new driver\r\n */\r\nconst createDriver = async (driverData) => {\r\n  try {\r\n    logger.debug('Creating a new driver', driverData);\r\n    return await prisma.driver.create({\r\n      data: driverData\r\n    });\r\n  } catch (error) {\r\n    logger.error('Error creating driver:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Update a driver\r\n */\r\nconst updateDriver = async (id, driverData) => {\r\n  try {\r\n    logger.debug(`Updating driver with ID: ${id}`, driverData);\r\n    return await prisma.driver.update({\r\n      where: { id },\r\n      data: driverData\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error updating driver with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a driver\r\n */\r\nconst deleteDriver = async (id) => {\r\n  try {\r\n    logger.debug(`Deleting driver with ID: ${id}`);\r\n    return await prisma.driver.delete({\r\n      where: { id }\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error deleting driver with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  getAllBuses,\r\n  getBusById,\r\n  createBus,\r\n  updateBus,\r\n  deleteBus,\r\n  getAllDrivers,\r\n  createDriver,\r\n  updateDriver,\r\n  deleteDriver,\r\n};\r\n"
          },
          {
            "type": "file",
            "name": "cafeteria.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\cafeteria.service.js",
            "size": 12231,
            "content": "const { prisma } = require('../services/database.service');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\n/**\r\n * Get all meals\r\n */\r\nconst getAllMeals = async () => {\r\n  try {\r\n    logger.debug('Retrieving all meals');\r\n    const meals = await prisma.meal.findMany();\r\n    return meals;\r\n  } catch (error) {\r\n    logger.error('Error retrieving meals:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get meal by ID\r\n */\r\nconst getMealById = async (id) => {\r\n  try {\r\n    logger.debug(`Getting meal with ID: ${id}`);\r\n    \r\n    return await prisma.meal.findUnique({\r\n      where: { id: parseInt(id) }\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error retrieving meal with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new meal\r\n */\r\nconst createMeal = async (mealData) => {\r\n  try {\r\n    logger.debug('Creating a new meal', mealData);\r\n    \r\n    return await prisma.meal.create({\r\n      data: mealData\r\n    });\r\n  } catch (error) {\r\n    logger.error('Error creating meal:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Update a meal\r\n */\r\nconst updateMeal = async (id, mealData) => {\r\n  try {\r\n    logger.debug(`Updating meal with ID: ${id}`, mealData);\r\n    \r\n    return await prisma.meal.update({\r\n      where: { id: parseInt(id) },\r\n      data: mealData\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error updating meal with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a meal\r\n */\r\nconst deleteMeal = async (id) => {\r\n  try {\r\n    logger.debug(`Deleting meal with ID: ${id}`);\r\n    \r\n    return await prisma.meal.delete({\r\n      where: { id: parseInt(id) }\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error deleting meal with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get all menus, optionally filtered by date\r\n */\r\nconst getMenus = async (date) => {\r\n  try {\r\n    logger.debug('Retrieving menus', date ? { date } : 'all');\r\n    \r\n    \r\n    let query = {\r\n      include: {\r\n        menuMeals: {\r\n          include: {\r\n            meal: true\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    if (date) {\r\n      const startDate = new Date(date);\r\n      startDate.setHours(0, 0, 0, 0);\r\n      \r\n      const endDate = new Date(date);\r\n      endDate.setHours(23, 59, 59, 999);\r\n      \r\n      query.where = {\r\n        date: {\r\n          gte: startDate,\r\n          lte: endDate\r\n        }\r\n      };\r\n    }\r\n\r\n    return await prisma.menu.findMany(query);\r\n  } catch (error) {\r\n    logger.error('Error retrieving menus:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get menu by ID\r\n */\r\nconst getMenuById = async (id) => {\r\n  try {\r\n    logger.debug(`Getting menu with ID: ${id}`);\r\n    \r\n    return await prisma.menu.findUnique({\r\n      where: { id: parseInt(id) },\r\n      include: {\r\n        menuMeals: {\r\n          include: {\r\n            meal: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error retrieving menu with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get today's menu\r\n */\r\nconst getTodayMenu = async () => {\r\n  try {\r\n    logger.debug('Getting today\\'s menu');\r\n    \r\n    \r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n    \r\n    const tomorrow = new Date(today);\r\n    tomorrow.setDate(tomorrow.getDate() + 1);\r\n    \r\n    return await prisma.menu.findFirst({\r\n      where: {\r\n        date: {\r\n          gte: today,\r\n          lt: tomorrow\r\n        }\r\n      },\r\n      include: {\r\n        menuMeals: {\r\n          include: {\r\n            meal: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n  } catch (error) {\r\n    logger.error('Error retrieving today\\'s menu:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new menu\r\n */\r\nconst createMenu = async (menuData) => {\r\n  try {\r\n    const { date, meals } = menuData;\r\n    \r\n    // Convert date string to Date object if necessary\r\n    const menuDate = typeof date === 'string' ? new Date(date) : date;\r\n    \r\n    return await prisma.$transaction(async (prisma) => {\r\n      // Create the menu\r\n      const menu = await prisma.menu.create({\r\n        data: {\r\n          date: menuDate\r\n        }\r\n      });\r\n      \r\n      // Add meals to the menu if provided\r\n      if (meals && meals.length > 0) {\r\n        const menuMeals = await Promise.all(\r\n          meals.map(async (mealItem) => {\r\n            return prisma.menuMeal.create({\r\n              data: {\r\n                menuId: menu.id,\r\n                mealId: mealItem.mealId,\r\n                price: mealItem.price,\r\n                available: mealItem.available ?? true\r\n              }\r\n            });\r\n          })\r\n        );\r\n        \r\n        return { ...menu, menuMeals };\r\n      }\r\n      \r\n      return menu;\r\n    });\r\n  } catch (error) {\r\n    logger.error('Error creating menu:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Update a menu\r\n */\r\nconst updateMenu = async (id, menuData) => {\r\n  try {\r\n    const { date, meals } = menuData;\r\n    \r\n    return await prisma.$transaction(async (prisma) => {\r\n      // Update menu date if provided\r\n      let menu = { id: parseInt(id) };\r\n      \r\n      if (date) {\r\n        menu = await prisma.menu.update({\r\n          where: { id: parseInt(id) },\r\n          data: { date: new Date(date) }\r\n        });\r\n      }\r\n      \r\n      // Update menu meals if provided\r\n      if (meals && meals.length > 0) {\r\n        // Get current menu meals\r\n        const currentMenuMeals = await prisma.menuMeal.findMany({\r\n          where: { menuId: parseInt(id) },\r\n          select: { id: true, mealId: true }\r\n        });\r\n        \r\n        // Create map of current meal IDs for quick lookup\r\n        const currentMealMap = new Map(\r\n          currentMenuMeals.map(item => [item.mealId, item.id])\r\n        );\r\n        \r\n        // Process each meal in the update\r\n        for (const meal of meals) {\r\n          if (currentMealMap.has(meal.mealId)) {\r\n            // Update existing menu meal\r\n            await prisma.menuMeal.update({\r\n              where: { id: currentMealMap.get(meal.mealId) },\r\n              data: {\r\n                price: meal.price,\r\n                available: meal.available\r\n              }\r\n            });\r\n            // Remove from map to track processed items\r\n            currentMealMap.delete(meal.mealId);\r\n          } else {\r\n            // Add new menu meal\r\n            await prisma.menuMeal.create({\r\n              data: {\r\n                menuId: parseInt(id),\r\n                mealId: meal.mealId,\r\n                price: meal.price,\r\n                available: meal.available ?? true\r\n              }\r\n            });\r\n          }\r\n        }\r\n        \r\n        // Remove any meals that were not in the update if removeOthers flag is true\r\n        if (menuData.removeOthers && currentMealMap.size > 0) {\r\n          await prisma.menuMeal.deleteMany({\r\n            where: {\r\n              id: {\r\n                in: Array.from(currentMealMap.values())\r\n              }\r\n            }\r\n          });\r\n        }\r\n      }\r\n      \r\n      // Return updated menu with meals\r\n      return await prisma.menu.findUnique({\r\n        where: { id: parseInt(id) },\r\n        include: {\r\n          menuMeals: {\r\n            include: {\r\n              meal: true\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error updating menu with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a menu\r\n */\r\nconst deleteMenu = async (id) => {\r\n  try {\r\n    return await prisma.$transaction(async (prisma) => {\r\n      // Delete related menu meals first\r\n      await prisma.menuMeal.deleteMany({\r\n        where: { menuId: parseInt(id) }\r\n      });\r\n      \r\n      // Then delete the menu\r\n      return await prisma.menu.delete({\r\n        where: { id: parseInt(id) }\r\n      });\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error deleting menu with ID ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Toggle meal availability in a menu\r\n */\r\nconst toggleMealAvailability = async (menuMealId, available) => {\r\n  try {\r\n    logger.debug(`Toggling availability for menu meal ID ${menuMealId} to ${available}`);\r\n    \r\n    \r\n    return await prisma.menuMeal.update({\r\n      where: { id: parseInt(menuMealId) },\r\n      data: { available },\r\n      include: { meal: true }\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error toggling availability for menu meal ID ${menuMealId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Create a preorder\r\n */\r\nconst createPreorder = async (userId, menuMealId) => {\r\n  try {\r\n    logger.debug(`Creating preorder for user ${userId} and menu meal ${menuMealId}`);\r\n    \r\n    \r\n    // Check if menu meal exists and is available\r\n    const menuMeal = await prisma.menuMeal.findUnique({\r\n      where: { id: parseInt(menuMealId) },\r\n      include: {\r\n        meal: true,\r\n        menu: true\r\n      }\r\n    });\r\n    \r\n    if (!menuMeal) {\r\n      throw new Error('Menu meal not found');\r\n    }\r\n    \r\n    if (!menuMeal.available) {\r\n      throw new Error('This meal is not currently available for ordering');\r\n    }\r\n    \r\n    // Check if menu is for today or future date\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n    \r\n    if (menuMeal.menu.date < today) {\r\n      throw new Error('Cannot preorder from a past menu');\r\n    }\r\n    \r\n    // Create the preorder\r\n    return await prisma.preorder.create({\r\n      data: {\r\n        userId,\r\n        menuMealId: parseInt(menuMealId),\r\n        status: 'placed'\r\n      },\r\n      include: {\r\n        menuMeal: {\r\n          include: {\r\n            meal: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n  } catch (error) {\r\n    logger.error('Error creating preorder:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get user preorders\r\n */\r\nconst getUserPreorders = async (userId) => {\r\n  try {\r\n    logger.debug(`Getting preorders for user ${userId}`);\r\n    \r\n    \r\n    return await prisma.preorder.findMany({\r\n      where: { userId },\r\n      include: {\r\n        menuMeal: {\r\n          include: {\r\n            meal: true,\r\n            menu: true\r\n          }\r\n        }\r\n      },\r\n      orderBy: {\r\n        orderTime: 'desc'\r\n      }\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error retrieving preorders for user ${userId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Update preorder status\r\n */\r\nconst updatePreorderStatus = async (orderId, status) => {\r\n  try {\r\n    const validStatuses = ['placed', 'ready', 'picked_up', 'cancelled'];\r\n    \r\n    if (!validStatuses.includes(status)) {\r\n      throw new Error(`Invalid status. Must be one of: ${validStatuses.join(', ')}`);\r\n    }\r\n    \r\n    return await prisma.preorder.update({\r\n      where: { id: parseInt(orderId) },\r\n      data: { status },\r\n      include: {\r\n        menuMeal: {\r\n          include: {\r\n            meal: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error updating status for preorder ${orderId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Cancel a preorder\r\n */\r\nconst cancelPreorder = async (orderId, userId) => {\r\n  try {\r\n    // Check if the preorder exists and belongs to the user\r\n    const preorder = await prisma.preorder.findUnique({\r\n      where: { id: parseInt(orderId) }\r\n    });\r\n    \r\n    if (!preorder) {\r\n      throw new Error('Preorder not found');\r\n    }\r\n    \r\n    if (preorder.userId !== userId) {\r\n      throw new Error('You are not authorized to cancel this preorder');\r\n    }\r\n    \r\n    // Check if the preorder is already picked up\r\n    if (preorder.status === 'picked_up') {\r\n      throw new Error('Cannot cancel a picked up order');\r\n    }\r\n    \r\n    // Cancel the preorder\r\n    return await prisma.preorder.update({\r\n      where: { id: parseInt(orderId) },\r\n      data: { status: 'cancelled' }\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Error cancelling preorder ${orderId}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  // Meal functions\r\n  getAllMeals,\r\n  getMealById,\r\n  createMeal,\r\n  updateMeal,\r\n  deleteMeal,\r\n  \r\n  // Menu functions\r\n  getMenus,\r\n  getMenuById,\r\n  getTodayMenu,\r\n  createMenu,\r\n  updateMenu,\r\n  deleteMenu,\r\n  toggleMealAvailability,\r\n  \r\n  // Preorder functions\r\n  createPreorder,\r\n  getUserPreorders,\r\n  updatePreorderStatus,\r\n  cancelPreorder\r\n};"
          },
          {
            "type": "file",
            "name": "cart.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\cart.service.js",
            "size": 2287,
            "content": "// cart.service.js\r\nconst { PrismaClient } = require(\"@prisma/client\");\r\nconst prisma = new PrismaClient();\r\n\r\n\r\nexports.getCartItems = async (userId) => {\r\n    const cart = await prisma.cart.findUnique({\r\n      where: { userId },\r\n      include: {\r\n        items: {\r\n          include: {\r\n            meal: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n  \r\n    if (!cart) {\r\n      return [];\r\n    }\r\n  \r\n    return cart.items;\r\n  };\r\n\r\n\r\n\r\nexports.addMealToCart = async (userId, mealId) => {\r\n  let cart = await prisma.cart.findUnique({\r\n    where: { userId },\r\n  });\r\n\r\n  if (!cart) {\r\n    cart = await prisma.cart.create({\r\n      data: { userId },\r\n    });\r\n  }\r\n\r\n  let cartItem = await prisma.cartItem.findUnique({\r\n    where: {\r\n      cartId_mealId: {\r\n        cartId: cart.id,\r\n        mealId,\r\n      },\r\n    },\r\n  });\r\n\r\n  if (cartItem) {\r\n    cartItem = await prisma.cartItem.update({\r\n      where: { id: cartItem.id },\r\n      data: { quantity: cartItem.quantity + 1 },\r\n    });\r\n  } else {\r\n    cartItem = await prisma.cartItem.create({\r\n      data: {\r\n        cartId: cart.id,\r\n        mealId,\r\n        quantity: 1,\r\n      },\r\n    });\r\n  }\r\n\r\n  return cartItem;\r\n};\r\n\r\n\r\nexports.removeFromCart = async (userId, cartItemId) => {\r\n    const cart = await prisma.cart.findUnique({\r\n      where: { userId },\r\n      include: {\r\n        items: {\r\n          where: { id: cartItemId }\r\n        }\r\n      }\r\n    });\r\n  \r\n    if (!cart || cart.items.length === 0) {\r\n      throw new Error('Cart item not found');\r\n    }\r\n  \r\n    // Delete the cart item\r\n    return await prisma.cartItem.delete({\r\n      where: { id: cartItemId }\r\n    });\r\n  };\r\n\r\n  exports.updateCartItemQuantity = async (userId, cartItemId, quantity) => {\r\n    // First verify the cart item belongs to the user\r\n    const cart = await prisma.cart.findUnique({\r\n      where: { userId },\r\n      include: {\r\n        items: {\r\n          where: { id: cartItemId },\r\n          include: { meal: true }\r\n        }\r\n      }\r\n    });\r\n  \r\n    if (!cart || cart.items.length === 0) {\r\n      throw new Error('Cart item not found');\r\n    }\r\n  \r\n    // Update the cart item quantity\r\n    return await prisma.cartItem.update({\r\n      where: { id: cartItemId },\r\n      data: { quantity },\r\n      include: { meal: true }\r\n    });\r\n  };"
          },
          {
            "type": "file",
            "name": "club.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\club.service.js",
            "size": 4124,
            "content": "const { prisma } = require('./database.service');\r\nconst storageService = require('./storage.service');\r\n\r\n// Create a new club\r\nconst createClub = async (data) => {\r\n  return await prisma.club.create({\r\n    data\r\n  });\r\n};\r\n\r\n// Update an existing club\r\nconst updateClub = async (id, data) => {\r\n  return await prisma.club.update({\r\n    where: { id: parseInt(id) },\r\n    data\r\n  });\r\n};\r\n\r\n// Delete a club\r\nconst deleteClub = async (id) => {\r\n  return await prisma.club.delete({\r\n    where: { id: parseInt(id) }\r\n  });\r\n};\r\n\r\n// Follow a club\r\nconst followClub = async (userId, clubId) => {\r\n  // Check if the user is already following the club\r\n  const existingFollow = await prisma.club.followers({\r\n    where: { id: clubId }\r\n  }).some(follower => follower.id === userId);\r\n  if (existingFollow) {\r\n    throw new Error('User is already following this club.');\r\n  }\r\n  await prisma.club.update({\r\n    where: { id: clubId },\r\n    data: {\r\n      followers: {\r\n        connect: { id: userId }\r\n      }\r\n    }\r\n  });\r\n  // Log the follow action\r\n  await prisma.followUnfollowLog.create({\r\n    data: {\r\n      userId,\r\n      clubId,\r\n      action: 'follow'\r\n    }\r\n  });\r\n};\r\n\r\n// Unfollow a club\r\nconst unfollowClub = async (userId, clubId) => {\r\n  const existingFollow = await prisma.club.followers({\r\n    where: { id: clubId }\r\n  }).some(follower => follower.id === userId);\r\n  if (!existingFollow) {\r\n    throw new Error('User is not following this club.');\r\n  }\r\n  await prisma.club.update({\r\n    where: { id: clubId },\r\n    data: {\r\n      followers: {\r\n        disconnect: { id: userId }\r\n      }\r\n    }\r\n  });\r\n  // Log the unfollow action\r\n  await prisma.followUnfollowLog.create({\r\n    data: {\r\n      userId,\r\n      clubId,\r\n      action: 'unfollow'\r\n    }\r\n  });\r\n};\r\n\r\n// Add album photo\r\nconst addAlbumPhoto = async (clubId, photo) => {\r\n  const photoUrl = await storageService.uploadPhoto(photo);\r\n  return await prisma.clubAlbumPhoto.create({\r\n    data: {\r\n      clubId,\r\n      photoUrl\r\n    }\r\n  });\r\n};\r\n\r\n// Remove album photo\r\nconst removeAlbumPhoto = async (photoId) => {\r\n  const photo = await prisma.clubAlbumPhoto.findUnique({\r\n    where: { id: parseInt(photoId) }\r\n  });\r\n  if (!photo) {\r\n    throw new Error('Photo not found');\r\n  }\r\n  await storageService.deletePhoto(photo.photoUrl);\r\n  return await prisma.clubAlbumPhoto.delete({\r\n    where: { id: parseInt(photoId) }\r\n  });\r\n};\r\n\r\n// Add a user to a club\r\nconst addUserToClub = async (userId, clubId, role) => {\r\n  return await prisma.userClub.create({\r\n    data: {\r\n      userId,\r\n      clubId,\r\n      role\r\n    }\r\n  });\r\n};\r\n\r\n// Remove a user from a club\r\nconst removeUserFromClub = async (userId, clubId) => {\r\n  return await prisma.userClub.delete({\r\n    where: {\r\n      userId,\r\n      clubId\r\n    }\r\n  });\r\n};\r\n\r\n// Change a user's role/status in a club\r\nconst changeUserRoleInClub = async (userId, clubId, newRole) => {\r\n  return await prisma.userClub.update({\r\n    where: {\r\n      userId,\r\n      clubId\r\n    },\r\n    data: {\r\n      role: newRole\r\n    }\r\n  });\r\n};\r\n\r\n// Log a user's visit to a club page\r\nconst logUserVisit = async (userId, clubId) => {\r\n  return await prisma.userVisit.create({\r\n    data: {\r\n      userId,\r\n      clubId\r\n    }\r\n  });\r\n};\r\n\r\n// Search for clubs\r\nconst searchClubs = async (searchParams) => {\r\n  const { query, page = 1, limit = 10, sort } = searchParams;\r\n  const where = {\r\n    OR: [\r\n      { name: { contains: query, mode: 'insensitive' } },\r\n      { description: { contains: query, mode: 'insensitive' } },\r\n      { tags: { contains: query, mode: 'insensitive' } }\r\n    ]\r\n  };\r\n  const clubs = await prisma.club.findMany({\r\n    where,\r\n    skip: (page - 1) * limit,\r\n    take: limit,\r\n    orderBy: sort === 'newest' ? { foundingDate: 'desc' } : { name: 'asc' }\r\n  });\r\n  const totalCount = await prisma.club.count({ where });\r\n  return { clubs, totalCount };\r\n};\r\n\r\nmodule.exports = {\r\n  createClub,\r\n  updateClub,\r\n  deleteClub,\r\n  followClub,\r\n  unfollowClub,\r\n  addAlbumPhoto,\r\n  removeAlbumPhoto,\r\n  addUserToClub,\r\n  removeUserFromClub,\r\n  changeUserRoleInClub,\r\n  logUserVisit,\r\n  searchClubs\r\n}; "
          },
          {
            "type": "file",
            "name": "database.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\database.service.js",
            "size": 931,
            "content": "const { PrismaClient } = require('@prisma/client');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\n// Initialize Prisma client with logging during development\r\n\r\n\r\nconst prisma = new PrismaClient({\r\n  log: process.env.NODE_ENV === 'development' ? ['query', 'info', 'warn', 'error'] : ['error'],\r\n});\r\n\r\n// Function to handle connection lifecycle\r\nlet isConnected = false;\r\n\r\nasync function connect() {\r\n  if (isConnected) {\r\n    return;\r\n  }\r\n\r\n  try {\r\n    await prisma.$connect();\r\n    isConnected = true;\r\n    logger.info('Connected to database successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to connect to database:', error);\r\n    // Implement retry logic if needed\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Handle graceful shutdown\r\nfunction disconnect() {\r\n  return prisma.$disconnect();\r\n}\r\n\r\nprocess.on('exit', () => {\r\n  disconnect();\r\n});\r\n\r\nmodule.exports = {\r\n  prisma,\r\n  connect,\r\n  disconnect,\r\n}; "
          },
          {
            "type": "file",
            "name": "department.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\department.service.js",
            "size": 256,
            "content": "const { prisma } = require('./database.service');\r\n\r\nclass DepartmentService {\r\n  async getAllDepartments() {\r\n    return await prisma.department.findMany();\r\n  }\r\n}\r\n\r\nconst departmentService = new DepartmentService();\r\nmodule.exports = departmentService;"
          },
          {
            "type": "file",
            "name": "email.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\email.service.js",
            "size": 3941,
            "content": "const nodemailer = require('nodemailer');\r\nconst { logger } = require('../utils/logger.util');\r\nrequire('dotenv').config();\r\n\r\n// Create a transporter using environment variables\r\nconst transporter = nodemailer.createTransport({\r\n  host: process.env.EMAIL_HOST,\r\n  port: process.env.EMAIL_PORT,\r\n  secure: process.env.EMAIL_PORT === 465, // true for 465, false for other ports\r\n  auth: {\r\n    user: process.env.EMAIL_USER,\r\n    pass: process.env.EMAIL_PASS,\r\n  },\r\n});\r\n\r\n// Verify connection configuration\r\nasync function verifyConnection() {\r\n  try {\r\n    await transporter.verify();\r\n    logger.info('Email service is ready to send messages');\r\n    return true;\r\n  } catch (error) {\r\n    logger.error('Email service connection error:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Send an email\r\nasync function sendEmail({ to, subject, text, html }) {\r\n  try {\r\n    const mailOptions = {\r\n      from: process.env.EMAIL_FROM,\r\n      to,\r\n      subject,\r\n      text,\r\n      html: html || text,\r\n    };\r\n\r\n    const info = await transporter.sendMail(mailOptions);\r\n    logger.info('Email sent successfully:', info.messageId);\r\n    return { success: true, messageId: info.messageId };\r\n  } catch (error) {\r\n    logger.error('Error sending email:', error);\r\n    return { success: false, error };\r\n  }\r\n}\r\n\r\n// Send verification email\r\nasync function sendVerificationEmail(user, verificationToken) {\r\n  const verificationUrl = `${process.env.CLIENT_URL}/verify-email?token=${verificationToken}`;\r\n  \r\n  return sendEmail({\r\n    to: user.email,\r\n    subject: 'Verify Your Email Address',\r\n    text: `Please verify your email by clicking on the following link: ${verificationUrl}`,\r\n    html: `\r\n      <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\r\n        <h2>Welcome to Our Platform!</h2>\r\n        <p>Thank you for signing up. Please verify your email address by clicking the button below:</p>\r\n        <div style=\"text-align: center; margin: 30px 0;\">\r\n          <a href=\"${verificationUrl}\" style=\"background-color: #4CAF50; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px;\">\r\n            Verify Email Address\r\n          </a>\r\n        </div>\r\n        <p>If the button doesn't work, you can also click on this link or copy and paste it into your browser:</p>\r\n        <p><a href=\"${verificationUrl}\">${verificationUrl}</a></p>\r\n        <p>This link will expire in 1 hour.</p>\r\n        <p>If you didn't sign up for our platform, please ignore this email.</p>\r\n      </div>\r\n    `,\r\n  });\r\n}\r\n\r\n// Send password reset email\r\nasync function sendPasswordResetEmail(user, resetToken) {\r\n  const resetUrl = `${process.env.CLIENT_URL}/reset-password?token=${resetToken}`;\r\n  \r\n  return sendEmail({\r\n    to: user.email,\r\n    subject: 'Reset Your Password',\r\n    text: `Please reset your password by clicking on the following link: ${resetUrl}. This link will expire in 1 hour.`,\r\n    html: `\r\n      <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\r\n        <h2>Password Reset Request</h2>\r\n        <p>We received a request to reset your password. Please click the button below to create a new password:</p>\r\n        <div style=\"text-align: center; margin: 30px 0;\">\r\n          <a href=\"${resetUrl}\" style=\"background-color: #4CAF50; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px;\">\r\n            Reset Password\r\n          </a>\r\n        </div>\r\n        <p>If the button doesn't work, you can also click on this link or copy and paste it into your browser:</p>\r\n        <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\r\n        <p>This link will expire in 10 minutes.</p>\r\n        <p>If you didn't request a password reset, please ignore this email or contact support if you have concerns.</p>\r\n      </div>\r\n    `,\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  verifyConnection,\r\n  sendEmail,\r\n  sendVerificationEmail,\r\n  sendPasswordResetEmail,\r\n}; "
          },
          {
            "type": "file",
            "name": "event.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\event.service.js",
            "size": 2269,
            "content": "const { prisma } = require('./database.service');\r\n\r\n// Follow an event\r\nconst followEvent = async (userId, eventId) => {\r\n  // Check if the user is already following the event\r\n  const existingFollow = await prisma.event.followers({\r\n    where: { id: eventId }\r\n  }).some(follower => follower.id === userId);\r\n  if (existingFollow) {\r\n    throw new Error('User is already following this event.');\r\n  }\r\n  await prisma.event.update({\r\n    where: { id: eventId },\r\n    data: {\r\n      followers: {\r\n        connect: { id: userId }\r\n      }\r\n    }\r\n  });\r\n  // Log the follow action\r\n  await prisma.eventFollowUnfollowLog.create({\r\n    data: {\r\n      userId,\r\n      eventId,\r\n      action: 'follow'\r\n    }\r\n  });\r\n};\r\n\r\n// Unfollow an event\r\nconst unfollowEvent = async (userId, eventId) => {\r\n  const existingFollow = await prisma.event.followers({\r\n    where: { id: eventId }\r\n  }).some(follower => follower.id === userId);\r\n  if (!existingFollow) {\r\n    throw new Error('User is not following this event.');\r\n  }\r\n  await prisma.event.update({\r\n    where: { id: eventId },\r\n    data: {\r\n      followers: {\r\n        disconnect: { id: userId }\r\n      }\r\n    }\r\n  });\r\n  // Log the unfollow action\r\n  await prisma.eventFollowUnfollowLog.create({\r\n    data: {\r\n      userId,\r\n      eventId,\r\n      action: 'unfollow'\r\n    }\r\n  });\r\n};\r\n\r\n// Log a user's visit to an event page\r\nconst logUserVisit = async (userId, eventId) => {\r\n  return await prisma.eventVisit.create({\r\n    data: {\r\n      userId,\r\n      eventId\r\n    }\r\n  });\r\n};\r\n\r\n// Search for events\r\nconst searchEvents = async (searchParams) => {\r\n  const { query, page = 1, limit = 10, sort } = searchParams;\r\n  const where = {\r\n    OR: [\r\n      { name: { contains: query, mode: 'insensitive' } },\r\n      { description: { contains: query, mode: 'insensitive' } },\r\n      { tags: { contains: query, mode: 'insensitive' } }\r\n    ]\r\n  };\r\n  const events = await prisma.event.findMany({\r\n    where,\r\n    skip: (page - 1) * limit,\r\n    take: limit,\r\n    orderBy: sort === 'newest' ? { startTime: 'desc' } : { name: 'asc' }\r\n  });\r\n  const totalCount = await prisma.event.count({ where });\r\n  return { events, totalCount };\r\n};\r\n\r\nmodule.exports = {\r\n  followEvent,\r\n  unfollowEvent,\r\n  logUserVisit,\r\n  searchEvents\r\n}; "
          },
          {
            "type": "file",
            "name": "notification.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\notification.service.js",
            "size": 13478,
            "content": "const { Server } = require('socket.io');\r\nconst { prisma } = require('./database.service');\r\nconst { logger } = require('../utils/logger.util');\r\nconst jwt = require('jsonwebtoken');\r\n\r\nclass NotificationService {\r\n  constructor() {\r\n    this.io = null;\r\n    this.userSockets = new Map(); // userId -> Set of socket ids\r\n    this.channels = new Map(); // channelName -> Set of userIds\r\n  }\r\n\r\n  initialize(server) {\r\n    this.io = new Server(server, {\r\n      cors: {\r\n        origin: process.env.CLIENT_URL,\r\n        methods: ['GET', 'POST'],\r\n        credentials: true\r\n      },\r\n      path: '/socket.io'\r\n    });\r\n\r\n    // Create notifications namespace\r\n    const notificationsNamespace = this.io.of('/notifications');\r\n\r\n    // Middleware to handle authentication\r\n    notificationsNamespace.use(async (socket, next) => {\r\n      try {\r\n        const token = socket.handshake.auth.token;\r\n        if (!token) {\r\n          logger.warn('Socket connection attempt without token');\r\n          return next(new Error('Authentication token required'));\r\n        }\r\n\r\n        const user = await this.verifyToken(token);\r\n        if (!user) {\r\n          logger.warn('Socket connection attempt with invalid token');\r\n          return next(new Error('Invalid authentication token'));\r\n        }\r\n\r\n        // Attach user to socket\r\n        socket.user = user;\r\n        logger.debug(`Socket authenticated for user ${user.id}`);\r\n        next();\r\n      } catch (error) {\r\n        logger.error('Socket middleware authentication error:', error);\r\n        next(new Error('Authentication failed'));\r\n      }\r\n    });\r\n\r\n    notificationsNamespace.on('connection', (socket) => {\r\n      logger.info(`Socket connected for user ${socket.user.id}`);\r\n      \r\n      // Store socket mapping\r\n      if (!this.userSockets.has(socket.user.id)) {\r\n        this.userSockets.set(socket.user.id, new Set());\r\n      }\r\n      this.userSockets.get(socket.user.id).add(socket.id);\r\n\r\n      // Join user's room\r\n      socket.join(`user:${socket.user.id}`);\r\n      \r\n      // Send authentication success\r\n      socket.emit('authenticated');\r\n\r\n      // Send initial unread count\r\n      this.getUnreadCount(socket.user.id)\r\n        .then(count => socket.emit('unread_count', count))\r\n        .catch(error => logger.error('Failed to get unread count:', error));\r\n\r\n      // Handle channel subscriptions\r\n      socket.on('subscribe', (channelName) => {\r\n        this.subscribeToChannel(socket.user.id, channelName);\r\n        socket.join(`channel:${channelName}`);\r\n        logger.debug(`User ${socket.user.id} subscribed to channel ${channelName}`);\r\n      });\r\n\r\n      socket.on('unsubscribe', (channelName) => {\r\n        this.unsubscribeFromChannel(socket.user.id, channelName);\r\n        socket.leave(`channel:${channelName}`);\r\n        logger.debug(`User ${socket.user.id} unsubscribed from channel ${channelName}`);\r\n      });\r\n\r\n      socket.on('disconnect', () => {\r\n        if (this.userSockets.has(socket.user.id)) {\r\n          this.userSockets.get(socket.user.id).delete(socket.id);\r\n          if (this.userSockets.get(socket.user.id).size === 0) {\r\n            this.userSockets.delete(socket.user.id);\r\n            // Clean up channel subscriptions\r\n            this.channels.forEach((subscribers, channel) => {\r\n              subscribers.delete(socket.user.id);\r\n              if (subscribers.size === 0) {\r\n                this.channels.delete(channel);\r\n              }\r\n            });\r\n          }\r\n          logger.debug(`Socket disconnected for user ${socket.user.id}`);\r\n        }\r\n      });\r\n\r\n      socket.on('mark_read', async (notificationId) => {\r\n        await this.markAsRead(socket.user.id, notificationId);\r\n      });\r\n\r\n      socket.on('mark_all_read', async () => {\r\n        await this.markAllAsRead(socket.user.id);\r\n      });\r\n    });\r\n\r\n    // Store the namespace reference\r\n    this.notificationsNamespace = notificationsNamespace;\r\n\r\n    logger.info('Notification service initialized with Socket.io');\r\n  }\r\n\r\n  handleConnection(socket) {\r\n    logger.debug('New socket connection attempt');\r\n\r\n    socket.on('auth', async (token) => {\r\n      try {\r\n        // Verify token and get user\r\n        const user = await this.verifyToken(token);\r\n        if (!user) {\r\n          logger.warn('Socket auth failed: Invalid token');\r\n          socket.emit('auth_error', 'Invalid token');\r\n          return;\r\n        }\r\n\r\n        // Store socket mapping\r\n        if (!this.userSockets.has(user.id)) {\r\n          this.userSockets.set(user.id, new Set());\r\n        }\r\n        this.userSockets.get(user.id).add(socket.id);\r\n\r\n        // Join user's room\r\n        socket.join(`user:${user.id}`);\r\n        \r\n        // Send authentication success\r\n        socket.emit('authenticated');\r\n        logger.debug(`Socket authenticated for user ${user.id}`);\r\n        \r\n        // Send unread notifications count\r\n        const unreadCount = await this.getUnreadCount(user.id);\r\n        socket.emit('unread_count', unreadCount);\r\n\r\n        // Handle channel subscriptions\r\n        socket.on('subscribe', (channelName) => {\r\n          this.subscribeToChannel(user.id, channelName);\r\n          socket.join(`channel:${channelName}`);\r\n          logger.debug(`User ${user.id} subscribed to channel ${channelName}`);\r\n        });\r\n\r\n        socket.on('unsubscribe', (channelName) => {\r\n          this.unsubscribeFromChannel(user.id, channelName);\r\n          socket.leave(`channel:${channelName}`);\r\n          logger.debug(`User ${user.id} unsubscribed from channel ${channelName}`);\r\n        });\r\n\r\n        socket.on('disconnect', () => {\r\n          if (this.userSockets.has(user.id)) {\r\n            this.userSockets.get(user.id).delete(socket.id);\r\n            if (this.userSockets.get(user.id).size === 0) {\r\n              this.userSockets.delete(user.id);\r\n              // Clean up channel subscriptions\r\n              this.channels.forEach((subscribers, channel) => {\r\n                subscribers.delete(user.id);\r\n                if (subscribers.size === 0) {\r\n                  this.channels.delete(channel);\r\n                }\r\n              });\r\n            }\r\n            logger.debug(`Socket disconnected for user ${user.id}`);\r\n          }\r\n        });\r\n\r\n        socket.on('mark_read', async (notificationId) => {\r\n          await this.markAsRead(user.id, notificationId);\r\n        });\r\n\r\n        socket.on('mark_all_read', async () => {\r\n          await this.markAllAsRead(user.id);\r\n        });\r\n\r\n      } catch (error) {\r\n        logger.error('Socket authentication error:', error);\r\n        socket.emit('auth_error', 'Authentication failed');\r\n      }\r\n    });\r\n  }\r\n\r\n  subscribeToChannel(userId, channelName) {\r\n    if (!this.channels.has(channelName)) {\r\n      this.channels.set(channelName, new Set());\r\n    }\r\n    this.channels.get(channelName).add(userId);\r\n  }\r\n\r\n  unsubscribeFromChannel(userId, channelName) {\r\n    if (this.channels.has(channelName)) {\r\n      this.channels.get(channelName).delete(userId);\r\n      if (this.channels.get(channelName).size === 0) {\r\n        this.channels.delete(channelName);\r\n      }\r\n    }\r\n  }\r\n\r\n  async broadcastToChannel(channelName, notification) {\r\n    try {\r\n      logger.debug(`Broadcasting to channel ${channelName}:`, notification);\r\n      \r\n      if (!this.channels.has(channelName)) {\r\n        logger.warn(`No subscribers for channel ${channelName}`);\r\n        return [];\r\n      }\r\n\r\n      const subscribers = Array.from(this.channels.get(channelName));\r\n      logger.debug(`Channel ${channelName} subscribers:`, subscribers);\r\n\r\n      const notifications = await Promise.all(\r\n        subscribers.map(userId =>\r\n          this.createNotification({\r\n            ...notification,\r\n            userId,\r\n            metadata: {\r\n              ...notification.metadata,\r\n              channel: channelName\r\n            }\r\n          })\r\n        )\r\n      );\r\n\r\n      // Emit to channel room using the namespace\r\n      logger.debug(`Emitting channel notification to channel:${channelName}`);\r\n      this.notificationsNamespace.to(`channel:${channelName}`).emit('channel_notification', {\r\n        channel: channelName,\r\n        notification\r\n      });\r\n\r\n      return notifications;\r\n    } catch (error) {\r\n      logger.error(`Failed to broadcast to channel ${channelName}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async verifyToken(token) {\r\n    try {\r\n      if (!token) return null;\r\n      \r\n      const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n      return await prisma.user.findUnique({\r\n        where: { id: decoded.userId },\r\n        select: { id: true, email: true, roles: true }\r\n      });\r\n    } catch (error) {\r\n      logger.error('Token verification failed:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async createNotification({ userId, title, message, type = 'INFO', metadata = {} }) {\r\n    try {\r\n      logger.debug(`Creating notification for user ${userId}:`, { title, message, type });\r\n      \r\n      const notification = await prisma.notification.create({\r\n        data: {\r\n          userId,\r\n          title,\r\n          message,\r\n          type,\r\n          metadata\r\n        }\r\n      });\r\n\r\n      logger.debug(`Notification created successfully:`, notification);\r\n\r\n      // Check if user has any active sockets\r\n      const userSockets = this.userSockets.get(userId);\r\n      logger.debug(`Active sockets for user ${userId}:`, userSockets ? Array.from(userSockets) : 'none');\r\n\r\n      // Emit to user's room using the namespace\r\n      logger.debug(`Emitting notification to user:${userId}`);\r\n      this.notificationsNamespace.to(`user:${userId}`).emit('notification', notification);\r\n\r\n      // Get updated unread count\r\n      const unreadCount = await this.getUnreadCount(userId);\r\n      logger.debug(`Emitting unread count ${unreadCount} to user:${userId}`);\r\n      this.notificationsNamespace.to(`user:${userId}`).emit('unread_count', unreadCount);\r\n\r\n      return notification;\r\n    } catch (error) {\r\n      logger.error('Failed to create notification:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getUnreadCount(userId) {\r\n    return await prisma.notification.count({\r\n      where: {\r\n        userId,\r\n        isRead: false\r\n      }\r\n    });\r\n  }\r\n\r\n  async markAsRead(userId, notificationId) {\r\n    try {\r\n      await prisma.notification.update({\r\n        where: {\r\n          id: notificationId,\r\n          userId // Ensure user owns the notification\r\n        },\r\n        data: {\r\n          isRead: true\r\n        }\r\n      });\r\n\r\n      const unreadCount = await this.getUnreadCount(userId);\r\n      this.notificationsNamespace.to(`user:${userId}`).emit('unread_count', unreadCount);\r\n    } catch (error) {\r\n      logger.error('Failed to mark notification as read:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async markAllAsRead(userId) {\r\n    try {\r\n      await prisma.notification.updateMany({\r\n        where: {\r\n          userId,\r\n          isRead: false\r\n        },\r\n        data: {\r\n          isRead: true\r\n        }\r\n      });\r\n\r\n      this.notificationsNamespace.to(`user:${userId}`).emit('unread_count', 0);\r\n    } catch (error) {\r\n      logger.error('Failed to mark all notifications as read:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getUserNotifications(userId, { page = 1, limit = 10, unreadOnly = false }) {\r\n    try {\r\n      const where = { userId };\r\n      if (unreadOnly) {\r\n        where.isRead = false;\r\n      }\r\n\r\n      const [notifications, total] = await Promise.all([\r\n        prisma.notification.findMany({\r\n          where,\r\n          orderBy: { createdAt: 'desc' },\r\n          skip: (page - 1) * limit,\r\n          take: limit\r\n        }),\r\n        prisma.notification.count({ where })\r\n      ]);\r\n\r\n      return {\r\n        notifications,\r\n        pagination: {\r\n          page,\r\n          limit,\r\n          total,\r\n          pages: Math.ceil(total / limit)\r\n        }\r\n      };\r\n    } catch (error) {\r\n      logger.error('Failed to get user notifications:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Helper method to broadcast to specific roles\r\n  async broadcastToRoles(roles, notification) {\r\n    try {\r\n      const users = await prisma.user.findMany({\r\n        where: {\r\n          roles: {\r\n            hasSome: roles\r\n          }\r\n        },\r\n        select: { id: true }\r\n      });\r\n\r\n      const notifications = await Promise.all(\r\n        users.map(user => this.createNotification({\r\n          ...notification,\r\n          userId: user.id\r\n        }))\r\n      );\r\n\r\n      return notifications;\r\n    } catch (error) {\r\n      logger.error('Failed to broadcast to roles:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async deleteNotification(userId, notificationId) {\r\n    try {\r\n      const notification = await prisma.notification.delete({\r\n        where: {\r\n          id: notificationId,\r\n          userId // Ensure user owns the notification\r\n        }\r\n      });\r\n\r\n      // Emit delete event to user's room\r\n      this.notificationsNamespace.to(`user:${userId}`).emit('notification_deleted', notificationId);\r\n\r\n      // Update unread count\r\n      const unreadCount = await this.getUnreadCount(userId);\r\n      this.notificationsNamespace.to(`user:${userId}`).emit('unread_count', unreadCount);\r\n\r\n      return notification;\r\n    } catch (error) {\r\n      logger.error('Failed to delete notification:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nconst notificationService = new NotificationService();\r\nmodule.exports = notificationService; "
          },
          {
            "type": "file",
            "name": "order.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\order.service.js",
            "size": 7198,
            "content": "const { PrismaClient } = require(\"@prisma/client\");\r\nconst crypto = require('crypto');\r\nconst prisma = new PrismaClient();\r\n\r\nexports.createOrder = async (userId, cartItems) => {\r\n  try {\r\n    console.log(\"Creating order for user:\", userId, \"with items:\", JSON.stringify(cartItems));\r\n    \r\n    return await prisma.$transaction(async (tx) => {\r\n      // Process cart items directly from the parameter\r\n      if (!cartItems || !Array.isArray(cartItems) || cartItems.length === 0) {\r\n        throw new Error(\"No items in cart\");\r\n      }\r\n\r\n      // Check if all meals exist\r\n      const mealIds = cartItems.map(item => item.mealId);\r\n      const meals = await tx.meal.findMany({\r\n        where: { id: { in: mealIds } }\r\n      });\r\n\r\n      if (meals.length !== mealIds.length) {\r\n        throw new Error(\"One or more meals not found\");\r\n      }\r\n\r\n      // Create orders\r\n      const orders = [];\r\n      for (const item of cartItems) {\r\n        const verificationCode = crypto.randomBytes(4).toString('hex').toUpperCase();\r\n        \r\n        // Set a default pickup time 1 hour from now (will be updated by manager later)\r\n        const defaultPickupTime = new Date();\r\n        defaultPickupTime.setHours(defaultPickupTime.getHours() + 1);\r\n        \r\n        const order = await tx.preorder.create({\r\n          data: {\r\n            quantity: item.quantity,\r\n            pickupTime: defaultPickupTime, // Use default time instead of null\r\n            verificationCode,\r\n            user: {\r\n              connect: { id: userId }\r\n            },\r\n            meal: {\r\n              connect: { id: item.mealId }\r\n            }\r\n          },\r\n          include: {\r\n            meal: true,\r\n            user: {\r\n              select: {\r\n                firstName: true,\r\n                lastName: true,\r\n                email: true\r\n              }\r\n            }\r\n          }\r\n        });\r\n        \r\n        orders.push(order);\r\n      }\r\n\r\n      // Fix cart clearing - find cart items for this user and delete them\r\n      try {\r\n        // Find cart first\r\n        const cart = await tx.cart.findFirst({\r\n          where: { userId },\r\n          select: { id: true }\r\n        });\r\n        \r\n        if (cart) {\r\n          // Delete cart items\r\n          await tx.cartItem.deleteMany({\r\n            where: { cartId: cart.id }\r\n          });\r\n        }\r\n      } catch (err) {\r\n        console.error(\"Failed to clear cart:\", err);\r\n        // Continue since order has been created successfully\r\n      }\r\n\r\n      return orders;\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Order creation failed with error:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\nexports.getUserOrders = async (userId) => {\r\n  return await prisma.preorder.findMany({\r\n    where: {\r\n      userId\r\n    },\r\n    include: {\r\n      meal: true,\r\n      user: {\r\n        select: {\r\n          firstName: true,\r\n          lastName: true,\r\n          email: true\r\n        }\r\n      }\r\n    },\r\n    orderBy: {\r\n      orderTime: 'desc'\r\n    }\r\n  });\r\n};\r\n\r\nexports.updateOrderStatus = async (orderId, status, pickupTime = null) => {\r\n  const validStatuses = ['placed', 'ready', 'picked_up', 'cancelled'];\r\n  \r\n  if (!validStatuses.includes(status)) {\r\n    throw new Error(`Invalid status. Must be one of: ${validStatuses.join(', ')}`);\r\n  }\r\n  \r\n  const updateData = { status };\r\n  \r\n  // If pickup time is provided and status is 'ready', update pickup time\r\n  if (pickupTime && status === 'ready') {\r\n    updateData.pickupTime = new Date(pickupTime);\r\n  }\r\n  \r\n  return await prisma.preorder.update({\r\n    where: { id: parseInt(orderId) },\r\n    data: updateData,\r\n    include: {\r\n      meal: true\r\n    }\r\n  });\r\n};\r\n\r\n// Update the verifyOrder function\r\n\r\n// Fix the verifyOrder function to use preorder instead of order\r\n\r\nexports.verifyOrder = async (verificationCode) => {\r\n  try {\r\n    console.log('Service attempting to verify code:', verificationCode);\r\n    \r\n    // Find order with matching verification code - CHANGE from \"order\" to \"preorder\"\r\n    const order = await prisma.preorder.findFirst({\r\n      where: {\r\n        verificationCode: verificationCode,\r\n        status: { in: ['placed', 'ready'] } // Only verify orders that are placed or ready\r\n      },\r\n      include: {\r\n        meal: true,\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            firstName: true,\r\n            lastName: true,\r\n            email: true,\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (!order) {\r\n      const error = new Error('Invalid verification code or order is not ready for pickup');\r\n      error.statusCode = 404;\r\n      throw error;\r\n    }\r\n\r\n    console.log('Order found:', order.id);\r\n\r\n    // Update the order status to 'picked_up' - CHANGE from \"order\" to \"preorder\"\r\n    const updatedOrder = await prisma.preorder.update({\r\n      where: { id: order.id },\r\n      data: { \r\n        status: 'picked_up',\r\n        pickupTime: new Date() // Update pickup time to current time\r\n      },\r\n      include: {\r\n        meal: true,\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            firstName: true,\r\n            lastName: true,\r\n            email: true,\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return updatedOrder;\r\n  } catch (error) {\r\n    console.error('Order verification error:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\n// Get all orders for management\r\nexports.getAllOrders = async () => {\r\n  return await prisma.preorder.findMany({\r\n    include: {\r\n      meal: true,\r\n      user: {\r\n        select: {\r\n          id: true,\r\n          firstName: true,\r\n          lastName: true,\r\n          email: true\r\n        }\r\n      }\r\n    },\r\n    orderBy: [\r\n      {\r\n        status: 'asc' // Put pending and active orders first\r\n      },\r\n      {\r\n        orderTime: 'desc' // Then sort by order time (newest first)\r\n      }\r\n    ]\r\n  });\r\n};\r\n\r\n\r\n// Approve an order\r\nexports.approveOrder = async (orderId) => {\r\n  // Check if order exists\r\n  const order = await prisma.preorder.findUnique({\r\n    where: { id: orderId }\r\n  });\r\n  \r\n  if (!order) {\r\n    throw new Error(\"Order not found\");\r\n  }\r\n  \r\n  // Update the order status to placed (approved)\r\n  return await prisma.preorder.update({\r\n    where: { id: orderId },\r\n    data: { \r\n      status: 'placed',\r\n      rejectionReason: null // Clear any previous rejection reason\r\n    },\r\n    include: {\r\n      meal: true,\r\n      user: {\r\n        select: {\r\n          firstName: true,\r\n          lastName: true,\r\n          email: true\r\n        }\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n\r\n// Reject an order with reason\r\nexports.rejectOrder = async (orderId, rejectionReason) => {\r\n  // Check if order exists\r\n  const order = await prisma.preorder.findUnique({\r\n    where: { id: orderId }\r\n  });\r\n  \r\n  if (!order) {\r\n    throw new Error(\"Order not found\");\r\n  }\r\n  \r\n  // Update the order status to cancelled with a reason\r\n  return await prisma.preorder.update({\r\n    where: { id: orderId },\r\n    data: { \r\n      status: 'cancelled',\r\n      rejectionReason: rejectionReason\r\n    },\r\n    include: {\r\n      meal: true,\r\n      user: {\r\n        select: {\r\n          firstName: true,\r\n          lastName: true,\r\n          email: true\r\n        }\r\n      }\r\n    }\r\n  });\r\n};"
          },
          {
            "type": "file",
            "name": "routine.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\routine.service.js",
            "size": 3703,
            "content": "const { prisma } = require('./database.service');\r\n\r\nconst setWeeklySchedule = async (userId, weekday, periods) => {\r\n  if (!userId) {\r\n    throw new Error('User ID is required');\r\n  }\r\n  return await prisma.routine.upsert({\r\n    where: { \r\n      weekday_userId: { \r\n        userId: userId, \r\n        weekday: weekday \r\n      } \r\n    },\r\n    update: { ...periods },\r\n    create: { userId, weekday, ...periods },\r\n  });\r\n};\r\n\r\nconst addCourse = async (userId, courseId, courseName, courseType) => {\r\n  if (!userId) {\r\n    throw new Error('User ID is required');\r\n  }\r\n\r\n  return await prisma.course.create({\r\n    data: {\r\n      courseId,\r\n      courseName,\r\n      courseType,\r\n      user: {\r\n        connect: {\r\n          id: userId\r\n        }\r\n      }\r\n    },\r\n  });\r\n};\r\n\r\nconst getWeeklySchedule = async (userId) => {\r\n  if (!userId) {\r\n    throw new Error('User ID is required');\r\n  }\r\n  return await prisma.routine.findMany({\r\n    where: { userId } ,\r\n  });\r\n};\r\n\r\nconst getCourses = async (userId) => {\r\n  return await prisma.course.findMany({\r\n    where: { userId },\r\n  });\r\n};\r\n\r\nconst addExam = async (userId, courseId, examType, syllabus, examDate) => {\r\n  if (!userId) {\r\n    throw new Error('User ID is required');\r\n  }\r\n\r\n  // First check if the course exists and belongs to the user\r\n  const course = await prisma.course.findFirst({\r\n    where: {\r\n      courseId: courseId,\r\n      userId: userId\r\n    }\r\n  });\r\n\r\n  if (!course) {\r\n    throw new Error('Course not found or you do not have permission to add an exam for this course');\r\n  }\r\n\r\n  return await prisma.exam.create({\r\n    data: {\r\n      examType,\r\n      syllabus,\r\n      examDate,\r\n      user: {\r\n        connect: {\r\n          id: userId\r\n        }\r\n      },\r\n      course: {\r\n        connect: {\r\n          id: course.id\r\n        }\r\n      }\r\n    },\r\n  });\r\n};\r\n\r\nconst updateExam = async (userId, examId, courseId, examType, syllabus, examDate) => {\r\n  if (!userId) {\r\n    throw new Error('User ID is required');\r\n  }\r\n\r\n  // First check if the exam belongs to the user\r\n  const exam = await prisma.exam.findFirst({\r\n    where: {\r\n      id: examId,\r\n      userId\r\n    },\r\n    include: {\r\n      course: true\r\n    }\r\n  });\r\n\r\n  if (!exam) {\r\n    throw new Error('Exam not found or you do not have permission to update it');\r\n  }\r\n\r\n  // Find the course by courseId\r\n  const course = await prisma.course.findFirst({\r\n    where: {\r\n      courseId: courseId.id,\r\n      userId: userId\r\n    }\r\n  });\r\n\r\n  if (!course) {\r\n    throw new Error(`Course with ID ${courseId} not found or you do not have permission to use it`);\r\n  }\r\n\r\n  return await prisma.exam.update({\r\n    where: { id: examId },\r\n    data: {\r\n      examType,\r\n      syllabus,\r\n      examDate,\r\n      course: {\r\n        connect: {\r\n          id: course.id\r\n        }\r\n      }\r\n    },\r\n    include: {\r\n      course: true\r\n    }\r\n  });\r\n};\r\n\r\nconst deleteExam = async (userId, examId) => {\r\n  if (!userId) {\r\n    throw new Error('User ID is required');\r\n  }\r\n\r\n  // First check if the exam belongs to the user\r\n  const exam = await prisma.exam.findFirst({\r\n    where: {\r\n      id: examId,\r\n      userId\r\n    }\r\n  });\r\n\r\n  if (!exam) {\r\n    throw new Error('Exam not found or you do not have permission to delete it');\r\n  }\r\n\r\n  return await prisma.exam.delete({\r\n    where: { id: examId }\r\n  });\r\n};\r\n\r\nconst getExams = async (userId) => {\r\n  if (!userId) {\r\n    throw new Error('User ID is required');\r\n  }\r\n  \r\n  return await prisma.exam.findMany({\r\n    where: { userId },\r\n    orderBy: { examDate: 'asc' }\r\n  });\r\n};\r\n\r\nmodule.exports = {\r\n  setWeeklySchedule,\r\n  addCourse,\r\n  getWeeklySchedule,\r\n  getCourses,\r\n  addExam,\r\n  updateExam,\r\n  deleteExam,\r\n  getExams,\r\n};\r\n"
          },
          {
            "type": "file",
            "name": "storage.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\storage.service.js",
            "size": 13883,
            "content": "const { supabaseAdmin } = require('../config/supabase');\r\nconst path = require('path');\r\nconst { v4: uuidv4 } = require('uuid');\r\nconst { logger } = require('../utils/logger.util');\r\nconst { ValidationError, NotFoundError } = require('../middleware/error.middleware');\r\nconst notificationService = require('./notification.service');\r\n\r\n// Connection status constants\r\nconst CONNECTION_STATUS = {\r\n  DISCONNECTED: 'disconnected',\r\n  CONNECTED: 'connected',\r\n  ERROR: 'error'\r\n};\r\n\r\n// Allowed file types and their corresponding MIME types\r\nconst ALLOWED_FILE_TYPES = {\r\n  images: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\r\n  documents: ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],\r\n  spreadsheets: ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],\r\n  presentations: ['application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation']\r\n};\r\n\r\n// Maximum file sizes in bytes\r\nconst MAX_FILE_SIZES = {\r\n  images: 5 * 1024 * 1024, // 5MB\r\n  documents: 10 * 1024 * 1024, // 10MB\r\n  spreadsheets: 10 * 1024 * 1024, // 10MB\r\n  presentations: 20 * 1024 * 1024, // 20MB\r\n  default: 5 * 1024 * 1024 // 5MB\r\n};\r\n\r\n/**\r\n * Supabase Storage Service for managing file uploads and retrievals\r\n */\r\nclass StorageService {\r\n  /**\r\n   * Initialize the storage service with bucket configuration\r\n   * @param {string} defaultBucket - The default storage bucket name\r\n   */\r\n  constructor(defaultBucket = 'app-uploads') {\r\n    this.defaultBucket = defaultBucket;\r\n    this.supabase = supabaseAdmin;\r\n    this.initialized = false;\r\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTED;\r\n    this.bucketConfigs = {\r\n      'app-uploads': { public: true, fileSizeLimit: MAX_FILE_SIZES.default },\r\n      'private-uploads': { public: false, fileSizeLimit: MAX_FILE_SIZES.documents },\r\n      'profile-pictures': { public: true, fileSizeLimit: MAX_FILE_SIZES.images }\r\n    };\r\n\r\n    // Log initial setup\r\n    logger.info('Storage service created', {\r\n      defaultBucket,\r\n      buckets: Object.keys(this.bucketConfigs)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get current connection status\r\n   * @returns {string} Current connection status\r\n   */\r\n  getConnectionStatus() {\r\n    return this.connectionStatus;\r\n  }\r\n\r\n  /**\r\n   * Initialize storage service and ensure buckets exist\r\n   */\r\n  async initialize() {\r\n    try {\r\n      if (this.initialized) {\r\n        logger.debug('Storage service already initialized');\r\n        return;\r\n      }\r\n      \r\n      logger.info('Initializing storage service...');\r\n      \r\n      // Check if the buckets exist, create them if not\r\n      const { data: buckets, error } = await this.supabase.storage.listBuckets();\r\n      \r\n      if (error) {\r\n        this.connectionStatus = CONNECTION_STATUS.ERROR;\r\n        logger.error('Failed to connect to storage service', {\r\n          error: error.message,\r\n          code: error.code,\r\n          status: this.connectionStatus\r\n        });\r\n        throw new Error(`Failed to list buckets: ${error.message}`);\r\n      }\r\n      \r\n      // Create missing buckets with their configurations\r\n      for (const [bucketName, config] of Object.entries(this.bucketConfigs)) {\r\n        const bucketExists = buckets.some(bucket => bucket.name === bucketName);\r\n        \r\n        if (!bucketExists) {\r\n          logger.info(`Creating storage bucket: ${bucketName}`, {\r\n            public: config.public,\r\n            sizeLimit: config.fileSizeLimit\r\n          });\r\n\r\n          const { error: createError } = await this.supabase.storage.createBucket(bucketName, {\r\n            public: config.public,\r\n            fileSizeLimit: config.fileSizeLimit,\r\n          });\r\n          \r\n          if (createError) {\r\n            this.connectionStatus = CONNECTION_STATUS.ERROR;\r\n            logger.error(`Failed to create bucket ${bucketName}`, {\r\n              error: createError.message,\r\n              code: createError.code,\r\n              status: this.connectionStatus\r\n            });\r\n            throw new Error(`Failed to create bucket ${bucketName}: ${createError.message}`);\r\n          }\r\n          \r\n          logger.info(`Created storage bucket: ${bucketName}`);\r\n        } else {\r\n          logger.debug(`Bucket ${bucketName} already exists`);\r\n        }\r\n      }\r\n      \r\n      this.initialized = true;\r\n      this.connectionStatus = CONNECTION_STATUS.CONNECTED;\r\n      logger.info('Storage service initialized successfully', {\r\n        status: this.connectionStatus,\r\n        buckets: buckets.map(b => b.name)\r\n      });\r\n    } catch (error) {\r\n      this.connectionStatus = CONNECTION_STATUS.ERROR;\r\n      logger.error('Storage service initialization failed', {\r\n        error: error.message,\r\n        status: this.connectionStatus,\r\n        initialized: this.initialized\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate file type and size\r\n   * @param {Object} file - The file object\r\n   * @param {string} category - The file category (images, documents, etc.)\r\n   * @throws {ValidationError} If validation fails\r\n   */\r\n  validateFile(file, category = 'default') {\r\n    // Check file size\r\n    const maxSize = MAX_FILE_SIZES[category] || MAX_FILE_SIZES.default;\r\n    if (file.size > maxSize) {\r\n      throw new ValidationError(`File size exceeds maximum limit of ${maxSize / (1024 * 1024)}MB`);\r\n    }\r\n\r\n    // Check file type if category is specified\r\n    if (category !== 'default' && ALLOWED_FILE_TYPES[category]) {\r\n      if (!ALLOWED_FILE_TYPES[category].includes(file.mimetype)) {\r\n        throw new ValidationError(`Invalid file type. Allowed types for ${category}: ${ALLOWED_FILE_TYPES[category].join(', ')}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Upload a file to storage with progress tracking and notifications\r\n   * @param {Object} file - The file object\r\n   * @param {Object} options - Upload options\r\n   * @returns {Object} - The uploaded file information\r\n   */\r\n  async uploadFile(file, {\r\n    folder = '',\r\n    bucketName = this.defaultBucket,\r\n    category = 'default',\r\n    userId = null,\r\n    isPrivate = false,\r\n    shareWithUsers = []\r\n  } = {}) {\r\n    try {\r\n      await this.initialize();\r\n      \r\n      if (!file || !file.buffer) {\r\n        logger.warn('Invalid file provided for upload', {\r\n          userId,\r\n          category,\r\n          bucket: bucketName\r\n        });\r\n        throw new ValidationError('Invalid file provided');\r\n      }\r\n\r\n      logger.info('Starting file upload', {\r\n        fileName: file.originalname,\r\n        size: file.size,\r\n        type: file.mimetype,\r\n        bucket: bucketName,\r\n        folder,\r\n        userId\r\n      });\r\n\r\n      // Validate file\r\n      this.validateFile(file, category);\r\n      \r\n      // Generate a unique file name\r\n      const fileExt = path.extname(file.originalname);\r\n      const fileName = `${uuidv4()}${fileExt}`;\r\n      const filePath = folder ? `${folder}/${fileName}` : fileName;\r\n\r\n      // Use private bucket if specified\r\n      const actualBucket = isPrivate ? 'private-uploads' : bucketName;\r\n      \r\n      // Upload file to Supabase\r\n      const { data, error } = await this.supabase.storage\r\n        .from(actualBucket)\r\n        .upload(filePath, file.buffer, {\r\n          contentType: file.mimetype,\r\n          cacheControl: '3600',\r\n          upsert: false\r\n        });\r\n      \r\n      if (error) {\r\n        throw new Error(`File upload failed: ${error.message}`);\r\n      }\r\n      \r\n      // Get file URL\r\n      const { data: urlData } = this.supabase.storage\r\n        .from(actualBucket)\r\n        .getPublicUrl(filePath);\r\n\r\n      const fileInfo = {\r\n        key: filePath,\r\n        url: urlData.publicUrl,\r\n        fileName,\r\n        originalName: file.originalname,\r\n        mimeType: file.mimetype,\r\n        size: file.size,\r\n        bucket: actualBucket,\r\n        isPrivate,\r\n        category,\r\n        uploadedBy: userId\r\n      };\r\n\r\n      // Send notification to uploader\r\n      if (userId) {\r\n        await notificationService.createNotification({\r\n          userId,\r\n          title: 'File Upload Success',\r\n          message: `${file.originalname} has been uploaded successfully`,\r\n          type: 'SUCCESS',\r\n          metadata: {\r\n            fileInfo: {\r\n              name: file.originalname,\r\n              size: file.size,\r\n              type: file.mimetype\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      // Share with users if specified\r\n      if (shareWithUsers.length > 0) {\r\n        await Promise.all(shareWithUsers.map(shareUserId =>\r\n          notificationService.createNotification({\r\n            userId: shareUserId,\r\n            title: 'File Shared With You',\r\n            message: `A file has been shared with you: ${file.originalname}`,\r\n            type: 'INFO',\r\n            metadata: {\r\n              fileInfo: {\r\n                name: file.originalname,\r\n                size: file.size,\r\n                type: file.mimetype,\r\n                url: urlData.publicUrl\r\n              }\r\n            }\r\n          })\r\n        ));\r\n      }\r\n      \r\n      logger.info('File upload completed successfully', {\r\n        fileName: fileInfo.originalName,\r\n        key: fileInfo.key,\r\n        bucket: fileInfo.bucket,\r\n        size: fileInfo.size\r\n      });\r\n\r\n      return fileInfo;\r\n    } catch (error) {\r\n      logger.error('File upload failed', {\r\n        error: error.message,\r\n        fileName: file?.originalname,\r\n        userId,\r\n        bucket: bucketName,\r\n        category\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Share a file with users\r\n   * @param {string} fileKey - The file key\r\n   * @param {string[]} userIds - Array of user IDs to share with\r\n   * @param {string} sharedBy - ID of user sharing the file\r\n   */\r\n  async shareFile(fileKey, userIds, sharedBy) {\r\n    try {\r\n      const fileUrl = this.getFileUrl(fileKey);\r\n      \r\n      await Promise.all(userIds.map(userId =>\r\n        notificationService.createNotification({\r\n          userId,\r\n          title: 'New File Shared',\r\n          message: 'A file has been shared with you',\r\n          type: 'INFO',\r\n          metadata: {\r\n            fileKey,\r\n            fileUrl,\r\n            sharedBy\r\n          }\r\n        })\r\n      ));\r\n\r\n      return true;\r\n    } catch (error) {\r\n      logger.error(`File sharing failed: ${error.message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the public URL for a file\r\n   * @param {string} filePath - The file path within the bucket\r\n   * @param {string} bucketName - Optional bucket name\r\n   * @returns {string} - The file's public URL\r\n   */\r\n  getFileUrl(filePath, bucketName = this.defaultBucket) {\r\n    try {\r\n      const { data } = this.supabase.storage\r\n        .from(bucketName)\r\n        .getPublicUrl(filePath);\r\n      \r\n      return data.publicUrl;\r\n    } catch (error) {\r\n      logger.error(`Failed to get file URL: ${error.message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Download a file's data\r\n   * @param {string} filePath - The file path within the bucket\r\n   * @param {string} bucketName - Optional bucket name\r\n   * @returns {Buffer} - The file data as a buffer\r\n   */\r\n  async downloadFile(filePath, bucketName = this.defaultBucket) {\r\n    try {\r\n      await this.initialize();\r\n      \r\n      const { data, error } = await this.supabase.storage\r\n        .from(bucketName)\r\n        .download(filePath);\r\n      \r\n      if (error) {\r\n        throw new NotFoundError(`File download failed: ${error.message}`);\r\n      }\r\n      \r\n      return data;\r\n    } catch (error) {\r\n      logger.error(`File download failed: ${error.message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a file and notify relevant users\r\n   * @param {string} filePath - The file path\r\n   * @param {Object} options - Delete options\r\n   */\r\n  async deleteFile(filePath, { bucketName = this.defaultBucket, userId = null } = {}) {\r\n    try {\r\n      await this.initialize();\r\n      \r\n      const { error } = await this.supabase.storage\r\n        .from(bucketName)\r\n        .remove([filePath]);\r\n      \r\n      if (error) {\r\n        throw new Error(`File deletion failed: ${error.message}`);\r\n      }\r\n\r\n      // Notify user of successful deletion\r\n      if (userId) {\r\n        await notificationService.createNotification({\r\n          userId,\r\n          title: 'File Deleted',\r\n          message: `File ${path.basename(filePath)} has been deleted successfully`,\r\n          type: 'SUCCESS'\r\n        });\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      // Notify user of deletion failure\r\n      if (userId) {\r\n        await notificationService.createNotification({\r\n          userId,\r\n          title: 'File Deletion Failed',\r\n          message: `Failed to delete ${path.basename(filePath)}: ${error.message}`,\r\n          type: 'ERROR'\r\n        });\r\n      }\r\n\r\n      logger.error(`File deletion failed: ${error.message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * List files in a bucket or folder\r\n   * @param {string} folder - Optional folder path\r\n   * @param {string} bucketName - Optional bucket name\r\n   * @returns {Array} - Array of file objects\r\n   */\r\n  async listFiles(folder = '', bucketName = this.defaultBucket) {\r\n    try {\r\n      await this.initialize();\r\n      \r\n      const { data, error } = await this.supabase.storage\r\n        .from(bucketName)\r\n        .list(folder);\r\n      \r\n      if (error) {\r\n        throw new Error(`Failed to list files: ${error.message}`);\r\n      }\r\n      \r\n      return data;\r\n    } catch (error) {\r\n      logger.error(`Failed to list files: ${error.message}`);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// Create and export an instance of the storage service\r\nconst storageService = new StorageService();\r\n\r\n// Log service creation\r\nlogger.info('Storage service instance created');\r\n\r\nmodule.exports = storageService; "
          },
          {
            "type": "file",
            "name": "user.service.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\services\\user.service.js",
            "size": 2561,
            "content": "const { prisma } = require('./database.service');\r\nconst bcrypt = require('bcrypt');\r\nconst { logger } = require('../utils/logger.util');\r\n\r\nclass UserService {\r\n  async updateProfile(userId, data) {\r\n    try {\r\n      const { name, phone, address } = data;\r\n      \r\n      const user = await prisma.user.update({\r\n        where: { id: userId },\r\n        data: {\r\n          name,\r\n          phone,\r\n          address\r\n        },\r\n        select: {\r\n          id: true,\r\n          email: true,\r\n          name: true,\r\n          phone: true,\r\n          address: true,\r\n          roles: true,\r\n          status: true,\r\n          emailVerified: true,\r\n          profile: true\r\n        }\r\n      });\r\n\r\n      logger.info(`Profile updated for user ${userId}`);\r\n      return user;\r\n    } catch (error) {\r\n      logger.error('Failed to update profile:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async changePassword(userId, { currentPassword, newPassword }) {\r\n    try {\r\n      // Get user with current password hash\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n        select: { password: true }\r\n      });\r\n\r\n      if (!user) {\r\n        throw new Error('User not found');\r\n      }\r\n\r\n      // Verify current password\r\n      const isValid = await bcrypt.compare(currentPassword, user.password);\r\n      if (!isValid) {\r\n        throw new Error('Current password is incorrect');\r\n      }\r\n\r\n      // Hash new password\r\n      const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n\r\n      // Update password\r\n      await prisma.user.update({\r\n        where: { id: userId },\r\n        data: { password: hashedPassword }\r\n      });\r\n\r\n      logger.info(`Password changed for user ${userId}`);\r\n      return { message: 'Password updated successfully' };\r\n    } catch (error) {\r\n      logger.error('Failed to change password:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getUserProfile(userId) {\r\n    try {\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n        select: {\r\n          id: true,\r\n          email: true,\r\n          name: true,\r\n          roles: true,\r\n          status: true,\r\n          emailVerified: true,\r\n          createdAt: true,\r\n          updatedAt: true\r\n        }\r\n      });\r\n\r\n      if (!user) {\r\n        throw new Error('User not found');\r\n      }\r\n\r\n      return user;\r\n    } catch (error) {\r\n      logger.error('Failed to get user profile:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nconst userService = new UserService();\r\nmodule.exports = userService; "
          }
        ]
      },
      {
        "type": "directory",
        "name": "utils",
        "path": "E:\\Work\\MIST_Hackathon\\server\\src\\utils",
        "children": [
          {
            "type": "file",
            "name": "logger.util.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\utils\\logger.util.js",
            "size": 1545,
            "content": "const winston = require('winston');\r\nconst path = require('path');\r\n\r\n// Define log levels\r\nconst levels = {\r\n  error: 0,\r\n  warn: 1,\r\n  info: 2,\r\n  http: 3,\r\n  debug: 4,\r\n};\r\n\r\n// Define log level based on environment\r\nconst level = () => {\r\n  const env = process.env.NODE_ENV || 'development';\r\n  return env === 'development' ? 'debug' : 'info';\r\n};\r\n\r\n// Define colors for each level\r\nconst colors = {\r\n  error: 'red',\r\n  warn: 'yellow',\r\n  info: 'green',\r\n  http: 'magenta',\r\n  debug: 'blue',\r\n};\r\n\r\n// Add colors to winston\r\nwinston.addColors(colors);\r\n\r\n// Define the format for logging\r\nconst format = winston.format.combine(\r\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),\r\n  winston.format.colorize({ all: true }),\r\n  winston.format.printf(\r\n    (info) => `${info.timestamp} ${info.level}: ${info.message}`\r\n  )\r\n);\r\n\r\n// Define transport for file logging\r\nconst transports = [\r\n  // Console transport\r\n  new winston.transports.Console(),\r\n  \r\n  // Error log file\r\n  new winston.transports.File({\r\n    filename: path.join(__dirname, '../../logs/error.log'),\r\n    level: 'error',\r\n  }),\r\n  \r\n  // All logs file\r\n  new winston.transports.File({ \r\n    filename: path.join(__dirname, '../../logs/all.log') \r\n  }),\r\n];\r\n\r\n// Create the logger\r\nconst logger = winston.createLogger({\r\n  level: level(),\r\n  levels,\r\n  format,\r\n  transports,\r\n});\r\n\r\n// Create a stream object for morgan http logger to use\r\nconst stream = {\r\n  write: (message) => logger.http(message.trim()),\r\n};\r\n\r\nmodule.exports = {\r\n  logger,\r\n  stream\r\n};"
          },
          {
            "type": "file",
            "name": "response.util.js",
            "path": "E:\\Work\\MIST_Hackathon\\server\\src\\utils\\response.util.js",
            "size": 2965,
            "content": "/**\r\n * Response utility for standardizing API responses across the application\r\n * Format is designed to be compatible with Supabase response structure\r\n */\r\n\r\n/**\r\n * Creates a success response object\r\n * @param {Object} data - The data to be returned\r\n * @param {string} message - Optional success message\r\n * @param {number} statusCode - HTTP status code\r\n * @returns {Object} Standardized success response\r\n */\r\nconst successResponse = (data = null, message = 'Operation successful', statusCode = 200) => {\r\n  return {\r\n    status: statusCode,\r\n    success: true,\r\n    message,\r\n    data,\r\n    error: null,\r\n  };\r\n};\r\n\r\n/**\r\n * Creates an error response object\r\n * @param {string} message - Error message\r\n * @param {number} statusCode - HTTP status code\r\n * @param {Object} errorDetails - Additional error details (optional)\r\n * @returns {Object} Standardized error response\r\n */\r\nconst errorResponse = (message, statusCode = 400, errorDetails = null) => {\r\n  // Create a standardized error object\r\n  const error = {\r\n    message,\r\n    code: statusCode,\r\n    details: errorDetails\r\n  };\r\n\r\n  return {\r\n    status: statusCode,\r\n    success: false,\r\n    message,\r\n    data: null,\r\n    error\r\n  };\r\n};\r\n\r\n/**\r\n * Send a success response\r\n * @param {Object} res - Express response object\r\n * @param {Object} data - Data to send\r\n * @param {string} message - Success message\r\n * @param {number} statusCode - HTTP status code\r\n */\r\nconst sendSuccess = (res, data = null, message = 'Operation successful', statusCode = 200) => {\r\n  return res.status(statusCode).json(successResponse(data, message, statusCode));\r\n};\r\n\r\n/**\r\n * Send an error response\r\n * @param {Object} res - Express response object\r\n * @param {string} message - Error message\r\n * @param {number} statusCode - HTTP status code\r\n * @param {Object} errorDetails - Additional error details\r\n */\r\nconst sendError = (res, message = 'An error occurred', statusCode = 400, errorDetails = null) => {\r\n  return res.status(statusCode).json(errorResponse(message, statusCode, errorDetails));\r\n};\r\n\r\n/**\r\n * Maps common error types to appropriate HTTP status codes\r\n * @param {Error} error - The error object\r\n * @returns {number} - Appropriate HTTP status code\r\n */\r\nconst getErrorStatusCode = (error) => {\r\n  if (error.name === 'ValidationError') return 400;\r\n  if (error.name === 'UnauthorizedError') return 401;\r\n  if (error.name === 'ForbiddenError') return 403;\r\n  if (error.name === 'NotFoundError') return 404;\r\n  if (error.name === 'ConflictError') return 409;\r\n  if (error.name === 'RateLimitError') return 429;\r\n  \r\n  // If this is a Prisma error, handle specific cases\r\n  if (error.code) {\r\n    // Prisma unique constraint violation\r\n    if (error.code === 'P2002') return 409;\r\n    // Prisma record not found\r\n    if (error.code === 'P2025') return 404;\r\n  }\r\n  \r\n  return 500;\r\n};\r\n\r\nmodule.exports = {\r\n  successResponse,\r\n  errorResponse,\r\n  sendSuccess,\r\n  sendError,\r\n  getErrorStatusCode\r\n}; "
          }
        ]
      },
      {
        "type": "directory",
        "name": "validators",
        "path": "E:\\Work\\MIST_Hackathon\\server\\src\\validators",
        "children": []
      }
    ]
  }
]